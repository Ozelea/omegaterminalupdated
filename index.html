<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;"> -->
    <title>Omega Terminal v2.0.1 - Modern Apple UI - Polymarket Working</title>
    <script>
      // Disable redirect loop - let page load normally
      console.log("‚úÖ Page loading without redirect loop");
    </script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"
      type="application/javascript"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/eth-crypto@2.1.2/dist/lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.1/lib/index.iife.min.js"></script>
    <link rel="stylesheet" href="styles/gui-themes.css" />
    <link rel="stylesheet" href="themes-crypto.css" />
    <link rel="stylesheet" href="apple-ui-theme.css" />
    <link rel="stylesheet" href="simple-input-fix.css" />
    <link rel="stylesheet" href="mobile-terminal-fix.css" />
    <link rel="stylesheet" href="mobile-games-fix.css" />
    <script src="dexscreener-enhanced-fixed.js"></script>
    <script src="dexscreener-analytics-ultimate.js"></script>
    <script src="metamask-connection-fix.js"></script>
    <script src="theme-crypto-plugin.js"></script>
    <script src="ref-simple.js"></script>
    <!-- <script src="near-wallet-plugin.js"></script> DISABLED: Was breaking existing NEAR commands -->
    <script src="near-wallet-connection-fix.js"></script>
    <script src="bot-manager-plugin.js"></script>
    <!-- <script src="input-visibility-hotfix.js"></script> DISABLED: Causing issues -->
    <!-- <script src="apple-ui-input-override.js"></script> DISABLED: Causing duplicate text -->
    <script src="apple-ui-plugin.js"></script>
    <script src="defillama-api-plugin.js"></script>
    <!-- <script src="opensea-nft-plugin.js"></script> REPLACED WITH ENHANCED VERSION -->
    <script src="opensea-enhanced-plugin.js"></script>

    <script src="enhanced-profile-system.js?v=kalshi-fixed-20251009"></script>
    <script src="terminal-chatter-mode.js"></script>
    <script src="python-integration-system.js"></script>
    <script src="pgt-integration-live.js"></script>
    <script src="pgt-cors-proxy.js"></script>
    <script src="pgt-nft-generator.js"></script>
    <script src="pgt-ui-overlay.js"></script>
    <!-- <script src="rome-network-plugin.js"></script> DISABLED: Rome commands integrated directly into index.html -->
    <!-- <script src="megaeth-network-plugin.js"></script> DISABLED: Not needed -->
    <script src="terminal-games-system.js"></script>
    <!-- <script src="simple-terminal-builder.js"></script> DISABLED: Causing conflicts -->
    <script src="omega-nft-onchain.js"></script>
    <script>
      // VERSION CHECK - This should be visible in console if updated code is loaded
      console.log("üöÄ OMEGA TERMINAL VERSION 2.0.1 LOADED");
      console.log("üöÄ OMEGA TERMINAL v2.0.1 - MODERN APPLE UI READY");
      console.log("üöÄ TIMESTAMP: " + new Date().toISOString());

      // Force cache bust for modern UI update
      if (
        !window.location.search.includes("v=modernui") &&
        !window.location.search.includes("appleui2025")
      ) {
        const timestamp = Date.now();
        const newUrl =
          window.location.href.split("?")[0] + "?v=modernui" + timestamp;
        console.log(
          "üöÄ OMEGA TERMINAL v2.0.1 - MODERN APPLE UI - CACHE UPDATING"
        );
        window.location.href = newUrl;
      }

      // Simple base58 decoder implementation
      const base58Chars =
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      const base58Lookup = {};
      for (let i = 0; i < base58Chars.length; i++) {
        base58Lookup[base58Chars[i]] = i;
      }

      function base58Decode(str) {
        let decoded = 0n;
        let multi = 1n;
        const base = 58n;

        for (let i = str.length - 1; i >= 0; i--) {
          const char = str[i];
          if (!(char in base58Lookup)) {
            throw new Error("Invalid base58 character: " + char);
          }
          decoded += BigInt(base58Lookup[char]) * multi;
          multi *= base;
        }

        // Convert to bytes
        const bytes = [];
        while (decoded > 0n) {
          bytes.unshift(Number(decoded % 256n));
          decoded = decoded / 256n;
        }

        // Handle leading zeros
        for (let i = 0; i < str.length && str[i] === "1"; i++) {
          bytes.unshift(0);
        }

        return new Uint8Array(bytes);
      }
    </script>
    <script>
      // Ensure Solana Web3 is accessible
      if (
        typeof window.solanaWeb3 === "undefined" &&
        typeof solanaWeb3 !== "undefined"
      ) {
        window.solanaWeb3 = solanaWeb3;
      }

      // Completely prevent Phantom from taking over window.ethereum
      const originalEthereum = window.ethereum;
      if (originalEthereum && originalEthereum.isPhantom) {
        console.log("Phantom detected in early script - blocking immediately");
        // Store the original providers before Phantom takes over
        const providers = originalEthereum.providers || [];
        const metamaskProvider = providers.find((p) => p.isMetaMask);

        if (metamaskProvider) {
          window.ethereum = metamaskProvider;
          console.log("MetaMask restored in early script");
        } else {
          window.ethereum = null;
          console.log("No MetaMask found - blocking all wallets");
        }
      }

      // Force MetaMask preference immediately after libraries load
      (function () {
        // More aggressive MetaMask forcing
        if (
          window.ethereum &&
          window.ethereum.providers &&
          Array.isArray(window.ethereum.providers)
        ) {
          const metamaskProvider = window.ethereum.providers.find(
            (p) => p.isMetaMask
          );
          if (metamaskProvider) {
            // Completely replace window.ethereum with MetaMask
            window.ethereum = metamaskProvider;
            console.log("MetaMask provider selected (early)");

            // Also set a flag to prevent other providers from taking over
            window.ethereum._forceMetaMask = true;
          }
        }

        // Additional check: if we detect Phantom, try to find MetaMask again
        if (
          window.ethereum &&
          window.ethereum.isPhantom &&
          !window.ethereum._forceMetaMask
        ) {
          console.log("Phantom detected, searching for MetaMask...");
          // Look for MetaMask in the original providers array
          if (
            window.ethereum.providers &&
            Array.isArray(window.ethereum.providers)
          ) {
            const metamaskProvider = window.ethereum.providers.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              window.ethereum = metamaskProvider;
              window.ethereum._forceMetaMask = true;
              console.log("MetaMask found and forced after Phantom detection");
            }
          }
        }
      })();
    </script>
    <style>
      /* iOS Message Animations */
      @keyframes slideInRight {
        from {
          transform: translateX(100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideInLeft {
        from {
          transform: translateX(-100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background-color: #000;
        color: #ffffff;
        font-family: "Courier New", monospace;
        font-size: 14px;
        line-height: 1.4;
        overflow: hidden;
      }

      /* Polymarket UI Variables */
      :root {
        --poly-text-primary: #1f2937;
        --poly-text-secondary: #6b7280;
        --poly-bg-primary: rgba(255, 255, 255, 0.05);
        --poly-bg-secondary: rgba(255, 255, 255, 0.1);
        --poly-border: rgba(255, 255, 255, 0.1);
        --poly-shadow: rgba(0, 0, 0, 0.1);
        --poly-backdrop: blur(10px);
      }

      /* Light theme overrides */
      [data-theme="light"] {
        --poly-text-primary: #111827;
        --poly-text-secondary: #6b7280;
        --poly-bg-primary: rgba(255, 255, 255, 0.8);
        --poly-bg-secondary: rgba(255, 255, 255, 0.9);
        --poly-border: rgba(0, 0, 0, 0.1);
        --poly-shadow: rgba(0, 0, 0, 0.05);
        --poly-backdrop: blur(20px);
      }

      .terminal {
        width: 100vw;
        height: 100dvh;
        padding: 20px;
        background: linear-gradient(135deg, #000 0%, #111111 100%);
        position: relative;
        display: flex;
        flex-direction: column;
      }

      .terminal-header {
        border-bottom: 1px solid #ffffff;
        padding-bottom: 10px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .terminal-title {
        font-size: 28px;
        font-weight: bold;
        text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      .terminal-status {
        font-size: 12px;
        color: #cccccc;
      }

      .theme-toggle {
        width: 22px;
        height: 22px;
        background: transparent;
        border: 2px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        margin-right: 0;
        margin-left: 0;
        display: inline-block;
        transition: border-color 0.2s;
        box-sizing: border-box;
        outline: none;
      }

      .theme-toggle:hover {
        border-color: #99ccff;
        background: rgba(255, 255, 255, 0.05);
      }

      .ai-toggle {
        background: #ffffff;
        border: 1px solid #ffffff;
        border-radius: 4px;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 12px;
        color: #333333;
        font-family: "Courier New", monospace;
        transition: all 0.3s ease;
        outline: none;
      }

      .ai-toggle:hover {
        background: #f0f0f0;
        border-color: #f0f0f0;
        color: #000000;
      }

      .terminal-input-section {
        border-top: 1px solid #ffffff;
        padding-top: 10px;
        margin-top: auto;
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 5px;
        border: 1px solid #ffffff;
      }

      .terminal-content {
        flex: 1;
        overflow-y: auto;
        padding-right: 10px;
        margin-bottom: 20px;
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      /* Modal popup styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: linear-gradient(135deg, #000 0%, #111111 100%);
        border: 2px solid #ffffff;
        border-radius: 10px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        animation: modalFadeIn 0.5s ease-out;
      }

      @keyframes modalFadeIn {
        from {
          opacity: 0;
          transform: scale(0.8) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .modal-title {
        font-size: 24px;
        font-weight: bold;
        color: #ffffff;
        margin-bottom: 20px;
        text-shadow: 0 0 15px #ffffff;
        letter-spacing: 2px;
      }

      .modal-steps {
        text-align: left;
        margin: 20px 0;
      }

      .modal-step {
        font-size: 16px;
        color: #ffffff;
        margin: 15px 0;
        padding: 10px;
        border-left: 3px solid #33bbff;
        background: rgba(51, 187, 255, 0.1);
      }

      .modal-step-number {
        color: #33bbff;
        font-weight: bold;
        margin-right: 10px;
      }

      .modal-button {
        background: linear-gradient(135deg, #33bbff 0%, #0066cc 100%);
        border: none;
        color: white;
        padding: 12px 30px;
        font-size: 16px;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .modal-button:hover {
        background: linear-gradient(135deg, #66ccff 0%, #0099ff 100%);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(51, 187, 255, 0.4);
      }

      .terminal-line {
        margin-bottom: 5px;
        word-wrap: break-word;
      }

      .prompt {
        color: #ffffff;
        font-weight: bold;
      }

      .command {
        color: #ffffff;
      }

      .output {
        color: #cccccc;
        margin-left: 20px;
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .error {
        color: #ff6666;
      }

      .success {
        color: #ffffff;
      }

      .warning {
        color: #ffffcc;
      }

      .info {
        color: #99ccff;
      }

      .mining-status {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #ffffff;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #111111;
        border: 1px solid #ffffff;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ffffff, #cccccc);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px #ffffff;
      }

      .input-line {
        display: flex;
        align-items: center;
        background: transparent;
      }

      .input-prompt {
        color: #ffffff;
        font-weight: bold;
        margin-right: 10px;
        font-size: 16px;
      }

      .input-field {
        background: transparent;
        border: none;
        color: #ffffff;
        font-family: "Courier New", monospace;
        font-size: 16px;
        outline: none;
        flex: 1;
        padding: 5px;
      }

      .input-field::placeholder {
        color: #666666;
      }

      .cursor {
        display: none !important;
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      .mining-animation {
        display: inline-block;
        animation: mining-pulse 2s infinite;
      }

      @keyframes mining-pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin: 10px 0;
      }

      .stat-box {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid #ffffff;
        padding: 10px;
        border-radius: 5px;
      }

      .stat-label {
        color: #cccccc;
        font-size: 12px;
      }

      .stat-value {
        color: #ffffff;
        font-size: 16px;
        font-weight: bold;
      }

      /* Boot Animation Styles */
      .boot-animation {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Courier New", monospace;
      }

      .omega-symbols {
        font-size: 48px;
        color: #ffffff;
        text-shadow: 0 0 20px #ffffff;
        margin-bottom: 20px;
        animation: omega-float 3s ease-in-out infinite;
      }

      .pickaxe {
        font-size: 36px;
        color: #ffcc00;
        text-shadow: 0 0 15px #ffcc00;
        animation: pickaxe-swing 2s ease-in-out infinite;
        margin-bottom: 30px;
      }

      .welcome-text {
        font-size: 24px;
        color: #ffffff;
        text-align: center;
        line-height: 1.5;
        text-shadow: 0 0 10px #ffffff;
      }

      .loading-dots {
        font-size: 18px;
        color: #cccccc;
        margin-top: 20px;
        animation: loading-pulse 1.5s ease-in-out infinite;
      }

      @keyframes omega-float {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @keyframes pickaxe-swing {
        0%,
        100% {
          transform: rotate(-15deg);
        }
        50% {
          transform: rotate(15deg);
        }
      }

      @keyframes loading-pulse {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
      }

      .hidden {
        display: none !important;
      }

      /* Light Theme Styles */
      .terminal.light-theme {
        background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
        color: #000000;
      }

      .terminal.light-theme .terminal-header {
        border-bottom: 1px solid #000000;
      }

      .terminal.light-theme .terminal-title {
        color: #000000;
        text-shadow: 0 0 15px #000000, 0 0 30px #000000;
      }

      .terminal.light-theme .terminal-status {
        color: #333333;
      }

      .terminal.light-theme .theme-toggle {
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid #000000;
        color: #000000;
      }

      .terminal.light-theme .theme-toggle:hover {
        background: rgba(0, 0, 0, 0.2);
      }

      .terminal.light-theme .terminal-input-section {
        border-top: 1px solid #000000;
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid #000000;
      }

      .terminal.light-theme .prompt {
        color: #000000;
      }

      .terminal.light-theme .command {
        color: #000000;
      }

      .terminal.light-theme .output {
        color: #333333;
      }

      .terminal.light-theme .error {
        color: #cc0000;
      }

      .terminal.light-theme .success {
        color: #000000;
      }

      .terminal.light-theme .warning {
        color: #cc6600;
      }

      .terminal.light-theme .info {
        color: #0066cc;
      }

      .terminal.light-theme .input-prompt {
        color: #000000;
      }

      .terminal.light-theme .input-field {
        color: #000000;
      }

      .terminal.light-theme .input-field::placeholder {
        color: #666666;
      }

      .terminal.light-theme .cursor {
        display: none !important;
      }

      .terminal.light-theme .mining-status {
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid #000000;
      }

      .terminal.light-theme .stat-box {
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid #000000;
      }

      .terminal.light-theme .stat-label {
        color: #333333;
      }

      .terminal.light-theme .stat-value {
        color: #000000;
      }

      .output.error {
        color: #ff3333 !important;
        font-weight: bold !important;
      }

      /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
      .terminal-content .output.error,
      .output.error {
        color: #ff3333 !important;
        font-weight: bold !important;
      }

      .terminal-content,
      .output,
      .output.error,
      .output.success,
      .output.info,
      .output.warning,
      .terminal-content *,
      .output *,
      .output.error *,
      .output.success *,
      .output.info *,
      .output.warning * {
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .terminal-line .copyable {
        cursor: pointer;
        text-decoration: underline;
        color: #00ff00;
        transition: all 0.3s ease;
      }

      .terminal-line .copyable:hover {
        color: #ffff00;
        text-shadow: 0 0 10px #ffff00;
      }

      .terminal-line .copyable:active {
        color: #ff0000;
      }

      body.theme-dark {
        background: #000;
        color: #fff;
      }
      body.theme-light {
        background: #fff;
        color: #111;
      }
      body.theme-matrix {
        background: #000;
        color: #00ff00;
      }
      body.theme-retro {
        background: #111;
        color: #39ff14;
      }
      .theme-matrix .terminal-header,
      .theme-retro .terminal-header {
        border-bottom: 1px solid #00ff00;
      }
      .theme-matrix .input-prompt,
      .theme-retro .input-prompt {
        color: #39ff14;
      }
      .theme-retro .input-prompt {
        color: orange;
      }

      /* Matrix Theme Styles */
      body.theme-matrix {
        background: #000 !important;
        color: #00ff00 !important;
      }
      body.theme-matrix .terminal {
        background: #000 !important;
        color: #00ff00 !important;
      }
      body.theme-matrix .terminal-header {
        border-bottom: 1px solid #00ff00 !important;
      }
      body.theme-matrix .prompt,
      body.theme-matrix .input-prompt {
        color: #00ff00 !important;
        font-weight: bold;
      }
      body.theme-matrix .command {
        color: #00ff00 !important;
      }
      body.theme-matrix .output {
        color: #00ff00 !important;
      }
      body.theme-matrix .error {
        color: #ff3333 !important;
      }
      body.theme-matrix .success {
        color: #00ff00 !important;
      }
      body.theme-matrix .warning {
        color: #ffff00 !important;
      }
      body.theme-matrix .info {
        color: #00ffff !important;
      }

      /* Retro Theme Styles */
      body.theme-retro {
        background: #181200 !important;
        color: #39ff14 !important;
      }
      body.theme-retro .terminal {
        background: #181200 !important;
        color: #39ff14 !important;
      }
      body.theme-retro .terminal-header {
        border-bottom: 1px solid #ffaa00 !important;
      }
      body.theme-retro .prompt,
      body.theme-retro .input-prompt {
        color: #ffaa00 !important;
        font-weight: bold;
      }
      body.theme-retro .command {
        color: #39ff14 !important;
      }
      body.theme-retro .output {
        color: #39ff14 !important;
      }
      body.theme-retro .error {
        color: #ff3333 !important;
      }
      body.theme-retro .success {
        color: #ffaa00 !important;
      }
      body.theme-retro .warning {
        color: #ffff00 !important;
      }
      body.theme-retro .info {
        color: #00ffff !important;
      }

      body.theme-retro .info {
        color: #00ffff !important;
      }

      /* PowerShell Theme Styles */
      body.theme-powershell {
        background: #012456 !important;
        color: #ffffff !important;
      }
      body.theme-powershell .terminal {
        background: #012456 !important;
        color: #ffffff !important;
      }
      body.theme-powershell .terminal-header {
        border-bottom: 1px solid #00bcf2 !important;
      }
      body.theme-powershell .prompt,
      body.theme-powershell .input-prompt {
        color: #f9f1a5 !important;
        font-weight: bold;
      }
      body.theme-powershell .command {
        color: #ffffff !important;
      }
      body.theme-powershell .output {
        color: #d7eaff !important;
      }
      body.theme-powershell .error {
        color: #ff3333 !important;
      }
      body.theme-powershell .success {
        color: #00bcf2 !important;
      }
      body.theme-powershell .warning {
        color: #f9f1a5 !important;
      }
      body.theme-powershell .info {
        color: #00bcf2 !important;
      }

      .omega-test-wallet-prompt {
        color: #fff !important;
        font-size: 1.5em !important;
        font-weight: bold;
        margin: 16px 0;
        display: block;
      }

      /* Modern Boot Animation Styles */
      .boot-animation {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          135deg,
          #000000 0%,
          #0a0a0a 50%,
          #000000 100%
        );
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        overflow: hidden;
      }

      .boot-animation::before {
        content: "";
        position: absolute;
        width: 200%;
        height: 200%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.03) 1px,
          transparent 1px
        );
        background-size: 50px 50px;
        animation: gridMove 20s linear infinite;
      }

      @keyframes gridMove {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(50px, 50px);
        }
      }

      .omega-container {
        position: relative;
        margin-bottom: 60px;
        animation: floatIn 1s ease-out;
      }

      @keyframes floatIn {
        from {
          opacity: 0;
          transform: translateY(-50px) scale(0.5);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .omega-main {
        font-size: 120px;
        color: #ffffff;
        text-shadow: 0 0 20px #ffffff, 0 0 40px #ffffff, 0 0 60px #99ccff,
          0 0 80px #99ccff;
        animation: pulseglow 2s ease-in-out infinite;
        position: relative;
        z-index: 2;
      }

      @keyframes pulseglow {
        0%,
        100% {
          text-shadow: 0 0 20px #ffffff, 0 0 40px #ffffff, 0 0 60px #99ccff,
            0 0 80px #99ccff;
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 30px #ffffff, 0 0 60px #ffffff, 0 0 90px #66ccff,
            0 0 120px #66ccff;
          transform: scale(1.05);
        }
      }

      .omega-orbit {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 300px;
        height: 300px;
        margin: -150px 0 0 -150px;
        animation: rotate 10s linear infinite;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .omega-orbit-symbol {
        position: absolute;
        font-size: 24px;
        color: #99ccff;
        opacity: 0.3;
        animation: orbitFade 2s ease-in-out infinite;
      }

      @keyframes orbitFade {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 0.8;
        }
      }

      .omega-orbit-symbol:nth-child(1) {
        top: 0;
        left: 50%;
        transform: translateX(-50%);
      }
      .omega-orbit-symbol:nth-child(2) {
        top: 21%;
        right: 21%;
      }
      .omega-orbit-symbol:nth-child(3) {
        top: 50%;
        right: 0;
        transform: translateY(-50%);
      }
      .omega-orbit-symbol:nth-child(4) {
        bottom: 21%;
        right: 21%;
      }
      .omega-orbit-symbol:nth-child(5) {
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
      }
      .omega-orbit-symbol:nth-child(6) {
        bottom: 21%;
        left: 21%;
      }
      .omega-orbit-symbol:nth-child(7) {
        top: 50%;
        left: 0;
        transform: translateY(-50%);
      }
      .omega-orbit-symbol:nth-child(8) {
        top: 21%;
        left: 21%;
      }

      .welcome-container {
        text-align: center;
        margin-bottom: 40px;
        animation: fadeInUp 1s ease-out 0.3s both;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .welcome-title {
        font-size: 48px;
        font-weight: bold;
        color: #ffffff;
        letter-spacing: 8px;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        margin-bottom: 10px;
      }

      .welcome-subtitle {
        font-size: 20px;
        color: #99ccff;
        letter-spacing: 4px;
        margin-bottom: 15px;
      }

      .welcome-description {
        font-size: 16px;
        color: #cccccc;
        letter-spacing: 2px;
      }

      .loading-container {
        width: 400px;
        max-width: 80vw;
        margin-bottom: 40px;
        animation: fadeInUp 1s ease-out 0.6s both;
      }

      .loading-bar {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
      }

      .loading-progress {
        height: 100%;
        background: linear-gradient(90deg, #66ccff, #ffffff, #66ccff);
        background-size: 200% 100%;
        animation: loadingProgress 2s ease-in-out infinite;
        box-shadow: 0 0 10px #66ccff;
      }

      @keyframes loadingProgress {
        0% {
          width: 0%;
          background-position: 0% 50%;
        }
        50% {
          width: 70%;
          background-position: 100% 50%;
        }
        100% {
          width: 100%;
          background-position: 200% 50%;
        }
      }

      .loading-text {
        text-align: center;
        color: #99ccff;
        font-size: 14px;
        margin-top: 15px;
        letter-spacing: 2px;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      .boot-features {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
        animation: fadeInUp 1s ease-out 0.9s both;
      }

      .feature-item {
        color: #99ccff;
        font-size: 14px;
        padding: 8px 16px;
        border: 1px solid rgba(153, 204, 255, 0.3);
        border-radius: 20px;
        background: rgba(153, 204, 255, 0.05);
        backdrop-filter: blur(10px);
        animation: featureGlow 3s ease-in-out infinite;
        animation-delay: calc(var(--i) * 0.2s);
      }

      .feature-item:nth-child(1) {
        --i: 0;
      }
      .feature-item:nth-child(2) {
        --i: 1;
      }
      .feature-item:nth-child(3) {
        --i: 2;
      }
      .feature-item:nth-child(4) {
        --i: 3;
      }

      @keyframes featureGlow {
        0%,
        100% {
          box-shadow: 0 0 5px rgba(153, 204, 255, 0.3);
          border-color: rgba(153, 204, 255, 0.3);
        }
        50% {
          box-shadow: 0 0 15px rgba(153, 204, 255, 0.6);
          border-color: rgba(153, 204, 255, 0.6);
        }
      }

      @media (max-width: 768px) {
        .omega-main {
          font-size: 80px;
        }
        .omega-orbit {
          width: 200px;
          height: 200px;
          margin: -100px 0 0 -100px;
        }
        .welcome-title {
          font-size: 32px;
          letter-spacing: 4px;
        }
        .welcome-subtitle {
          font-size: 16px;
        }
        .loading-container {
          width: 300px;
        }
        .boot-features {
          gap: 15px;
        }
        .feature-item {
          font-size: 12px;
          padding: 6px 12px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
      <div class="omega-container">
        <div class="omega-main">Œ©</div>
        <div class="omega-orbit">
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
          <div class="omega-orbit-symbol">Œ©</div>
        </div>
      </div>
      <div class="welcome-container">
        <div class="welcome-title">OMEGA TERMINAL</div>
        <div class="welcome-subtitle">v2.0.1</div>
        <div class="welcome-description">Multi-Chain Web3 Terminal</div>
      </div>
      <div class="loading-container">
        <div class="loading-bar">
          <div class="loading-progress"></div>
        </div>
        <div class="loading-text">Initializing Terminal...</div>
      </div>
      <div class="boot-features">
        <div class="feature-item">ü§ñ AI</div>
        <div class="feature-item">‚ö° Multi-Chain</div>
        <div class="feature-item">üèõÔ∏è Defi</div>
        <div class="feature-item">üé® NFTs</div>
      </div>
    </div>

    <div class="terminal" id="terminal" style="display: none">
      <div class="terminal-header">
        <div class="terminal-title">Omega Terminal v2.0.1</div>
        <div
          style="
            display: flex;
            align-items: center;
            gap: 18px;
            margin-left: auto;
          "
        >
          <button class="ai-toggle" title="Toggle AI Mode" id="aiToggle">
            AI Mode (off)
          </button>
          <button class="theme-toggle" title="Toggle Theme"></button>
          <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
        </div>
      </div>
      <div
        class="tab-bar"
        id="tabBar"
        style="
          display: flex;
          align-items: center;
          background: #111;
          border-bottom: 1px solid #fff;
        "
      >
        <div
          class="tab active"
          data-tab="0"
          style="
            padding: 8px 18px;
            cursor: pointer;
            border-right: 1px solid #333;
            color: #fff;
            font-weight: bold;
          "
        >
          Terminal 1
        </div>
        <div
          id="addTabBtn"
          style="
            padding: 8px 18px;
            cursor: pointer;
            color: #00bcf2;
            font-size: 1.3em;
          "
        >
          +
        </div>
      </div>

      <!-- Faucet Info Box -->
      <div
        id="faucetInfoBox"
        style="
          background: rgba(0, 153, 255, 0.1);
          border: 1px solid #99ccff;
          color: #99ccff;
          padding: 10px 16px;
          border-radius: 6px;
          margin: 0 0 12px 0;
          font-size: 15px;
        "
      >
        <b>Note:</b> Each wallet can only claim from the faucet once every 24
        hours.<br />
        If you try to claim again before the cooldown is over, the transaction
        will fail.
      </div>
      <div class="terminal-content" id="terminalContent"></div>
      <div class="terminal-input-section">
        <div class="input-line">
          <span class="input-prompt">root@omega-miner:~$</span>
          <input
            type="text"
            class="input-field"
            id="commandInput"
            placeholder="Enter command..."
            autocomplete="off"
          />
          <span class="cursor">|</span>
        </div>
      </div>
    </div>

    <script>
      // API URLs for different services
      const RELAYER_URL = "https://terminal-v1-5-9.onrender.com"; // Production relayer for mining/claims
      const OMEGA_API_URL = "https://omeganetwork.co/api"; // Production API for ambassador data

      // Simplified ethers loading with fallback support
      function loadEthers() {
        return new Promise((resolve, reject) => {
          // Small delay to ensure CDN script has time to load
          setTimeout(() => {
            console.log("Checking for ethers availability...");

            // Check if ethers is already loaded (CDN success)
            if (typeof ethers !== "undefined") {
              console.log("Ethers loaded successfully from CDN");
              resolve(ethers);
              return;
            }

            console.log(
              "CDN ethers not loaded, trying additional CDN sources..."
            );

            // Try multiple CDN sources
            const cdnSources = [
              "https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js",
              "https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js",
            ];

            let currentSource = 0;

            function tryNextSource() {
              if (currentSource >= cdnSources.length) {
                // All CDN sources failed, load fallback
                console.log(
                  "All CDN sources failed, loading fallback ethers..."
                );
                loadEthersFallback();
                resolve(ethers);
                return;
              }

              const script = document.createElement("script");
              script.src = cdnSources[currentSource];
              script.onload = () => {
                if (typeof ethers !== "undefined") {
                  console.log(
                    `Ethers loaded successfully from: ${cdnSources[currentSource]}`
                  );
                  resolve(ethers);
                } else {
                  currentSource++;
                  tryNextSource();
                }
              };
              script.onerror = () => {
                console.warn(
                  `Failed to load ethers from: ${cdnSources[currentSource]}`
                );
                currentSource++;
                tryNextSource();
              };
              document.head.appendChild(script);
            }

            tryNextSource();
          }, 500); // 500ms delay to ensure CDN script has time to load
        });
      }

      // Fallback ethers implementation - only loads if all CDN sources fail
      function loadEthersFallback() {
        console.log("Loading ethers fallback...");
        window.ethers = {
          providers: {
            Web3Provider: function (provider) {
              this.provider = provider;
              this.getSigner = () => ({
                getAddress: () =>
                  Promise.resolve("0x0000000000000000000000000000000000000000"),
                sendTransaction: () =>
                  Promise.reject(
                    new Error("Fallback ethers - no real transactions")
                  ),
              });
              this.getGasPrice = () =>
                Promise.resolve({ toString: () => "20000000000" });
              this.getBalance = () => Promise.resolve({ isZero: () => true });
              this.getTransactionCount = () => Promise.resolve(0);
            },
          },
          Contract: function (address, abi, signer) {
            this.address = address;
            this.abi = abi;
            this.signer = signer;
            // Add basic contract methods
            this.startMining = () =>
              Promise.resolve({ wait: () => Promise.resolve() });
            this.claimRewards = () =>
              Promise.resolve({ wait: () => Promise.resolve() });
          },
          Wallet: {
            createRandom: function () {
              return {
                address: "0x" + Math.random().toString(16).substr(2, 40),
                privateKey: "0x" + Math.random().toString(16).substr(2, 64),
                connect: function (provider) {
                  return this;
                },
                sendTransaction: function (tx) {
                  return Promise.resolve({
                    hash: "0x" + Math.random().toString(16).substr(2, 64),
                    wait: () => Promise.resolve(),
                  });
                },
              };
            },
          },
          utils: {
            formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
            parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
            id: (text) => "0x" + Math.random().toString(16).substr(2, 64),
            defaultAbiCoder: {
              decode: () => [
                "0x0000000000000000000000000000000000000000",
                "1000000000000000000",
                "1",
              ],
            },
            hexDataSlice: (data, start) => data,
          },
        };
        console.log("Ethers fallback loaded successfully");
      }

      class OmegaMinerTerminal {
        constructor() {
          // VERSION CHECK - This should be visible in terminal if updated code is loaded
          console.log("üöÄ OMEGA TERMINAL CONSTRUCTOR VERSION 2.0.1");
          this.version = "2.0.1";
          this.tabs = [{ id: 0, name: "Terminal 1", history: [], output: [] }];
          this.activeTab = 0;
          console.log("[DEBUG] OmegaMinerTerminal constructor called");
          if (window && window.terminal) {
            console.log(
              "[DEBUG] Previous terminal instance found, overwriting"
            );
          }
          this.provider = null;
          this.signer = null;
          this.contract = null;
          this.isMining = false;
          this.miningInterval = null;
          this.currentNonce = 0;
          this.ethers = null;
          this.isDarkTheme = true; // Default to dark theme

          // Load saved theme preference
          const savedTheme = localStorage.getItem("omega-terminal-theme");
          if (savedTheme) {
            this.isDarkTheme = savedTheme === "dark";
          }

          // New mining system properties
          this.pendingClaimableBalance = 0;
          this.totalEarned = 0; // Track total earned during session
          this.waitingForContinueResponse = false;

          // Stress test properties
          this.isStressTesting = false;
          this.stressTestInterval = null;
          this.stressTestStats = {
            walletsCreated: 0,
            transactionsSent: 0,
            successfulTxs: 0,
            failedTxs: 0,
            startTime: 0,
          };
          this.stressWallet = null;
          this.stressNonce = 0;

          // Contract properties
          this.contractAddress = "0x54c731627f2d2b55267b53e604c869ab8e6a323b"; // SimpleMiner contract with claimTo
          this.faucetAddress = "0xf8e00f8cfaccf9b95f703642ec589d1c6ceee1a9"; // Update faucet contract address
          this.minerFaucetAddress =
            "0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207"; // Deployed OmegaMinerFaucet contract
          this.contractABI = [
            "function mineBlock(uint256 nonce, bytes32 solution) external",
            "function claimRewards() external",
            "function claimTo(address recipient) external",
            "function getMinerInfo(address miner) external view returns (uint256 _totalMined, uint256 _lastMineTime, uint256 _pendingRewards)",
            "function calculateReward(address miner, uint256 nonce, bytes32 solution) external view returns (uint256)",
            "function cooldownPeriod() external view returns (uint256)",
            "function totalRewardsDistributed() external view returns (uint256)",
            "function owner() external view returns (address)",
            "function setCooldownPeriod(uint256 _cooldown) external",
            "function withdrawExcess() external",
            "event BlockMined(address indexed miner, uint256 nonce, bytes32 solution, uint256 reward)",
            "event RewardsClaimed(address indexed miner, uint256 amount)",
          ];
          this.faucetABI = [
            {
              inputs: [],
              name: "claim",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "user", type: "address" },
              ],
              name: "getFaucetStatus",
              outputs: [
                { internalType: "bool", name: "canClaimNow", type: "bool" },
                { internalType: "uint256", name: "lastClaim", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "timeUntilNextClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "claimAmount",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "faucetBalance",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "totalClaims_",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "emergencyWithdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              stateMutability: "nonpayable",
              type: "constructor",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "amount",
                  type: "uint256",
                },
              ],
              name: "FaucetRefilled",
              type: "event",
            },
            {
              inputs: [],
              name: "refillFaucet",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "amount",
                  type: "uint256",
                },
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256",
                },
              ],
              name: "TokensClaimed",
              type: "event",
            },
            {
              inputs: [],
              name: "withdrawFaucet",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              stateMutability: "payable",
              type: "receive",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "canClaim",
              outputs: [
                {
                  internalType: "bool",
                  name: "",
                  type: "bool",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "CLAIM_AMOUNT",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "CLAIM_COOLDOWN",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "faucetBalance",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "getClaimInfo",
              outputs: [
                {
                  internalType: "bool",
                  name: "canClaimNow",
                  type: "bool",
                },
                {
                  internalType: "uint256",
                  name: "lastClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "timeUntilNextClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "claimAmount",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "getFaucetBalance",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "getTimeUntilNextClaim",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "",
                  type: "address",
                },
              ],
              name: "lastClaimTime",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "totalClaims",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
          ];
          this.minerFaucetABI = [
            {
              inputs: [],
              name: "mine",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "totalMined",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "lastMineTime",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ];

          this.loadTheme();
          console.log("[DEBUG] Calling init() from constructor");
          this.init();

          // In the OmegaMinerTerminal class:
          // 1. Add DM prompt state variables to the constructor
          this.awaitingDMRecipient = false;
          this.awaitingDMMessage = false;
          this.tempDMRecipient = "";
          this.solanaAddress = null;
          this.awaitingWalletChoice = false;
        }

        async init() {
          this.log("üöÄ OMEGA TERMINAL v2.0.1 INITIALIZING", "info");
          // Show boot animation first
          await this.showBootAnimation();
          // Always set up event listeners immediately after boot
          this.setupEventListeners();
          try {
            this.ethers = await loadEthers();
            const hasMetaMask = await this.isRealMetaMask();

            // Always show connect message - let user decide what to do
            this.logHtml(
              '<span style="color:#ffffff; font-size: 16px; font-weight: bold;">Type "connect" to get started</span>',
              "output"
            );
          } catch (error) {
            this.log("DEBUG: Error in init() catch block", "error");
            console.log("[DEBUG] Error in init() catch block", error);
            console.error("Failed to load ethers:", error);
            this.log(
              "Failed to load ethers library: " + error.message,
              "error"
            );
            this.log(
              "Please check your internet connection and refresh the page",
              "error"
            );
          }
        }

        loadTheme() {
          const theme = localStorage.getItem("omega-terminal-theme") || "dark";
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro"
            );
            terminal.classList.add("theme-" + theme);
          }
          localStorage.setItem("omega-terminal-theme", theme);
          this.log(`Theme set to ${theme} mode`, "success");
        }

        async showBootAnimation() {
          this.log("DEBUG: showBootAnimation() called", "info");
          console.log("[DEBUG] showBootAnimation() called");
          return new Promise((resolve) => {
            setTimeout(() => {
              document.getElementById("bootAnimation").style.display = "none";
              document.getElementById("terminal").style.display = "flex";
              this.applyTheme();
              // Clean startup - no debug messages
              this.log('Type "connect" to get started', "info");
              resolve();
            }, 4000); // Extended boot time to show cool animation
          });
        }

        showGettingStartedModal() {
          // Create modal HTML
          const modalHTML = `
                    <div class="modal-overlay" id="gettingStartedModal">
                        <div class="modal-content">
                            <div class="modal-title">üöÄ How To Get Started</div>
                            <div class="modal-steps">
                                <div class="modal-step">
                                    <span class="modal-step-number">1.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">connect</span> for MetaMask, <span style="color:#33bbff;font-weight:bold;">yes</span> for new Omega Wallet, or <span style="color:#33bbff;font-weight:bold;">import</span> for existing wallet
                                </div>
                                <div class="modal-step">
                                    <span class="modal-step-number">2.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">help</span> for a list of commands
                                </div>
                            </div>
                            <button class="modal-button" onclick="document.getElementById('gettingStartedModal').remove(); document.getElementById('commandInput').focus();">
                                Let's Get Started!
                            </button>
                        </div>
                    </div>
                `;

          // Add modal to page
          document.body.insertAdjacentHTML("beforeend", modalHTML);

          // Focus on the button for accessibility
          setTimeout(() => {
            const button = document.querySelector(".modal-button");
            if (button) button.focus();
          }, 100);
        }

        setupEventListeners() {
          const input = document.getElementById("commandInput");
          if (input) {
            input.focus();
            // Command history and autocomplete state
            this.commandHistory = [];
            this.historyIndex = -1;
            this.lastInputValue = "";
            this.availableCommands = [
              "help",
              "clear",
              "connect",
              "disconnect",
              "balance",
              "faucet",
              "mine",
              "claim",
              "status",
              "stats",
              "send",
              "ens",
              "mixer",
              "stress",
              "stopstress",
              "stressstats",
              "theme",
              "rickroll",
              "fortune",
              "matrix",
              "hack",
              "disco",
              "stop",
              "tab",
              "email",
              "inbox",
              "dexscreener",
              "geckoterminal",
              "stock",
              "alphakey",
              "ds",
              "cg",
              "alpha",
              "airdrop",
              "solana",
              "eclipse",
              "hyperliquid",
              "polymarket",
              "poly",
              "events",
              "recent",
              "magiceden",
              "import",
              "ambassador",
              "profile",
              "gui",
              "rome",
              "kalshi",
              "bot",
              "bots",
              "py",
              "python",
              "pgt",
              "pgt-demo",
              "game",
              "play",
              "chat",
              "near-wallet",
              "nearwallet",
              "near",
              "ref",
              "defillama",
              "llama",
              "defi",
              "tvl",
              "modern",
              "nft",
              "opensea",
              "profile",
              "terminal",
              "mint",
            ];
            input.addEventListener("keydown", (e) => {
              // Up arrow: previous command
              if (e.key === "ArrowUp") {
                if (this.commandHistory.length > 0) {
                  if (this.historyIndex === -1) {
                    this.historyIndex = this.commandHistory.length - 1;
                    this.lastInputValue = input.value;
                  } else if (this.historyIndex > 0) {
                    this.historyIndex--;
                  }
                  input.value = this.commandHistory[this.historyIndex];
                  setTimeout(
                    () =>
                      input.setSelectionRange(
                        input.value.length,
                        input.value.length
                      ),
                    0
                  );
                }
                e.preventDefault();
              }
              // Down arrow: next command or clear
              if (e.key === "ArrowDown") {
                if (
                  this.commandHistory.length > 0 &&
                  this.historyIndex !== -1
                ) {
                  if (this.historyIndex < this.commandHistory.length - 1) {
                    this.historyIndex++;
                    input.value = this.commandHistory[this.historyIndex];
                  } else {
                    this.historyIndex = -1;
                    input.value = this.lastInputValue || "";
                  }
                  setTimeout(
                    () =>
                      input.setSelectionRange(
                        input.value.length,
                        input.value.length
                      ),
                    0
                  );
                }
                e.preventDefault();
              }
              // Tab: autocomplete
              if (e.key === "Tab") {
                e.preventDefault();
                const val = input.value.trim();
                if (!val) return;
                const matches = this.availableCommands.filter((cmd) =>
                  cmd.startsWith(val)
                );
                if (matches.length === 1) {
                  input.value = matches[0] + " ";
                } else if (matches.length > 1) {
                  this.logHtml(
                    '<span style="color:#cccccc">' +
                      matches.join("    ") +
                      "</span>",
                    "info"
                  );
                }
              }
            });
            input.addEventListener("keypress", async (e) => {
              if (e.key === "Enter") {
                const val = input.value;
                input.value = "";
                if (this.awaitingPromptInput && this.promptResolver) {
                  const value = val.trim();
                  this.awaitingPromptInput = false;
                  this.promptResolver(value);
                  this.promptResolver = null;
                } else {
                  if (val.trim()) {
                    this.commandHistory.push(val.trim());
                    if (this.commandHistory.length > 100)
                      this.commandHistory.shift();
                  }
                  this.historyIndex = -1;
                  this.lastInputValue = "";
                  await this.executeCommand(val);
                }
              }
              // Ctrl+C to stop stress test
              if (e.key === "c" && e.ctrlKey) {
                // 'this' is not needed here, as isStressTesting is not used in this context
              }
            });

            // Input field is now clean - hardcoded cursor spans are hidden via CSS

            // Fallback: refocus input if user clicks anywhere in the terminal
            document
              .getElementById("terminal")
              .addEventListener("click", function () {
                input.focus();
              });
          }
          // Setup AI toggle
          const aiToggle = document.querySelector(".ai-toggle");
          if (aiToggle) {
            aiToggle.addEventListener("click", () => {
              this.toggleAIMode();
            });
          }

          // Setup theme toggle
          const themeToggle = document.querySelector(".theme-toggle");
          if (themeToggle) {
            themeToggle.addEventListener("click", () => {
              this.toggleTheme();
            });
            // Remove emoji/text, just hollow circle
            themeToggle.textContent = "";
          }

          // Setup tab system
          const addTabBtn = document.getElementById("addTabBtn");
          if (addTabBtn) {
            addTabBtn.addEventListener("click", () => {
              const newId = this.tabs.length;
              this.tabs.push({
                id: newId,
                name: `Terminal ${newId + 1}`,
                history: [],
                output: [],
              });
              this.activeTab = newId;
              this.renderTabs();
              this.clearTerminalContent();
            });
          }
        }

        async promptTerminalInput() {
          return new Promise((resolve) => {
            this.awaitingPromptInput = true;
            this.promptResolver = resolve;
          });
        }

        async checkWalletConnection() {
          if (typeof window.ethereum !== "undefined") {
            try {
              // Force MetaMask selection before checking accounts
              if (
                window.ethereum.providers &&
                Array.isArray(window.ethereum.providers)
              ) {
                const metamaskProvider = window.ethereum.providers.find(
                  (p) => p.isMetaMask
                );
                if (metamaskProvider) {
                  window.ethereum = metamaskProvider;
                  console.log(
                    "MetaMask provider forced in checkWalletConnection"
                  );
                }
              }

              // Check if we have a valid MetaMask provider after forcing
              if (window.ethereum && window.ethereum.isMetaMask) {
                const accounts = await window.ethereum.request({
                  method: "eth_accounts",
                });
                if (accounts.length > 0) {
                  await this.connectWallet();
                }
              } else {
                console.log("MetaMask not available after provider selection");
              }
            } catch (error) {
              this.log(
                "Error checking wallet connection: " + error.message,
                "error"
              );
            }
          }
        }

        async connectWallet() {
          try {
            if (!this.ethers) {
              this.log(
                "Ethers library not loaded. Please refresh the page.",
                "error"
              );
              return;
            }

            // Smart MetaMask detection and Phantom handling
            let provider;
            let providerName = "Unknown";

            if (window.ethereum) {
              // If we already have MetaMask selected, use it
              if (window.ethereum.isMetaMask) {
                provider = window.ethereum;
                providerName = "MetaMask";
                this.log("‚úÖ Using MetaMask provider", "success");
              }
              // Check if we have multiple providers and can find MetaMask
              else if (
                window.ethereum.providers &&
                Array.isArray(window.ethereum.providers)
              ) {
                const metamaskProvider = window.ethereum.providers.find(
                  (p) => p.isMetaMask
                );
                if (metamaskProvider) {
                  // Force MetaMask
                  window.ethereum = metamaskProvider;
                  provider = metamaskProvider;
                  providerName = "MetaMask";
                  this.log("‚úÖ MetaMask provider found and forced", "success");
                } else if (window.ethereum.isPhantom) {
                  // Only Phantom available - reject
                  this.log(
                    "‚ùå Only Phantom EVM detected - blocking connection",
                    "error"
                  );
                  this.log(
                    "üí° Please install MetaMask for Omega network support",
                    "info"
                  );
                  return;
                } else {
                  // Other provider - try to use it but warn
                  provider = window.ethereum;
                  providerName = "Other";
                  this.log(
                    "‚ö†Ô∏è Using non-MetaMask provider - may not support Omega network",
                    "warning"
                  );
                }
              }
              // Single provider case
              else {
                if (window.ethereum.isPhantom) {
                  this.log(
                    "‚ùå Phantom EVM detected - blocking connection",
                    "error"
                  );
                  this.log(
                    "üí° Please disable Phantom EVM or use MetaMask for Omega network",
                    "info"
                  );
                  return;
                } else {
                  provider = window.ethereum;
                  providerName = window.ethereum.isMetaMask
                    ? "MetaMask"
                    : "Other";
                  if (!window.ethereum.isMetaMask) {
                    this.log(
                      "‚ö†Ô∏è Using non-MetaMask provider - may not support Omega network",
                      "warning"
                    );
                  }
                }
              }
            } else {
              this.log("No EVM wallet found.", "error");
              this.log("", "info");
              this.log(
                "Would you like to create an Omega Wallet instead?",
                "info"
              );
              this.log(
                'Type "yes" to generate an Omega Wallet and receive 0.1 OMEGA tokens',
                "info"
              );
              this.log('Type "no" to cancel', "info");
              this.awaitingWalletChoice = true;
              return;
            }

            this.log(`üîó Connecting to ${providerName}...`, "info");

            // Request account access
            try {
              await provider.request({ method: "eth_requestAccounts" });
              this.log("‚úÖ Account access granted", "success");
            } catch (requestError) {
              this.log("‚ùå Connection denied by user", "error");
              return;
            }

            this.provider = new this.ethers.providers.Web3Provider(provider);
            this.signer = this.provider.getSigner();

            this.log("üîç Getting wallet address...", "info");
            const address = await this.signer.getAddress();
            this.userAddress = address;

            // CRITICAL: Check if this is actually MetaMask by testing network switching
            try {
              const currentNetwork = await this.provider.getNetwork();
              this.log(
                `üîç Current network: Chain ID ${currentNetwork.chainId}`,
                "info"
              );

              // Try to switch to Omega network - this will fail with Phantom EVM
              try {
                await provider.request({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: "0x4e454228" }], // Omega chain ID
                });
                this.log(
                  "‚úÖ Successfully switched to Omega network - this is MetaMask!",
                  "success"
                );
              } catch (switchError) {
                if (switchError.code === 4902) {
                  // Chain not added, try to add it
                  try {
                    const networkConfig = {
                      chainId: "0x4e454228",
                      chainName: "Omega Network",
                      nativeCurrency: {
                        name: "OMEGA",
                        symbol: "OMEGA",
                        decimals: 18,
                      },
                      rpcUrls: ["https://0x4e454228.rpc.aurora-cloud.dev"],
                      blockExplorerUrls: [
                        "https://0x4e454228.explorer.aurora-cloud.dev/",
                      ],
                    };

                    this.log("üîç Adding network with config:", "info");
                    this.log(
                      `   Chain ID: ${networkConfig.chainId} (${parseInt(
                        networkConfig.chainId,
                        16
                      )} decimal)`,
                      "info"
                    );
                    this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, "info");
                    this.log(
                      `   Explorer: ${networkConfig.blockExplorerUrls[0]}`,
                      "info"
                    );

                    // Debug: Log the exact request being sent
                    console.log(
                      "[DEBUG] Sending wallet_addEthereumChain request:",
                      {
                        method: "wallet_addEthereumChain",
                        params: [networkConfig],
                      }
                    );

                    await provider.request({
                      method: "wallet_addEthereumChain",
                      params: [networkConfig],
                    });
                    this.log(
                      "‚úÖ Successfully added Omega network - this is MetaMask!",
                      "success"
                    );
                  } catch (addError) {
                    this.log(
                      "‚ùå Failed to add Omega network - this might be Phantom EVM",
                      "error"
                    );
                    this.log(
                      "üí° Phantom EVM does not support custom networks like Omega",
                      "info"
                    );
                    return;
                  }
                } else {
                  this.log(
                    "‚ùå Failed to switch to Omega network - this might be Phantom EVM",
                    "error"
                  );
                  this.log(
                    "üí° Phantom EVM does not support custom networks like Omega",
                    "info"
                  );
                  return;
                }
              }
            } catch (networkError) {
              this.log(
                "‚ùå Failed to check network - this might be Phantom EVM",
                "error"
              );
              return;
            }

            // Check if we're using fallback ethers (which would return 0x000... address)
            if (address === "0x0000000000000000000000000000000000000000") {
              this.log(
                "‚ö†Ô∏è Using fallback ethers - real transactions not available",
                "warning"
              );
              this.log(
                "üí° Please check your internet connection and refresh the page",
                "info"
              );
              return;
            }

            this.log(`‚úÖ Wallet connected: ${address}`, "success");
            this.updateConnectionStatus("CONNECTED");

            if (
              this.contractAddress !==
              "0x0000000000000000000000000000000000000000"
            ) {
              this.contract = new this.ethers.Contract(
                this.contractAddress,
                this.contractABI,
                this.signer
              );
              this.log("‚úÖ Mining contract connected", "success");
            }
          } catch (error) {
            console.error("Connect wallet error:", error);
            this.log("‚ùå Failed to connect wallet: " + error.message, "error");
            this.log(
              "üí° Make sure MetaMask is unlocked and you approve the connection",
              "info"
            );
          }
        }

        async disconnectWallet() {
          try {
            if (!this.signer) {
              this.log("No wallet connected to disconnect.", "warning");
              return;
            }

            // Get the address before disconnecting for the message
            const address = await this.signer.getAddress();

            // Clear all wallet-related properties
            this.provider = null;
            this.signer = null;
            this.contract = null;
            this.pendingClaimableBalance = 0;

            this.log(`üîå Wallet disconnected: ${address}`, "success");
            this.updateConnectionStatus("DISCONNECTED");
            this.log(
              'üí° Use "connect" command to reconnect your wallet',
              "info"
            );
          } catch (error) {
            console.error("Disconnect wallet error:", error);
            this.log(
              "‚ùå Error disconnecting wallet: " + error.message,
              "error"
            );
          }
        }

        async executeCommand(command) {
          // Handle custom swap direction first!
          if (this.awaitingCustomSwapDirection) {
            const dir = command.trim();
            if (dir === "1") {
              this.customSwapDirection = 1;
              this.awaitingCustomSwapDirection = false;
              this.awaitingCustomSwapAmount = true;
              this.log(
                `Enter amount of SOL to swap (e.g. 0.001, you have X SOL):`,
                "info"
              );
            } else if (dir === "2") {
              this.customSwapDirection = 2;
              this.awaitingCustomSwapDirection = false;
              this.awaitingCustomSwapAmount = true;
              this.log(
                `Enter amount of ${this.customSwapTokenSymbol} to swap (e.g. 1000, you have X):`,
                "info"
              );
            } else {
              this.log("Please type 1 or 2.", "warning");
            }
            return;
          }
          if (this.awaitingCustomSwapAmount) {
            const amtStr = command.trim();
            this.awaitingCustomSwapAmount = false;
            let amountLamports;
            let fromMint, toMint;
            if (this.customSwapDirection === 1) {
              // SOL ‚Üí Token
              fromMint = "So11111111111111111111111111111111111111112";
              toMint = this.customSwapTokenMint;
              amountLamports = Math.round(parseFloat(amtStr) * 1e9).toString();
            } else {
              // Token ‚Üí SOL (assume 6 decimals for most SPL tokens)
              fromMint = this.customSwapTokenMint;
              toMint = "So11111111111111111111111111111111111111112";
              amountLamports = Math.round(parseFloat(amtStr) * 1e6).toString();
            }
            this.log(
              `Executing custom swap: ${amtStr} ${
                this.customSwapDirection === 1
                  ? "SOL"
                  : this.customSwapTokenSymbol
              }...`,
              "info"
            );
            await this.executeSolanaSwap(amountLamports, fromMint, toMint);
            this.customSwapTokenMint = null;
            this.customSwapTokenSymbol = null;
            this.customSwapDirection = null;
            return;
          }
          if (this.awaitingPromptInput) return;

          // Profile registration input handling
          if (
            this.awaitingInput &&
            this.inputType &&
            this.inputType.startsWith("profile_")
          ) {
            await this.handleProfileRegistrationInput(command.trim());
            return;
          }

          // At the top of executeCommand, before command parsing:
          if (this.awaitingDMRecipient) {
            this.tempDMRecipient = command.trim();
            this.awaitingDMRecipient = false;
            this.awaitingDMMessage = true;
            this.logHtml(
              '<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' +
                this.tempDMRecipient +
                "</span>",
              "info"
            );
            this.log("Enter your message:", "info");
            return;
          }
          if (this.awaitingDMMessage) {
            const message = command.trim();
            const recipient = this.tempDMRecipient;
            this.awaitingDMMessage = false;
            this.tempDMRecipient = "";
            if (!recipient || !message) {
              this.log("Recipient and message required.", "error");
              return;
            }
            this.logHtml(
              '<span style="color:#99ccff">Message:</span> <span style="color:#fff">' +
                message +
                "</span>",
              "info"
            );
            await this.sendDirectMessage(recipient, message);
            this.log("‚úÖ Email sent!", "success");
            return;
          }

          this.logCommand(command);
          // Hide faucet info box after first command
          try {
            const infoBox = document.getElementById("faucetInfoBox");
            if (infoBox && infoBox.style.display !== "none") {
              infoBox.style.display = "none";
            }
          } catch (e) {}
          const args = command.trim().split(/\s+/);
          const cmd = args[0].toLowerCase();

          // Debug logging

          if (cmd === "email" && args[1] === "clearkey") {
            this.e2eePrivateKey = null;
            this.log("E2EE private key cleared from memory.", "success");
            return;
          }

          // --- Handle awaiting input states before command parsing ---

          // Handle wallet choice (yes/no for creating Omega Wallet)
          if (this.awaitingWalletChoice) {
            this.awaitingWalletChoice = false;
            if (cmd === "yes") {
              this.log("üîë Generating Omega Wallet...", "info");
              const wallet = this.ethers.Wallet.createRandom();
              this.storedPrivateKey = wallet.privateKey;
              this.log("‚úÖ Omega Wallet generated successfully!", "success");
              this.log("", "info");
              this.log("üìã WALLET DETAILS:", "info");
              this.logHtml(
                `üèõÔ∏è Address: <span class="copyable" onclick="navigator.clipboard.writeText('${wallet.address}').then(() => window.terminal.log('‚úÖ Address copied!', 'success'))">${wallet.address}</span>`,
                "output"
              );
              this.logHtml(
                `üîë Private Key: <span class="copyable" onclick="navigator.clipboard.writeText('${wallet.privateKey}').then(() => window.terminal.log('‚úÖ Private key copied!', 'success'))">${wallet.privateKey}</span>`,
                "output"
              );
              this.log("", "info");
              this.log(
                "‚ö†Ô∏è  SECURITY WARNING: Save these details securely!",
                "error"
              );
              this.log(
                "üí∞ Requesting 0.1 OMEGA tokens from relayer...",
                "info"
              );

              // Fund the wallet via relayer
              try {
                const response = await fetch(`${RELAYER_URL}/fund`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    address: wallet.address,
                    amount: "0.1",
                  }),
                });
                const data = await response.json();
                if (data.success) {
                  this.log(
                    `‚úÖ Your wallet has been funded! Tx: ${data.txHash}`,
                    "success"
                  );
                  this.log("‚ú® You can now use the terminal!", "info");
                  this.log("", "info");
                  this.log(
                    "üí° To use your Omega Wallet, type commands like:",
                    "info"
                  );
                  this.log('   - "balance" to check your balance', "info");
                  this.log('   - "mine" to start mining', "info");
                  this.log('   - "faucet" to claim more tokens', "info");

                  // Set up the wallet for use
                  const OMEGA_RPC_URL =
                    "https://0x4e454228.rpc.aurora-cloud.dev";
                  this.provider = new this.ethers.providers.JsonRpcProvider(
                    OMEGA_RPC_URL
                  );
                  this.signer = new this.ethers.Wallet(
                    wallet.privateKey,
                    this.provider
                  );
                  this.updateConnectionStatus("CONNECTED (Omega Wallet)");
                } else {
                  this.log(
                    "‚ùå Funding failed: " + (data.error || "Unknown error"),
                    "error"
                  );
                  this.log(
                    "üí° You can still use this wallet by funding it manually",
                    "info"
                  );
                }
              } catch (err) {
                this.log("‚ùå Funding request failed: " + err.message, "error");
                this.log(
                  "üí° You can still use this wallet by funding it manually",
                  "info"
                );
              }
            } else if (cmd === "no") {
              this.log("Wallet creation cancelled.", "info");
              this.log(
                "üí° Please install MetaMask to connect a browser wallet",
                "info"
              );
            } else {
              this.log(
                '‚ùå Invalid response. Please type "yes" or "no"',
                "error"
              );
              this.awaitingWalletChoice = true;
            }
            return;
          }

          if (this.awaitingMixerDirectInput && args.length === 2) {
            this.awaitingMixerDirectInput = false;
            const privateKeyInput = args[0];
            const amountStr = args[1];
            try {
              const mixerABI = [
                "function deposit(bytes32 commitment) external payable",
              ];
              // Always use a JsonRpcProvider for direct private key flows
              const OMEGA_RPC_URL = "https://0x4e454228.rpc.aurora-cloud.dev";
              const provider = new this.ethers.providers.JsonRpcProvider(
                OMEGA_RPC_URL
              );
              const privateKey = privateKeyInput.startsWith("0x")
                ? privateKeyInput
                : "0x" + privateKeyInput;
              const wallet = new this.ethers.Wallet(privateKey, provider);
              // Debug: print wallet address
              this.log(`Using wallet address: ${wallet.address}`, "info");
              // Debug: print provider network
              const network = await provider.getNetwork();
              this.log(
                `Provider network: ${network.name} (chainId: ${network.chainId})`,
                "info"
              );
              // Debug: print wallet balance
              const balance = await wallet.getBalance();
              this.log(
                `Wallet balance: ${this.ethers.utils.formatEther(
                  balance
                )} OMEGA`,
                "info"
              );
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const depositAmount = this.ethers.utils.parseEther(amountStr);
              const array = window.crypto.getRandomValues(new Uint8Array(32));
              const secret = Array.from(array)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
              const commitment = this.ethers.utils.keccak256("0x" + secret);
              this.logHtml(
                `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('‚úÖ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy secret', 'error'))\">${secret}</span>`,
                "info"
              );
              this.log(`2. Commitment: ${commitment}`, "info");
              this.log(`3. Deposit amount: ${amountStr} OMEGA`, "info");
              this.log("4. Creating wallet and calling contract...", "info");
              const tx = await mixerContract.deposit(commitment, {
                value: depositAmount,
              });
              this.log(
                `‚úÖ Deposit transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              try {
                const receipt = await tx.wait();
                this.log(
                  `‚úÖ Deposit confirmed! Block: ${receipt.blockNumber}`,
                  "success"
                );
                this.log(
                  "Your funds are now in the mixer. Use your secret to withdraw later.",
                  "info"
                );
              } catch (err) {
                this.log(
                  "‚ö†Ô∏è Transaction was submitted but confirmation could not be detected in time.",
                  "warning"
                );
                this.log(
                  "You can check the status manually on the block explorer:",
                  "info"
                );
                this.logHtml(
                  `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                  "info"
                );
              }
            } catch (error) {
              this.log(`‚ùå Deposit failed: ${error.message}`, "error");
              this.log(
                "Make sure you have enough OMEGA and a valid private key.",
                "info"
              );
            }
            return;
          }
          if (this.awaitingMixerDirectAmount && args.length === 1) {
            this.awaitingMixerDirectAmount = false;
            const amountStr = args[0];
            try {
              // Mixer contract ABI (updated for new contract)
              const mixerABI = [
                "function deposit(bytes32 commitment) external payable",
              ];
              const privateKey = this.storedPrivateKey.startsWith("0x")
                ? this.storedPrivateKey
                : "0x" + this.storedPrivateKey;
              const wallet = new this.ethers.Wallet(privateKey, this.provider);
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const depositAmount = this.ethers.utils.parseEther(amountStr);
              // Generate secret and commitment
              const array = window.crypto.getRandomValues(new Uint8Array(32));
              const secret = Array.from(array)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
              const commitment = this.ethers.utils.keccak256("0x" + secret);
              this.logHtml(
                `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('‚úÖ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy secret', 'error'))\">${secret}</span>`,
                "info"
              );
              this.log(`2. Commitment: ${commitment}`, "info");
              this.log(`3. Deposit amount: ${amountStr} OMEGA`, "info");
              this.log("4. Creating wallet and calling contract...", "info");
              const tx = await mixerContract.deposit(commitment, {
                value: depositAmount,
              });
              this.log(
                `‚úÖ Deposit transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              try {
                const receipt = await tx.wait();
                this.log(
                  `‚úÖ Deposit confirmed! Block: ${receipt.blockNumber}`,
                  "success"
                );
                this.log(
                  "Your funds are now in the mixer. Use your secret to withdraw later.",
                  "info"
                );
              } catch (err) {
                this.log(
                  "‚ö†Ô∏è Transaction was submitted but confirmation could not be detected in time.",
                  "warning"
                );
                this.log(
                  "You can check the status manually on the block explorer:",
                  "info"
                );
                this.logHtml(
                  `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                  "info"
                );
              }
              // Clear stored private key
              this.storedPrivateKey = null;
            } catch (error) {
              this.log(`‚ùå Deposit failed: ${error.message}`, "error");
              this.log(
                "Make sure you have enough OMEGA and a valid private key.",
                "info"
              );
              this.storedPrivateKey = null;
            }
            return;
          }
          if (
            this.awaitingPrivateKey &&
            this.awaitingMixerWithdrawDirect &&
            args.length === 1
          ) {
            // Withdraw-direct: received private key
            this.awaitingPrivateKey = false;
            this.awaitingMixerWithdrawDirect = false;
            this.storedPrivateKey = args[0];
            this.log(
              "Now enter your secret and withdrawal address separated by a space:",
              "info"
            );
            this.awaitingMixerWithdrawDirectParams = true;
            return;
          }
          if (this.awaitingMixerWithdrawDirectParams && args.length === 2) {
            // Withdraw-direct: received secret and address
            this.awaitingMixerWithdrawDirectParams = false;
            try {
              this.log("=== Omega Mixer Withdraw (Direct) ===", "info");
              this.log("Withdrawing funds directly from contract...", "info");
              // Validate secret
              let secretHex = args[0];
              if (!secretHex.startsWith("0x")) secretHex = "0x" + secretHex;
              if (secretHex.length !== 66) {
                // 2 for '0x' + 64 hex chars
                this.log(
                  "‚ùå Secret must be 32 bytes (64 hex characters).",
                  "error"
                );
                this.storedPrivateKey = null;
                return;
              }
              // Create wallet from private key (stored from previous step)
              const privateKey = this.storedPrivateKey.startsWith("0x")
                ? this.storedPrivateKey
                : "0x" + this.storedPrivateKey;
              const wallet = new this.ethers.Wallet(privateKey, this.provider);
              // Mixer contract ABI
              const mixerABI = [
                "function withdraw(bytes32 secret, address to) external",
              ];
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const tx = await mixerContract.withdraw(secretHex, args[1]);
              this.log(
                `‚úÖ Withdrawal transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              const receipt = await tx.wait();
              this.log(
                `‚úÖ Withdrawal confirmed! Block: ${receipt.blockNumber}`,
                "success"
              );
              this.log(`‚úÖ Funds withdrawn to: ${args[1]}`, "success");
              // Clear stored private key
              this.storedPrivateKey = null;
            } catch (error) {
              this.log(`‚ùå Withdrawal failed: ${error.message}`, "error");
              this.log(
                "Make sure you have a valid private key and the secret is correct.",
                "info"
              );
              this.storedPrivateKey = null;
            }
            return;
          }

          // Handle custom swap input
          if (this.awaitingCustomSwap && args.length === 2) {
            const amount = args[0];
            const toMint = args[1];
            await this.handleCustomSwapInput(amount, toMint);
            return;
          }

          // --- End awaiting input checks ---

          // --- Handle command parsing ---
          switch (cmd) {
            case "connect":
              await this.connectWallet();
              break;
            case "disconnect":
              this.disconnectWallet();
              break;
            case "balance":
              await this.showBalance();
              break;
            case "theme":
              this.setTheme(args[1]);
              break;
            case "mine":
              this.mine();
              break;
            case "faucet":
              if (args[1] === "status") {
                await this.showFaucetStatus();
              } else {
                this.faucetClaim();
              }
              break;
            case "status":
              this.showStatus();
              break;
            case "stats":
              this.showStats();
              break;
            case "send":
              this.sendOmega(command);
              break;
            case "clear":
              this.clearTerminal();
              break;
            case "help":
              this.showHelp();
              break;
            case "network":
              await this.checkNetwork();
              break;
            case "forceadd":
              await this.forceAddNetwork();
              break;
            case "rpccheck":
              await this.checkRpcChainId();
              break;
            case "rickroll":
              this.rickroll();
              break;
            case "fortune":
              this.fortune();
              break;
            case "matrix":
              this.matrix();
              break;
            case "hack":
              this.hack();
              break;
            case "disco":
              this.disco();
              break;
            case "sudo":
              this.sudoMine();
              break;
            case "fund":
              this.fundMiningWallet(args[1]);
              break;
            case "stress":
              this.startStressTest();
              break;
            case "stopstress":
              this.stopStressTest();
              break;
            case "stressstats":
              this.showStressStats();
              break;
            case "mixer":
              if (args[1] === "-help") {
                this.log("=== Omega Mixer Help ===", "info");
                this.log(
                  "The Omega Mixer allows you to privately send OMEGA tokens by breaking the on-chain link between sender and receiver.",
                  "info"
                );
                this.log("How it works:", "info");
                this.log(
                  '1. Use "mixer deposit" to generate a secret and commitment, then manually call the contract.',
                  "info"
                );
                this.log(
                  '2. Use "mixer deposit-execute" to generate secret and call contract via MetaMask.',
                  "info"
                );
                this.log(
                  '3. Use "mixer deposit-direct" to generate secret and call contract directly (requires private key).',
                  "info"
                );
                this.log(
                  "4. Wait for the mixing round to complete (more users = more privacy).",
                  "info"
                );
                this.log(
                  '5. Use "mixer withdraw" to prepare your withdrawal. Enter your secret and the new address you want to receive funds at.',
                  "info"
                );
                this.log(
                  "6. In MetaMask (or via a relayer), call the withdraw function on the mixer contract with your secret and new address.",
                  "info"
                );
                this.log(
                  "7. For maximum privacy, use a relayer to submit the withdrawal transaction.",
                  "info"
                );
                this.log(
                  "NEVER share your secret. Anyone with the secret can withdraw your funds!",
                  "warning"
                );
                this.log(
                  "WARNING: Using deposit-direct requires entering your private key. Use at your own risk!",
                  "warning"
                );
              } else if (args[1] === "deposit") {
                // Generate secret and commitment
                const array = window.crypto.getRandomValues(new Uint8Array(32));
                const secret = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                const commitment = this.ethers.utils.keccak256("0x" + secret);
                this.log("=== Omega Mixer Deposit ===", "info");
                this.logHtml(
                  `1. Save this secret for withdrawal: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('‚úÖ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy secret', 'error'))\">${secret}</span>`,
                  "info"
                );
                this.log(`2. Commitment (for deposit): ${commitment}`, "info");
                this.log(
                  `3. In MetaMask, interact with the mixer contract:`,
                  "info"
                );
                this.logHtml(
                  `   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('‚úÖ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>`,
                  "info"
                );
                this.log(
                  `   IMPORTANT: Do NOT send a plain transaction to this address!`,
                  "warning"
                );
                this.log(`   Instead, call the deposit function:`, "info");
                this.log(`   - Go to the contract in MetaMask`, "info");
                this.log(`   - Click "Write Contract"`, "info");
                this.log(`   - Find the "deposit" function`, "info");
                this.log(`   - Enter commitment: ${commitment}`, "info");
                this.log(`   - Set value to your desired OMEGA amount`, "info");
                this.log(`   - Submit the transaction`, "info");
                this.log(
                  "4. After mixing, use your secret to withdraw to a new address.",
                  "info"
                );
              } else if (args[1] === "deposit-execute") {
                // Generate secret and commitment, then prompt for amount
                const array = window.crypto.getRandomValues(new Uint8Array(32));
                const secret = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                const commitment = this.ethers.utils.keccak256("0x" + secret);
                this.storedMixerSecret = secret;
                this.storedMixerCommitment = commitment;
                this.awaitingMixerExecuteAmount = true;
                this.log("=== Omega Mixer Deposit (Auto-Execute) ===", "info");
                this.logHtml(
                  `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('‚úÖ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy secret', 'error'))\">${secret}</span>`,
                  "info"
                );
                this.log(`2. Commitment: ${commitment}`, "info");
                this.log(
                  "3. Enter deposit amount in OMEGA (e.g. 0.1):",
                  "info"
                );
                return;
              }
              // Add handler for awaitingMixerExecuteAmount
              if (this.awaitingMixerExecuteAmount && args.length === 1) {
                this.awaitingMixerExecuteAmount = false;
                const amountStr = args[0];
                try {
                  const mixerABI = [
                    "function deposit(bytes32 commitment) external payable",
                  ];
                  const mixerContract = new this.ethers.Contract(
                    "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                    mixerABI,
                    this.provider.getSigner()
                  );
                  const depositAmount = this.ethers.utils.parseEther(amountStr);
                  const commitment = this.storedMixerCommitment;
                  const tx = await mixerContract.deposit(commitment, {
                    value: depositAmount,
                  });
                  this.log(
                    `‚úÖ Deposit transaction submitted! Hash: ${tx.hash}`,
                    "success"
                  );
                  this.log("Waiting for confirmation...", "info");
                  try {
                    const receipt = await tx.wait();
                    this.log(
                      `‚úÖ Deposit confirmed! Block: ${receipt.blockNumber}`,
                      "success"
                    );
                    this.log(
                      "Your funds are now in the mixer. Use your secret to withdraw later.",
                      "info"
                    );
                  } catch (err) {
                    this.log(
                      "‚ö†Ô∏è Transaction was submitted but confirmation could not be detected in time.",
                      "warning"
                    );
                    this.log(
                      "You can check the status manually on the block explorer:",
                      "info"
                    );
                    this.logHtml(
                      `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                      "info"
                    );
                  }
                  // Clear stored secret/commitment
                  this.storedMixerSecret = null;
                  this.storedMixerCommitment = null;
                } catch (error) {
                  this.log(`‚ùå Deposit failed: ${error.message}`, "error");
                  this.log(
                    "Make sure you have enough OMEGA in your wallet.",
                    "info"
                  );
                  this.storedMixerSecret = null;
                  this.storedMixerCommitment = null;
                }
                return;
              } else if (args[1] === "deposit-direct") {
                this.log("=== Omega Mixer Deposit (Direct) ===", "warning");
                this.log(
                  "WARNING: This will require your private key. Use at your own risk!",
                  "warning"
                );
                this.log(
                  "Enter your private key and deposit amount separated by a space (e.g. <privatekey> 0.1):",
                  "info"
                );
                this.awaitingMixerDirectInput = true;
                return;
              } else if (args[1] === "withdraw") {
                this.log("=== Omega Mixer Withdraw ===", "info");
                this.log(
                  "Enter your secret (hex) and withdrawal address separated by a space:",
                  "info"
                );
                this.awaitingMixerWithdraw = true;
              } else if (this.awaitingMixerWithdraw && args.length === 3) {
                // args[1] = secret, args[2] = to_address
                this.awaitingMixerWithdraw = false;
                this.log("=== Omega Mixer Withdraw ===", "info");
                this.log(
                  "In MetaMask (or via relayer), call the withdraw function on the mixer contract:",
                  "info"
                );
                this.logHtml(
                  "   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('‚úÖ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>",
                  "info"
                );
                this.log(
                  "   Function: withdraw(bytes32 secret, address to)",
                  "info"
                );
                this.log(`   Secret: ${args[1]}`, "info");
                this.log(`   To: ${args[2]}`, "info");
                this.log(
                  "You can use a relayer to submit this transaction for extra privacy.",
                  "info"
                );
              } else if (args[1] === "withdraw-direct") {
                this.log("=== Omega Mixer Withdraw (Direct) ===", "warning");
                this.log(
                  "WARNING: This will require your private key. Use at your own risk!",
                  "warning"
                );
                this.log("Enter your private key (without 0x prefix):", "info");
                this.awaitingPrivateKey = true;
                this.awaitingMixerWithdrawDirect = true;
              } else {
                this.log(
                  "Usage: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help",
                  "info"
                );
              }
              break;
            case "claim":
              await this.claim();
              break;
            case "stop":
              this.stopAll();
              break;
            case "tab":
              const newId = this.tabs.length;
              this.tabs.push({
                id: newId,
                name: `Terminal ${newId + 1}`,
                history: [],
                output: [],
              });
              this.activeTab = newId;
              this.renderTabs();
              this.clearTerminalContent();
              return;
            case "ens":
              if (!args[1]) {
                this.log(
                  "Usage: ens register <name> | ens resolve <name>",
                  "info"
                );
                break;
              }
              if (args[1] === "register" && args[2]) {
                if (!this.signer) {
                  this.log(
                    "Please connect your wallet first using: connect",
                    "error"
                  );
                  break;
                }
                const name = args[2];
                this.log(`Registering ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract(this.signer);
                  const tx = await ens.register(name);
                  this.log(
                    `‚úÖ Registration transaction sent: ${tx.hash}`,
                    "success"
                  );
                  this.log("Waiting for confirmation...", "info");
                  await tx.wait();
                  this.log(`‚úÖ Name registered: ${name}`, "success");
                } catch (err) {
                  this.log(`‚ùå Registration failed: ${err.message}`, "error");
                }
                break;
              } else if (args[1] === "resolve" && args[2]) {
                const name = args[2];
                this.log(`Resolving ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract();
                  const address = await ens.resolve(name);
                  if (
                    address &&
                    address !== "0x0000000000000000000000000000000000000000"
                  ) {
                    this.logHtml(
                      `‚úÖ <b>${name}</b> resolves to <span class="copyable" onclick="navigator.clipboard.writeText('${address}').then(() => window.terminal.log('‚úÖ Address copied!', 'success'))">${address}</span>`,
                      "success"
                    );
                  } else {
                    this.log(`‚ùå Name not found: ${name}`, "error");
                  }
                } catch (err) {
                  this.log(`‚ùå Resolve failed: ${err.message}`, "error");
                }
                break;
              } else if (args[1] === "search" && args[2]) {
                const name = args[2];
                this.log(`Searching for ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract();
                  const address = await ens.resolve(name);
                  if (
                    address &&
                    address !== "0x0000000000000000000000000000000000000000"
                  ) {
                    this.logHtml(
                      `‚úÖ <b>${name}</b> is owned by <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${address}').then(() => window.terminal.log('‚úÖ Address copied!', 'success'))\">${address}</span>`,
                      "success"
                    );
                  } else {
                    this.log(`‚ùå Name not found: ${name}`, "error");
                  }
                } catch (err) {
                  this.log(`‚ùå ENS search failed: ${err.message}`, "error");
                }
                break;
              } else {
                this.log(
                  "Usage: ens register <name> | ens resolve <name>",
                  "info"
                );
              }
              break;
            case "dm":
              if (!args[1]) {
                this.log("Usage: dm <recipient> <message>", "info");
                break;
              }
              if (args.length < 3) {
                this.log("Usage: dm <recipient> <message>", "info");
                break;
              }
              const recipient = args[1];
              const dmMessage = args.slice(2).join(" ");
              await this.sendDirectMessage(recipient, dmMessage);
              break;
            case "inbox":
            case "messages":
              if (args[1] === "all") {
                await this.showInbox(true); // Show all messages
              } else {
                await this.showInbox(false); // Show limited messages
              }
              break;
            case "email":
              this.awaitingDMRecipient = true;
              this.awaitingDMMessage = false;
              this.tempDMRecipient = "";
              this.log("Enter recipient (address or ENS):", "info");
              break;
            case "dexscreener":
              await this.handleDexScreenerCommand(args);
              break;
            case "geckoterminal":
              await this.handleGeckoTerminalCommand(args);
              break;
            case "stock":
              await this.handleStockCommand(args);
              break;
            case "alphakey":
              await this.handleAlphaKeyCommand(args);
              break;
            case "ds":
              await this.handleDexScreenerAlias(args);
              break;
            case "cg":
              await this.handleGeckoTerminalAlias(args);
              break;
            case "alpha":
              await this.handleAlphaAlias(args);
              break;
            case "create":
              await this.handleCreateCommand(args);
              break;
            case "url":
            case "urls":
              this.logHtml("Helpful URLs:", "info");
              this.logHtml(
                'Gitbook: <a href="https://omega-6.gitbook.io/omega" target="_blank" style="color:#fff;">https://omega-6.gitbook.io/omega</a>',
                "info"
              );
              this.logHtml(
                'Block Explorer: <a href="https://0x4e454228.explorer.aurora-cloud.dev/" target="_blank" style="color:#fff;">https://0x4e454228.explorer.aurora-cloud.dev/</a>',
                "info"
              );
              this.logHtml(
                'Website: <a href="https://omeganetwork.co" target="_blank" style="color:#fff;">omeganetwork.co</a>',
                "info"
              );
              break;
            case "airdrop":
              this.airdrop();
              break;
            case "solana":
              if (args[1] === "help") {
                this.log("=== Solana/Jupiter Commands ===", "info");
                this.log("solana connect - Connect Phantom wallet", "output");
                this.log(
                  "solana search <query> - Search for Solana tokens",
                  "output"
                );
                this.log(
                  "solana quote <amount> <fromMint> <toMint> - Get swap quote",
                  "output"
                );
                this.log(
                  "solana swap - Open interactive swap interface",
                  "output"
                );
                this.log(
                  "solana swap <amount> <fromMint> <toMint> - Execute swap",
                  "output"
                );
                this.log("", "output");
                this.log("Examples:", "output");
                this.log("solana search bonk", "output");
                this.log(
                  "solana quote 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112",
                  "output"
                );
                this.log("solana swap", "output");
                this.log(
                  "solana swap 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112",
                  "output"
                );
                return;
              }
              if (args[1] === "connect") {
                if (window.solana && window.solana.isPhantom) {
                  try {
                    const resp = await window.solana.connect();
                    const address = resp.publicKey.toString();
                    this.solanaAddress = address;
                    // Fetch SOL balance using direct fetch to Helius
                    try {
                      const body = {
                        jsonrpc: "2.0",
                        id: 1,
                        method: "getBalance",
                        params: [address],
                      };
                      const res = await fetch(
                        "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082",
                        {
                          method: "POST",
                          headers: { "Content-Type": "application/json" },
                          body: JSON.stringify(body),
                        }
                      );
                      const data = await res.json();
                      let sol = "N/A";
                      if (
                        data &&
                        data.result &&
                        typeof data.result.value === "number"
                      ) {
                        sol = data.result.value / 1e9;
                      }
                      this.logHtml(
                        `<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#99ff99'>Balance:</span> <b>${sol} SOL</b>`,
                        "success"
                      );
                    } catch (err) {
                      this.logHtml(
                        `<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#ff3333'>Failed to fetch balance</span>`,
                        "success"
                      );
                    }
                  } catch (e) {
                    this.log("User rejected the connection request.", "error");
                  }
                } else {
                  this.logHtml(
                    "<span style='color:#ff3333'>Phantom wallet not detected. <a href='https://phantom.app/download' target='_blank' style='color:#33bbff'>Install Phantom</a></span>",
                    "error"
                  );
                }
                return;
              }
              if (args[1] === "search" && args[2]) {
                const query = args.slice(2).join(" ");
                this.log(`Searching Solana tokens for: ${query}`, "info");
                try {
                  const res = await fetch(
                    `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                      query
                    )}`
                  );
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    data.forEach((token, idx) => {
                      // Card-like top section: logo | name (symbol) | mint | price
                      let cardTop = `<div style='display:flex;align-items:center;justify-content:space-between;gap:14px;margin-bottom:4px;'>`;
                      // Left: logo, name, symbol, mint, price, volume, holders
                      cardTop += `<div style='display:flex;align-items:center;gap:14px;'>`;
                      if (token.logoURI || token.icon) {
                        const logo = token.logoURI || token.icon;
                        cardTop += `<img src='${logo}' alt='icon' style='width:40px;height:40px;border-radius:50%;background:#fff;padding:2px;'>`;
                      }
                      cardTop += `<div><span style='font-size:1.2em;font-weight:bold;'>${
                        token.name || ""
                      }</span> <span style='color:#99ccff;'>(${
                        token.symbol || ""
                      })</span><br>`;
                      cardTop += `Mint: <span class='copyable' onclick=\"navigator.clipboard.writeText('${
                        token.address || token.id
                      }')\">${token.address || token.id}</span><br>`;
                      if (token.usdPrice !== undefined)
                        cardTop += `Price: <b>$${Number(
                          token.usdPrice
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 8,
                        })}</b><br>`;
                      if (
                        token.volume24h !== undefined ||
                        token.stats24h?.buyVolume !== undefined ||
                        token.stats24h?.sellVolume !== undefined
                      ) {
                        let vol = token.volume24h;
                        if (vol === undefined && token.stats24h) {
                          const buy = Number(token.stats24h.buyVolume || 0);
                          const sell = Number(token.stats24h.sellVolume || 0);
                          vol = buy + sell;
                        }
                        if (vol !== undefined)
                          cardTop += `24h Volume: <b>$${Number(
                            vol
                          ).toLocaleString(undefined, {
                            maximumFractionDigits: 2,
                          })}</b><br>`;
                      }
                      if (token.holderCount !== undefined)
                        cardTop += `Holders: <b>${Number(
                          token.holderCount
                        ).toLocaleString()}</b><br>`;
                      cardTop += `</div></div>`;
                      // Middle: audit and CEXes
                      cardTop += `<div style='min-width:200px;text-align:center;'>`;
                      if (token.audit) {
                        cardTop += `<div style='margin-bottom:4px;'><b>Audit</b><br>`;
                        if (token.audit.mintAuthorityDisabled !== undefined)
                          cardTop += `Mint Authority: <b>${
                            token.audit.mintAuthorityDisabled
                              ? "Disabled"
                              : "Enabled"
                          }</b><br>`;
                        if (token.audit.freezeAuthorityDisabled !== undefined)
                          cardTop += `Freeze Authority: <b>${
                            token.audit.freezeAuthorityDisabled
                              ? "Disabled"
                              : "Enabled"
                          }</b><br>`;
                        if (token.audit.topHoldersPercentage !== undefined)
                          cardTop += `Top Holders: <b>${Number(
                            token.audit.topHoldersPercentage
                          ).toLocaleString(undefined, {
                            maximumFractionDigits: 2,
                          })}%</b><br>`;
                        cardTop += `</div>`;
                      }
                      if (
                        token.cexes &&
                        Array.isArray(token.cexes) &&
                        token.cexes.length > 0
                      ) {
                        cardTop += `<div><b>CEXs</b><br><span style='font-size:0.95em;'>${token.cexes.join(
                          ", "
                        )}</span></div>`;
                      }
                      cardTop += `</div>`;
                      // Right: mcap and fdv
                      cardTop += `<div style='text-align:right;min-width:180px;'>`;
                      if (token.mcap !== undefined)
                        cardTop += `Market Cap:<br><b>$${Number(
                          token.mcap
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 2,
                        })}</b><br>`;
                      if (token.fdv !== undefined)
                        cardTop += `FDV:<br><b>$${Number(
                          token.fdv
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 2,
                        })}</b><br>`;
                      cardTop += `</div>`;
                      cardTop += `</div>`;

                      // Add swap buttons section
                      let swapSection = `<div style='margin-top:8px;padding:8px;background:rgba(0,255,0,0.1);border:1px solid #00ff00;border-radius:4px;'>`;
                      swapSection += `<div style='font-weight:bold;margin-bottom:4px;'>Quick Swap Actions:</div>`;
                      swapSection += `<div style='display:flex;gap:8px;flex-wrap:wrap;'>`;

                      // Swap from SOL to this token (use 1 SOL = 1,000,000,000 lamports)
                      swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000000', 'So11111111111111111111111111111111111111112', '${
                        token.address || token.id
                      }')\" style='background:#00ff00;color:#000;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1 SOL ‚Üí ${
                        token.symbol || "Token"
                      }</button>`;

                      // Swap from this token to SOL (use 1,000,000 units; adjust decimals as needed)
                      swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000', '${
                        token.address || token.id
                      }', 'So11111111111111111111111111111111111111112')\" style='background:#ff6600;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1M ${
                        token.symbol || "Token"
                      } ‚Üí SOL</button>`;

                      // Custom swap button
                      swapSection += `<button onclick=\"window.terminal.promptCustomSwap('${
                        token.address || token.id
                      }', '${
                        token.symbol || "Token"
                      }')\" style='background:#0066ff;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Custom Swap</button>`;

                      swapSection += `</div></div>`;

                      this.logHtml(cardTop + swapSection, "output");
                      this.logHtml("<hr>", "output");
                    });
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">No results found.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana token search failed: " + e.message, "error");
                }
                return;
              }
              if (args[1] === "quote" && args.length === 5) {
                const amount = args[2];
                const fromMint = args[3];
                const toMint = args[4];
                this.log(
                  `Getting quote for ${amount} (mint: ${fromMint}) to (mint: ${toMint})`,
                  "info"
                );
                try {
                  const res = await fetch(
                    `${RELAYER_URL}/jupiter/quote?amount=${encodeURIComponent(
                      amount
                    )}&fromMint=${encodeURIComponent(
                      fromMint
                    )}&toMint=${encodeURIComponent(toMint)}`
                  );
                  const data = await res.json();
                  if (data && data.outAmount) {
                    this.logHtml(
                      `<b>Quote:</b> ${amount} ‚Üí ${data.outAmount} (route: ${
                        data.marketInfos?.map((m) => m.label).join(", ") ||
                        "N/A"
                      })`,
                      "success"
                    );
                  } else if (data && data.error) {
                    this.logHtml(
                      `<span style='color:#ff3333'>${data.error}</span>`,
                      "error"
                    );
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">No quote found.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana quote failed: " + e.message, "error");
                }
                return;
              }
              if (args[1] === "swap" && args.length === 2) {
                this.showSolanaSwapInterface();
                return;
              }
              if (args[1] === "swap" && args.length === 5) {
                if (!this.solanaAddress) {
                  this.log(
                    "Please connect your Phantom wallet first using: solana connect",
                    "error"
                  );
                  return;
                }
                const amount = args[2];
                const fromMint = args[3];
                const toMint = args[4];
                this.log(
                  `Swapping ${amount} (mint: ${fromMint}) to (mint: ${toMint})`,
                  "info"
                );
                try {
                  const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      inputMint: fromMint,
                      outputMint: toMint,
                      amount,
                      userPublicKey: this.solanaAddress,
                    }),
                  });
                  const data = await res.json();
                  this.log(
                    "DEBUG: Full relayer response: " + JSON.stringify(data),
                    "info"
                  );
                  if (data && data.transaction) {
                    // Ask Phantom to sign and send the transaction
                    if (window.solana && window.solana.isPhantom) {
                      try {
                        const txBuf = Uint8Array.from(
                          atob(data.transaction),
                          (c) => c.charCodeAt(0)
                        );
                        this.log(
                          "DEBUG: About to send transaction to Phantom",
                          "info"
                        );
                        this.log(
                          "DEBUG: User address: " + this.solanaAddress,
                          "info"
                        );
                        this.log(
                          "DEBUG: Transaction buffer (base64): " +
                            data.transaction,
                          "info"
                        );
                        this.log(
                          "DEBUG: Transaction buffer (Uint8Array length): " +
                            txBuf.length,
                          "info"
                        );
                        let signed;
                        if (
                          window.solanaWeb3 &&
                          window.solanaWeb3.VersionedTransaction
                        ) {
                          try {
                            const transaction =
                              window.solanaWeb3.VersionedTransaction.deserialize(
                                txBuf
                              );
                            this.log(
                              "DEBUG: Deserialized VersionedTransaction:",
                              "info"
                            );
                            this.log(JSON.stringify(transaction), "info");
                            signed = await window.solana.signAndSendTransaction(
                              transaction
                            );
                            this.log(
                              "DEBUG: Used VersionedTransaction object for signing.",
                              "info"
                            );
                          } catch (err) {
                            this.log(
                              "DEBUG: Failed to deserialize VersionedTransaction, falling back to buffer. Error: " +
                                (err && err.message ? err.message : err),
                              "warning"
                            );
                            signed = await window.solana.signAndSendTransaction(
                              { message: txBuf }
                            );
                            this.log("DEBUG: Used buffer for signing.", "info");
                          }
                        } else {
                          signed = await window.solana.signAndSendTransaction({
                            message: txBuf,
                          });
                          this.log(
                            "DEBUG: Used buffer for signing (no VersionedTransaction available).",
                            "info"
                          );
                        }
                        this.log(
                          "DEBUG: Phantom signAndSendTransaction result: " +
                            JSON.stringify(signed),
                          "info"
                        );
                        this.logHtml(
                          `<b>Swap transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signed.signature}')">${signed.signature}</span>`,
                          "success"
                        );
                      } catch (e) {
                        this.log(
                          "DEBUG: Error from Phantom signAndSendTransaction: " +
                            (e && e.message ? e.message : e),
                          "error"
                        );
                        this.log(
                          "User rejected or failed to sign the swap transaction.",
                          "error"
                        );
                      }
                    } else {
                      this.log(
                        "Phantom wallet not available for signing.",
                        "error"
                      );
                    }
                  } else if (data && data.error) {
                    this.logHtml(
                      `<span style='color:#ff3333'>${data.error}</span>`,
                      "error"
                    );
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">Swap failed.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana swap failed: " + e.message, "error");
                }
                return;
              }
            case "near":
              this.log("Near Intents command detected!", "info");

              // near-tokens
              if (args[1] === "tokens") {
                this.log("Fetching Near Intents supported tokens...", "info");
                try {
                  const response = await fetch(
                    "https://1click.chaindefuser.com/v0/tokens"
                  );
                  if (!response.ok) {
                    this.log(
                      `Failed to fetch tokens: HTTP ${response.status}`,
                      "error"
                    );
                    return;
                  }

                  const tokens = await response.json();
                  let html = `<b>Near Intents Supported Tokens (${tokens.length} total):</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Blockchain</th><th>Asset ID</th><th>Price (USD)</th><th>Decimals</th></tr>`;

                  tokens.forEach((token) => {
                    html += `<tr><td>${token.symbol}</td><td>${token.blockchain}</td><td>${token.assetId}</td><td>$${token.price}</td><td>${token.decimals}</td></tr>`;
                  });

                  html += `</table>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Near Intents tokens: " + e.message,
                    "error"
                  );
                }
                return;
              }

              // near-quote
              if (args[1] === "quote") {
                if (args.length < 6) {
                  this.log(
                    "Usage: near quote <originAsset> <destinationAsset> <amount> <slippageBps> <recipient>",
                    "info"
                  );
                  this.log(
                    'Example: near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-recipient-address"',
                    "info"
                  );
                  return;
                }

                const originAsset = args[2];
                const destinationAsset = args[3];
                const amount = args[4];
                const slippageBps = parseInt(args[5]);
                const recipient = args[6];

                this.log(
                  `Getting Near Intents quote for ${amount} ${originAsset} ‚Üí ${destinationAsset}...`,
                  "info"
                );

                try {
                  const quotePayload = {
                    dry: true, // Dry run for quote
                    swapType: "EXACT_INPUT",
                    slippageTolerance: slippageBps,
                    originAsset,
                    depositType: "ORIGIN_CHAIN",
                    destinationAsset,
                    amount,
                    refundTo: recipient, // Use recipient as refund address for now
                    refundType: "ORIGIN_CHAIN",
                    recipient,
                    recipientType: "DESTINATION_CHAIN",
                    deadline: new Date(
                      Date.now() + 24 * 60 * 60 * 1000
                    ).toISOString(), // 24 hours from now
                    quoteWaitingTimeMs: 3000,
                  };

                  const response = await fetch(
                    "https://1click.chaindefuser.com/v0/quote",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify(quotePayload),
                    }
                  );

                  if (!response.ok) {
                    const errorText = await response.text();
                    this.log(`Quote failed: HTTP ${response.status}`, "error");
                    this.log(`Error details: ${errorText}`, "error");
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Near Intents Quote:</b><br>`;
                  html += `Input: <b>${data.quote.amountInFormatted} ${originAsset}</b> ($${data.quote.amountInUsd})<br>`;
                  html += `Output: <b>${data.quote.amountOutFormatted} ${destinationAsset}</b> ($${data.quote.amountOutUsd})<br>`;
                  html += `Min Output: <b>${data.quote.minAmountOutFormatted} ${destinationAsset}</b><br>`;
                  html += `Slippage: <b>${slippageBps / 100}%</b><br>`;
                  html += `Time Estimate: <b>${data.quote.timeEstimate} seconds</b><br>`;
                  html += `Deposit Address: <b>${data.quote.depositAddress}</b><br>`;
                  html += `Deadline: <b>${new Date(
                    data.quote.deadline
                  ).toLocaleString()}</b><br>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Quote failed: ${e.message}`, "error");
                }
                return;
              }

              // near-swap
              if (args[1] === "swap") {
                // Show interactive swap interface
                this.showNearSwapInterface();
                return;
              }

              // near-status
              if (args[1] === "status") {
                let depositAddress;
                if (args[2]) {
                  depositAddress = args[2];
                } else if (window.nearSwapInfo) {
                  depositAddress = window.nearSwapInfo.depositAddress;
                } else {
                  this.log("Usage: near status <depositAddress>", "info");
                  this.log(
                    "Or use: near status (if you have a recent swap)",
                    "info"
                  );
                  return;
                }

                this.log(
                  `Checking Near Intents swap status for: ${depositAddress}`,
                  "info"
                );

                try {
                  const response = await fetch(
                    `https://1click.chaindefuser.com/v0/status?depositAddress=${depositAddress}`
                  );

                  if (!response.ok) {
                    if (response.status === 404) {
                      this.log(
                        "Swap not found. Make sure the deposit address is correct.",
                        "warning"
                      );
                    } else {
                      const errorText = await response.text();
                      this.log(
                        `Status check failed: HTTP ${response.status}`,
                        "error"
                      );
                      this.log(`Error details: ${errorText}`, "error");
                    }
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Near Intents Swap Status:</b><br>`;
                  html += `Status: <b>${data.status}</b><br>`;
                  html += `Updated: <b>${new Date(
                    data.updatedAt
                  ).toLocaleString()}</b><br>`;

                  if (data.swapDetails) {
                    html += `<br><b>Swap Details:</b><br>`;
                    html += `Input: <b>${data.swapDetails.amountInFormatted} ${data.quoteResponse.quoteRequest.originAsset}</b><br>`;
                    html += `Output: <b>${data.swapDetails.amountOutFormatted} ${data.quoteResponse.quoteRequest.destinationAsset}</b><br>`;
                    html += `Slippage: <b>${
                      data.swapDetails.slippage / 100
                    }%</b><br>`;

                    if (
                      data.swapDetails.originChainTxHashes &&
                      data.swapDetails.originChainTxHashes.length > 0
                    ) {
                      html += `<br><b>Origin Chain Transactions:</b><br>`;
                      data.swapDetails.originChainTxHashes.forEach((tx) => {
                        html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                      });
                    }

                    if (
                      data.swapDetails.destinationChainTxHashes &&
                      data.swapDetails.destinationChainTxHashes.length > 0
                    ) {
                      html += `<br><b>Destination Chain Transactions:</b><br>`;
                      data.swapDetails.destinationChainTxHashes.forEach(
                        (tx) => {
                          html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                        }
                      );
                    }

                    if (data.swapDetails.refundedAmount) {
                      html += `<br><b>Refunded Amount:</b> ${data.swapDetails.refundedAmountFormatted}<br>`;
                    }
                  }

                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Status check failed: ${e.message}`, "error");
                }
                return;
              }

              // Wallet commands (added by NEAR wallet fix)
              if (args[1] === "connect" || args[1] === "wallet") {
                if (this.connectNearWalletFixed) {
                  await this.connectNearWalletFixed();
                } else {
                  this.log(
                    "‚ùå NEAR wallet functionality not loaded. Please refresh the page.",
                    "error"
                  );
                }
                return;
              }

              if (args[1] === "disconnect") {
                if (this.disconnectNearWallet) {
                  this.disconnectNearWallet();
                } else {
                  this.log("‚ùå NEAR wallet functionality not loaded.", "error");
                }
                return;
              }

              if (args[1] === "balance" && (!args[2] || args[2] === "wallet")) {
                if (this.showNearWalletBalance) {
                  await this.showNearWalletBalance();
                } else {
                  this.log("‚ùå NEAR wallet functionality not loaded.", "error");
                }
                return;
              }

              if (args[1] === "debug") {
                if (this.debugNearWalletDetection) {
                  this.debugNearWalletDetection();
                } else {
                  this.log(
                    "‚ùå NEAR wallet debug functionality not loaded.",
                    "error"
                  );
                }
                return;
              }

              // near help
              if (args[1] === "help") {
                let html = `<b>NEAR Protocol Commands:</b><br>`;
                html += `<br><b>üíº Wallet Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>near connect</b> ‚Äî Connect NEAR wallet</li>`;
                html += `<li><b>near wallet</b> ‚Äî Same as near connect</li>`;
                html += `<li><b>near disconnect</b> ‚Äî Disconnect NEAR wallet</li>`;
                html += `<li><b>near balance</b> ‚Äî Check NEAR wallet balance</li>`;
                html += `<li><b>near debug</b> ‚Äî Debug wallet detection</li>`;
                html += `</ul>`;
                html += `<br><b>üîÑ Trading Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>near tokens</b> ‚Äî List all supported tokens for cross-chain swaps</li>`;
                html += `<li><b>near quote &lt;originAsset&gt; &lt;destinationAsset&gt; &lt;amount&gt; &lt;slippageBps&gt; &lt;recipient&gt;</b> ‚Äî Get a quote for a cross-chain swap</li>`;
                html += `<li><b>near swap</b> ‚Äî Show interactive cross-chain swap interface</li>`;
                html += `<li><b>near status [depositAddress]</b> ‚Äî Check swap status (uses recent swap if no address provided)</li>`;
                html += `<li><b>near help</b> ‚Äî Show this help</li>`;
                html += `</ul>`;
                html += `<br><b>Examples:</b><br>`;
                html += `<code>near connect</code><br>`;
                html += `<code>near tokens</code><br>`;
                html += `<code>near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-address"</code><br>`;
                html += `<code>near swap</code><br>`;
                html += `<code>near status 0x123abc456def789</code><br>`;
                this.logHtml(html, "output");
                return;
              }

              // Default Near help
              this.log(
                "NEAR commands: connect | wallet | tokens | quote | swap | status | help",
                "info"
              );
              return;

            case "eclipse":
              this.log("Eclipse command detected!", "info");
              if (args[1] === "-help" || args[1] === "help") {
                let html = `<b>Eclipse (SVM) Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>eclipse gen-wallet</b> ‚Äî Generate a new Eclipse (SVM) wallet</li>`;
                html += `<li><b>eclipse wallet-info</b> ‚Äî Show current Eclipse wallet details</li>`;
                html += `<li><b>eclipse balance</b> ‚Äî Check Eclipse wallet balance</li>`;
                html += `<li><b>eclipse swap &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> ‚Äî Execute a swap on Solar DEX</li>`;
                html += `<li><b>eclipse quote &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> ‚Äî Get swap quote without executing</li>`;
                html += `<li><b>eclipse tokens</b> ‚Äî List available tokens on Eclipse</li>`;
                html += `<li><b>eclipse price &lt;mint&gt;</b> ‚Äî Get token price from Solar DEX</li>`;
                html += `</ul>`;
                html += `<br><b>Examples:</b><br>`;
                html += `<code>eclipse swap So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                html += `<code>eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                html += `<code>eclipse price CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze</code><br>`;
                html += `<br><b>Note:</b> Slippage is in basis points (100 = 1%, 50 = 0.5%)<br>`;
                this.logHtml(html, "output");
                return;
              }

              // eclipse gen-wallet
              if (args[1] === "gen-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot generate Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                try {
                  // Generate Solana keypair
                  const keypair = window.solanaWeb3.Keypair.generate();
                  const publicKey = keypair.publicKey.toString();
                  const privateKey = Array.from(keypair.secretKey)
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey,
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                  html += `<br>üí° Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to generate Eclipse wallet: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // eclipse wallet-info
              if (args[1] === "wallet-info") {
                if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                  let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                  html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Eclipse wallet generated in this session. Use: eclipse gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse balance
              if (args[1] === "balance") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                try {
                  const connection = new window.solanaWeb3.Connection(
                    window.eclipseWallet.rpcUrl,
                    "confirmed"
                  );
                  const publicKey = new window.solanaWeb3.PublicKey(
                    window.eclipseWallet.publicKey
                  );
                  const balance = await connection.getBalance(publicKey);
                  const balanceInSol =
                    balance / window.solanaWeb3.LAMPORTS_PER_SOL;

                  this.logHtml(`<b>Eclipse Wallet Balance:</b>`, "output");
                  this.logHtml(
                    `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`,
                    "output"
                  );
                  this.logHtml(
                    `<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`,
                    "output"
                  );
                  this.logHtml(`<b>Network:</b> Eclipse (SVM)`, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Eclipse wallet balance: " + e.message,
                    "error"
                  );
                }
                return;
              }

              // eclipse import-wallet
              if (args[1] === "import-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot import Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                if (args.length < 3) {
                  this.log(
                    "Usage: eclipse import-wallet <private_key>",
                    "info"
                  );
                  this.log(
                    "Example: eclipse import-wallet 1234567890abcdef...",
                    "info"
                  );
                  this.log(
                    "Note: Private key should be a 64-character hex string",
                    "info"
                  );
                  return;
                }

                try {
                  const privateKeyInput = args[2];
                  let keypair;

                  // Try to detect format and handle accordingly
                  this.log(
                    `Debug: Private key length: ${privateKeyInput.length}`,
                    "info"
                  );

                  if (/^[0-9a-fA-F]{64}$/.test(privateKeyInput)) {
                    // Hex format (64 characters)
                    const privateKeyBytes = new Uint8Array(
                      privateKeyInput
                        .match(/.{1,2}/g)
                        .map((byte) => parseInt(byte, 16))
                    );
                    keypair =
                      window.solanaWeb3.Keypair.fromSecretKey(privateKeyBytes);
                    this.log("‚úÖ Detected hex format private key", "success");
                  } else if (
                    /^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(privateKeyInput)
                  ) {
                    // Base58 format (80-88 characters) - standard Solana format
                    this.log(
                      "‚úÖ Base58 pattern matched, attempting decode...",
                      "success"
                    );
                    try {
                      // Use our custom base58 decoder
                      this.log("Debug: Using custom base58 decoder", "info");
                      const privateKeyBytes = base58Decode(privateKeyInput);

                      // Handle different private key formats
                      if (privateKeyBytes.length === 32) {
                        // 32 bytes: Just the private key
                        this.log(
                          "Debug: Detected 32-byte private key format",
                          "info"
                        );
                        keypair =
                          window.solanaWeb3.Keypair.fromSecretKey(
                            privateKeyBytes
                          );
                      } else if (privateKeyBytes.length === 64) {
                        // 64 bytes: Private key + public key (keypair format)
                        this.log(
                          "Debug: Detected 64-byte keypair format, using full keypair data",
                          "info"
                        );
                        // Use the full 64-byte array directly - Solana expects this format
                        keypair =
                          window.solanaWeb3.Keypair.fromSecretKey(
                            privateKeyBytes
                          );
                      } else {
                        this.log(
                          `‚ùå Invalid private key length: ${privateKeyBytes.length} bytes (expected 32 or 64)`,
                          "error"
                        );
                        return;
                      }
                      this.log(
                        "‚úÖ Detected base58 format private key",
                        "success"
                      );
                    } catch (e) {
                      this.log("‚ùå Invalid base58 private key format", "error");
                      this.log(
                        `Debug: base58 decode error: ${e.message}`,
                        "error"
                      );
                      return;
                    }
                  } else {
                    this.log("‚ùå Invalid private key format.", "error");
                    this.log(
                      `Debug: Hex pattern match: ${/^[0-9a-fA-F]{64}$/.test(
                        privateKeyInput
                      )}`,
                      "info"
                    );
                    this.log(
                      `Debug: Base58 pattern match: ${/^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(
                        privateKeyInput
                      )}`,
                      "info"
                    );
                    this.log("Supported formats:", "info");
                    this.log("- Hex: 64-character hex string", "info");
                    this.log(
                      "- Base58: 80-88 character base58 string (standard Solana format)",
                      "info"
                    );
                    this.log(
                      "Example hex: eclipse import-wallet 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                      "info"
                    );
                    this.log(
                      "Example base58: eclipse import-wallet 4dmKkXNHJm1RX4bqrLHBg4m5vMwSrERmyi6CgbdW54BL2ktHvH6zJpFGz7kq8r8WNz1E1LJHaFUztcJLdDFD5xUy",
                      "info"
                    );
                    return;
                  }
                  const publicKey = keypair.publicKey.toString();

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey: privateKeyInput, // Store the original input format
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>Eclipse (SVM) Wallet Imported Successfully!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Your private key is now stored in session memory!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<br>‚úÖ Wallet imported and ready to use!<br>`;
                  html += `<br>üí° Use <b>eclipse balance</b> to check your funds.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to import Eclipse wallet: " + e.message,
                    "error"
                  );
                  this.log(
                    "Make sure your private key is correct and in hex format.",
                    "info"
                  );
                  return;
                }
              }

              // eclipse swap
              if (args[1] === "swap") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                // Show interactive swap interface
                this.showEclipseSwapInterface();
                return;
              }

              // eclipse quote
              if (args[1] === "quote") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                if (args.length < 5) {
                  this.log(
                    "Usage: eclipse quote <inputMint> <outputMint> <amount> <slippageBps>",
                    "info"
                  );
                  this.log(
                    "Example: eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100",
                    "info"
                  );
                  return;
                }

                const inputMint = args[2];
                const outputMint = args[3];
                const amount = parseFloat(args[4]);
                const slippageBps = parseInt(args[5]);

                this.log(
                  `Getting quote for ${amount} ${inputMint} ‚Üí ${outputMint}...`,
                  "info"
                );

                try {
                  // Ensure we have the correct SOL mint address
                  const solMintAddress =
                    "So11111111111111111111111111111111111111112";
                  const actualInputMint =
                    inputMint === "11111111111111111111111111111111"
                      ? solMintAddress
                      : inputMint;

                  // Get compute unit price from Solar API
                  let computeUnitPrice = "auto";
                  try {
                    const feeResponse = await fetch(
                      "https://api.solarstudios.co/main/auto-fee"
                    );
                    if (feeResponse.ok) {
                      const feeData = await feeResponse.json();
                      computeUnitPrice = String(feeData.data.default.h); // Use high priority
                      this.log(
                        `Using compute unit price: ${computeUnitPrice}`,
                        "info"
                      );
                    }
                  } catch (e) {
                    this.log("Using default compute unit price", "info");
                  }

                  const quotePayload = {
                    inputMint: actualInputMint,
                    outputMint,
                    amount: amount * 1e9, // Convert to lamports
                    slippageBps,
                    version: "LEGACY",
                    wallet: window.eclipseWallet.keypair.publicKey.toString(),
                    computeUnitPriceMicroLamports: computeUnitPrice,
                    wrapSol:
                      actualInputMint ===
                      "So11111111111111111111111111111111111111112"
                        ? true
                        : false,
                  };

                  this.log(
                    `Quote payload: ${JSON.stringify(quotePayload)}`,
                    "info"
                  );

                  // Build query parameters for GET request
                  const queryParams = new URLSearchParams({
                    inputMint: actualInputMint,
                    outputMint: outputMint,
                    amount: (amount * 1e9).toString(),
                    slippageBps: slippageBps.toString(),
                    txVersion: "LEGACY",
                  });

                  const response = await fetch(
                    `https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`,
                    {
                      method: "GET",
                      headers: { "Content-Type": "application/json" },
                    }
                  );

                  if (!response.ok) {
                    const errorText = await response.text();
                    this.log(`Quote failed: HTTP ${response.status}`, "error");
                    this.log(`Error details: ${errorText}`, "error");
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Eclipse Swap Quote:</b><br>`;
                  html += `Input: <b>${amount} ${inputMint}</b><br>`;
                  html += `Output: <b>${(data.outAmount / 1e9).toFixed(
                    9
                  )} ${outputMint}</b><br>`;
                  html += `Price Impact: <b>${data.priceImpactPct}%</b><br>`;
                  html += `Minimum Output: <b>${(
                    data.otherAmountThreshold / 1e9
                  ).toFixed(9)} ${outputMint}</b><br>`;
                  html += `Slippage: <b>${slippageBps / 100}%</b><br>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Quote failed: ${e.message}`, "error");
                }
                return;
              }

              // eclipse tokens
              if (args[1] === "tokens") {
                this.log("Fetching Eclipse token lists...", "info");
                try {
                  // Fetch Solar tokens
                  this.log("Fetching Solar DEX tokens...", "info");
                  const solarResponse = await fetch(
                    "https://api.solarstudios.co/mint/list"
                  );
                  let solarTokens = [];
                  if (solarResponse.ok) {
                    const solarData = await solarResponse.json();
                    if (
                      solarData.success &&
                      solarData.data &&
                      solarData.data.mintList
                    ) {
                      solarTokens = solarData.data.mintList;
                    }
                  }

                  // Fetch Deserialize tokens
                  this.log("Fetching Deserialize tokens...", "info");
                  const deserializeResponse = await fetch(
                    "https://api.deserialize.xyz/tokenList"
                  );
                  let deserializeTokens = [];
                  if (deserializeResponse.ok) {
                    const deserializeData = await deserializeResponse.json();
                    if (
                      deserializeData.data &&
                      Array.isArray(deserializeData.data)
                    ) {
                      deserializeTokens = deserializeData.data;
                    }
                  }

                  // Merge tokens and remove duplicates
                  const allTokens = new Map();

                  // Add Solar tokens
                  solarTokens.forEach((token) => {
                    allTokens.set(token.address, {
                      address: token.address,
                      symbol: token.symbol,
                      name: token.name,
                      decimals: token.decimals,
                      source: "Solar",
                    });
                  });

                  // Add Deserialize tokens (will override if duplicate address)
                  deserializeTokens.forEach((token) => {
                    allTokens.set(token.address, {
                      address: token.address,
                      symbol: token.metadata?.symbol || "N/A",
                      name: token.metadata?.name || "N/A",
                      decimals: token.decimals,
                      source: allTokens.has(token.address)
                        ? "Both"
                        : "Deserialize",
                    });
                  });

                  const tokens = Array.from(allTokens.values());

                  let html = `<b>Eclipse Tokens (${tokens.length} total):</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Name</th><th>Mint Address</th><th>Source</th><th>Solar DEX</th><th>Deserialize Agg</th></tr>`;

                  // Show all tokens
                  const displayTokens = tokens;

                  // Fetch Solar prices for all tokens
                  this.log("Fetching Solar DEX prices...", "info");
                  const mintAddresses = displayTokens
                    .map((token) => token.address)
                    .join(",");
                  const solarPriceResponse = await fetch(
                    `https://api.solarstudios.co/mint/price?mints=${mintAddresses}`
                  );
                  const solarPriceData = solarPriceResponse.ok
                    ? await solarPriceResponse.json()
                    : { data: {} };

                  // Fetch Deserialize prices for all tokens
                  this.log("Fetching Deserialize prices...", "info");
                  const deserializePrices = {};

                  // Fetch prices one by one for Deserialize (since it doesn't support batch)
                  for (const token of displayTokens) {
                    try {
                      const deserializeResponse = await fetch(
                        `https://api.deserialize.xyz/tokenPrice/${token.address}`
                      );
                      if (deserializeResponse.ok) {
                        const deserializeData =
                          await deserializeResponse.json();
                        deserializePrices[token.address] =
                          deserializeData.price;
                      }
                    } catch (e) {
                      // Continue if one fails
                    }
                  }

                  displayTokens.forEach((token) => {
                    const solarPrice = solarPriceData.data?.[token.address];
                    const deserializePrice = deserializePrices[token.address];

                    const solarPriceDisplay = solarPrice
                      ? `$${parseFloat(solarPrice).toFixed(6)}`
                      : "N/A";
                    const deserializePriceDisplay = deserializePrice
                      ? `$${parseFloat(deserializePrice).toFixed(6)}`
                      : "N/A";

                    // Color code the source
                    let sourceColor = "#ffffff";
                    if (token.source === "Solar") sourceColor = "#99ccff";
                    if (token.source === "Deserialize") sourceColor = "#ffcc99";
                    if (token.source === "Both") sourceColor = "#ccff99";

                    html += `<tr><td>${token.symbol || "N/A"}</td><td>${
                      token.name || "N/A"
                    }</td><td style='font-size:0.8em;'>${
                      token.address || "N/A"
                    }</td><td style='color:${sourceColor}'>${
                      token.source
                    }</td><td>${solarPriceDisplay}</td><td>${deserializePriceDisplay}</td></tr>`;
                  });

                  // No need for "more tokens" message since we're showing all

                  html += `</table>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Failed to fetch tokens: ${e.message}`, "error");
                }
                return;
              }

              // eclipse price
              if (args[1] === "price" && args[2]) {
                const mint = args[2];
                this.log(`Fetching price for ${mint}...`, "info");
                try {
                  const response = await fetch(
                    `https://api.solarstudios.co/mint/price?mints=${mint}`
                  );
                  if (!response.ok) {
                    this.log("Failed to fetch price", "error");
                    return;
                  }

                  const data = await response.json();
                  const price = data.data?.[mint];

                  if (price) {
                    this.log(`‚úÖ Price: $${price}`, "success");
                  } else {
                    this.log("‚ùå Price not found", "error");
                  }
                } catch (e) {
                  this.log(`Failed to fetch price: ${e.message}`, "error");
                }
                return;
              }

              // Default Eclipse help
              this.log(
                "Eclipse (SVM) commands: gen-wallet | import-wallet | wallet-info | balance | swap | quote | tokens | price | help",
                "info"
              );
              this.log(
                "Near Intents commands: near-tokens | near-quote | near-swap | near-status | help",
                "info"
              );
              this.log(
                "Solana Web3 available: " + (window.solanaWeb3 ? "Yes" : "No"),
                "info"
              );
              return;

            case "nft":
            case "opensea":
              // Check if it's a minting command
              const nftSubcommand = args[1]?.toLowerCase();
              if (
                nftSubcommand === "mint" ||
                nftSubcommand === "collection" ||
                nftSubcommand === "view" ||
                nftSubcommand === "list"
              ) {
                // NFT Minting commands
                if (window.handleNFTMintCommand) {
                  window.handleNFTMintCommand(args.slice(1));
                } else {
                  this.log(
                    "‚ùå NFT Minter not loaded. Please refresh.",
                    "error"
                  );
                }
              } else {
                // OpenSea trading commands
                if (typeof this.handleNFTCommand === "function") {
                  await this.handleNFTCommand(args);
                } else {
                  this.log(
                    "‚ùå Enhanced NFT functionality not loaded. Please refresh the page.",
                    "error"
                  );
                  this.log(
                    "üí° Trading: nft setup | nft search | nft assets | nft buy | nft bid",
                    "info"
                  );
                  this.log(
                    "üí° Minting: nft mint | nft collection | nft view <#>",
                    "info"
                  );
                }
              }
              return;

            case "chat":
              // Terminal Chatter Mode (Telegram-like chat)
              if (window.handleChatCommand) {
                window.handleChatCommand(args.slice(1));
              } else {
                this.log("üí¨ Terminal Chatter", "info");
                this.log("üöÄ Telegram-like community chat", "info");
                this.log(
                  "üí° Commands: chat open | chat settings | chat help",
                  "info"
                );
              }
              return;

            case "python":
              // Python Integration System
              console.log("üêç Python command detected, checking handlers...");
              console.log("omegaPython exists:", !!window.omegaPython);
              console.log(
                "handlePythonCommand exists:",
                typeof window.handlePythonCommand
              );

              if (
                window.omegaPython &&
                typeof window.handlePythonCommand === "function"
              ) {
                this.log("üêç Executing Python command...", "info");
                window.handlePythonCommand(args.slice(0));
              } else {
                this.log("üêç Python Integration System", "info");
                if (!window.omegaPython) {
                  this.log(
                    "‚è≥ Python environment is initializing... Please wait.",
                    "warning"
                  );
                  this.log(
                    "üí° This may take 10-30 seconds on first load.",
                    "info"
                  );
                } else if (typeof window.handlePythonCommand !== "function") {
                  this.log(
                    "‚ùå Python command handler not ready. Please refresh and try again.",
                    "error"
                  );
                } else {
                  this.log(
                    "‚ùå Python system not ready. Please try again.",
                    "error"
                  );
                }
                this.log(
                  "üí° Commands: python help | python upload | python run <script>",
                  "info"
                );
              }
              return;

            case "pgt":
              // PGT Portfolio Tracking Integration
              if (window.handlePGTCommand) {
                window.handlePGTCommand(args.slice(1));
              } else {
                this.log("üéØ PGT Portfolio Tracking", "info");
                this.log(
                  "üìä Multi-chain wallet tracking and portfolio management",
                  "info"
                );
                this.log(
                  "üí° Commands: pgt track | pgt portfolio | pgt wallets | pgt help",
                  "info"
                );
                this.log(
                  '‚ö†Ô∏è Note: Use "pgt-demo" for local testing (CORS-free)',
                  "warning"
                );
              }
              return;

            case "pgt-demo":
              // PGT Demo Mode (CORS-free local testing)
              if (window.handlePGTDemoCommand) {
                window.handlePGTDemoCommand(args.slice(1));
              } else {
                this.log("üéÆ PGT Demo Mode", "info");
                this.log("üìä CORS-free local testing for PGT commands", "info");
                this.log(
                  "üí° Commands: pgt-demo track | pgt-demo portfolio",
                  "info"
                );
              }
              return;

            case "terminal":
              // Simple Terminal Builder System
              if (
                window.simpleTerminalBuilder &&
                typeof window.handleSimpleTerminalCommand === "function"
              ) {
                window.handleSimpleTerminalCommand(args.slice(1));
              } else {
                this.log("üèóÔ∏è Simple Terminal Builder", "info");
                this.log("üìù Create custom terminals with custom URLs", "info");
                this.log(
                  "üí° Commands: terminal create | terminal list | terminal launch",
                  "info"
                );
                if (!window.simpleTerminalBuilder) {
                  this.log(
                    "‚ùå Terminal builder not loaded. Please refresh.",
                    "error"
                  );
                }
              }
              return;

            case "mint":
              // Shortcut for nft mint
              if (window.handleNFTMintCommand) {
                window.handleNFTMintCommand(["mint"]);
              } else {
                this.log("‚ùå NFT Minter not loaded. Please refresh.", "error");
              }
              return;

            case "hyperliquid":
              if (args[1] === "-help" || args[1] === "help") {
                let html = `<b>Hyperliquid Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>hyperliquid perps</b> ‚Äî List all perps with mark price and open interest</li>`;
                html += `<li><b>hyperliquid perp &lt;COIN&gt;</b> ‚Äî Show detailed info for a single perp (mark price, OI, funding, leverage, recent trades)</li>`;
                html += `<li><b>hyperliquid funding &lt;COIN&gt;</b> ‚Äî Show current and historical funding rates for a perp</li>`;
                html += `<li><b>hyperliquid positions &lt;ADDRESS&gt;</b> ‚Äî Show all open perp positions for a given address</li>`;
                html += `<li><b>hyperliquid orderbook &lt;COIN&gt;</b> ‚Äî Show top bids/asks for a perp</li>`;
                html += `<li><b>hyperliquid trades &lt;COIN&gt;</b> ‚Äî Show recent trades for a perp</li>`;
                html += `<li><b>hyperliquid oi-cap</b> ‚Äî Show perps at open interest cap</li>`;
                html += `</ul>`;
                this.logHtml(html, "output");
                return;
              }
              // 0. hyperliquid perps
              if (args[1] === "perps") {
                this.log("Fetching Hyperliquid perps...", "info");
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                  });
                  const data = await res.json();
                  if (
                    Array.isArray(data) &&
                    data.length === 2 &&
                    Array.isArray(data[0].universe) &&
                    Array.isArray(data[1])
                  ) {
                    const universe = data[0].universe;
                    const ctxs = data[1];
                    let html = `<b>Hyperliquid Perps</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Mark Price</th><th>Open Interest</th><th>24h Volume</th><th>Funding</th></tr>`;
                    for (let i = 0; i < universe.length; ++i) {
                      const meta = universe[i];
                      const ctx = ctxs[i];
                      html += `<tr><td><b>${meta.name}</b></td><td>${ctx.markPx}</td><td>${ctx.openInterest}</td><td>${ctx.dayNtlVlm}</td><td>${ctx.funding}</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log(
                      "Failed to parse Hyperliquid perps data.",
                      "error"
                    );
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch Hyperliquid perps: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 1. hyperliquid perp <COIN>
              if (args[1] === "perp" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid perp info for ${coin}...`,
                  "info"
                );
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                  });
                  const data = await res.json();
                  if (
                    Array.isArray(data) &&
                    data.length === 2 &&
                    Array.isArray(data[0].universe) &&
                    Array.isArray(data[1])
                  ) {
                    const universe = data[0].universe;
                    const ctxs = data[1];
                    const idx = universe.findIndex(
                      (x) => x.name.toUpperCase() === coin
                    );
                    if (idx === -1) {
                      this.log(`Perp ${coin} not found.`, "error");
                      return;
                    }
                    const meta = universe[idx];
                    const ctx = ctxs[idx];
                    let html = `<b>${coin} Perp</b><br>`;
                    html += `Mark Price: <b>${ctx.markPx}</b><br>`;
                    html += `Open Interest: <b>${ctx.openInterest}</b><br>`;
                    html += `Funding: <b>${ctx.funding}</b><br>`;
                    html += `Max Leverage: <b>${meta.maxLeverage}</b><br>`;
                    html += `Size Decimals: <b>${meta.szDecimals}</b><br>`;
                    html += `24h Volume: <b>${ctx.dayNtlVlm}</b><br>`;
                    html += `Prev Day Price: <b>${ctx.prevDayPx}</b><br>`;
                    html += `Premium: <b>${ctx.premium}</b><br>`;
                    html += `<hr>`;
                    // Recent trades
                    html += `<b>Recent Trades:</b><br>`;
                    const tradesRes = await fetch(
                      "https://api.hyperliquid.xyz/info",
                      {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ type: "recentTrades", coin }),
                      }
                    );
                    if (!tradesRes.ok) {
                      const text = await tradesRes.text();
                      this.log(
                        `Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`,
                        "error"
                      );
                      return;
                    }
                    const trades = await tradesRes.json();
                    if (Array.isArray(trades) && trades.length > 0) {
                      html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                      for (let i = 0; i < Math.min(trades.length, 10); ++i) {
                        const t = trades[i];
                        html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${
                          t.side
                        }</td><td>${new Date(
                          t.time
                        ).toLocaleTimeString()}</td></tr>`;
                      }
                      html += `</table>`;
                    } else {
                      html += "No recent trades.";
                    }
                    this.logHtml(html, "output");
                  } else {
                    this.log("Failed to parse Hyperliquid perp data.", "error");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch Hyperliquid perp info: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 2. hyperliquid funding <COIN>
              if (args[1] === "funding" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid funding rates for ${coin}...`,
                  "info"
                );
                try {
                  const now = Date.now();
                  const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      type: "fundingHistory",
                      coin,
                      startTime: weekAgo,
                      endTime: now,
                    }),
                  });
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    let html = `<b>${coin} Funding Rates (last 7d):</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Time</th><th>Funding Rate</th><th>Premium</th></tr>`;
                    for (let i = 0; i < Math.min(data.length, 20); ++i) {
                      const f = data[i];
                      html += `<tr><td>${new Date(
                        f.time
                      ).toLocaleString()}</td><td>${f.fundingRate}</td><td>${
                        f.premium
                      }</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No funding history found.", "warning");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch funding history: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 3. hyperliquid positions <ADDRESS>
              if (args[1] === "positions" && args[2]) {
                const user = args[2];
                this.log(
                  `Fetching Hyperliquid perp positions for ${user}...`,
                  "info"
                );
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "clearinghouseState", user }),
                  });
                  const data = await res.json();
                  if (
                    data &&
                    Array.isArray(data.assetPositions) &&
                    data.assetPositions.length > 0
                  ) {
                    let html = `<b>Perp Positions for ${user}:</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Sz</th><th>Entry Px</th><th>Leverage</th><th>Unrealized PnL</th><th>ROE</th></tr>`;
                    for (const pos of data.assetPositions) {
                      const p = pos.position;
                      html += `<tr><td>${p.coin}</td><td>${p.szi}</td><td>${
                        p.entryPx
                      }</td><td>${p.leverage.value}x</td><td>${
                        p.unrealizedPnl
                      }</td><td>${(parseFloat(p.returnOnEquity) * 100).toFixed(
                        2
                      )}%</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No open perp positions found.", "warning");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch perp positions: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 4. hyperliquid orderbook <COIN>
              if (args[1] === "orderbook" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid orderbook for ${coin}...`,
                  "info"
                );
                try {
                  const metaRes = await fetch(
                    "https://api.hyperliquid.xyz/info",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                    }
                  );
                  const metaData = await metaRes.json();
                  if (
                    Array.isArray(metaData) &&
                    metaData.length === 2 &&
                    Array.isArray(metaData[0].universe)
                  ) {
                    const universe = metaData[0].universe;
                    const idx = universe.findIndex(
                      (x) => x.name.toUpperCase() === coin
                    );
                    if (idx === -1) {
                      this.log(`Perp ${coin} not found.`, "error");
                      return;
                    }
                    const orderbookRes = await fetch(
                      "https://api.hyperliquid.xyz/v1/orderbook",
                      {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ coin }),
                      }
                    );
                    const ob = await orderbookRes.json();
                    if (ob && ob.bids && ob.asks) {
                      let html = `<b>${coin} Orderbook</b><br>`;
                      html += `<table style='width:100%;font-size:0.95em;'><tr><th>Bid Px</th><th>Bid Sz</th><th>Ask Px</th><th>Ask Sz</th></tr>`;
                      for (
                        let i = 0;
                        i < Math.max(ob.bids.length, ob.asks.length, 10);
                        ++i
                      ) {
                        const bid = ob.bids[i] || ["", ""];
                        const ask = ob.asks[i] || ["", ""];
                        html += `<tr><td>${bid[0]}</td><td>${bid[1]}</td><td>${ask[0]}</td><td>${ask[1]}</td></tr>`;
                      }
                      html += `</table>`;
                      this.logHtml(html, "output");
                    } else {
                      this.log("No orderbook data found.", "warning");
                    }
                  } else {
                    this.log("Failed to fetch meta for orderbook.", "error");
                  }
                } catch (e) {
                  this.log("Failed to fetch orderbook: " + e.message, "error");
                }
                return;
              }
              // 5. hyperliquid trades <COIN>
              if (args[1] === "trades" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(`Fetching Hyperliquid trades for ${coin}...`, "info");
                try {
                  const tradesRes = await fetch(
                    "https://api.hyperliquid.xyz/info",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({ type: "recentTrades", coin }),
                    }
                  );
                  if (!tradesRes.ok) {
                    const text = await tradesRes.text();
                    this.log(
                      `Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`,
                      "error"
                    );
                    return;
                  }
                  const trades = await tradesRes.json();
                  if (Array.isArray(trades) && trades.length > 0) {
                    let html = `<b>Recent Trades for ${coin}:</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                    for (let i = 0; i < Math.min(trades.length, 20); ++i) {
                      const t = trades[i];
                      html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${
                        t.side
                      }</td><td>${new Date(
                        t.time
                      ).toLocaleTimeString()}</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No recent trades found.", "warning");
                  }
                } catch (e) {
                  this.log("Failed to fetch trades: " + e.message, "error");
                }
                return;
              }
              // 6. hyperliquid oi-cap
              if (args[1] === "oi-cap") {
                this.log("Fetching perps at open interest cap...", "info");
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "perpsAtOpenInterestCap" }),
                  });
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    this.logHtml(
                      `<b>Perps at Open Interest Cap:</b> ${data.join(", ")}`,
                      "output"
                    );
                  } else {
                    this.log("No perps at open interest cap.", "info");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch perps at open interest cap: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // hyperliquid gen-wallet
              if (args[1] === "gen-wallet") {
                const array = new Uint8Array(32);
                window.crypto.getRandomValues(array);
                const privHex = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                let address = "";
                try {
                  if (window.ethers) {
                    const wallet = new window.ethers.Wallet("0x" + privHex);
                    address = wallet.address;
                  } else {
                    this.log(
                      "Ethers.js not loaded. Cannot generate address.",
                      "error"
                    );
                    return;
                  }
                } catch (e) {
                  this.log("Failed to generate wallet: " + e.message, "error");
                  return;
                }
                window.hyperliquidApiWallet = { privHex, address };
                let html = `<b>New Hyperliquid API Wallet Generated!</b><br>`;
                html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can trade on your behalf!</span><br>`;
                html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${address}')">${address}</span><br>`;
                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privHex}')">${privHex}</span><br>`;
                html += `<button onclick="(() => { const blob = new Blob(['${privHex}'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'hyperliquid-api-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Private Key</button><br>`;
                html += `<br>Register this address as an API wallet in your Hyperliquid account.<br>`;
                this.logHtml(html, "output");
                return;
              }
              // hyperliquid wallet-info
              if (args[1] === "wallet-info") {
                if (
                  window.hyperliquidApiWallet &&
                  window.hyperliquidApiWallet.address
                ) {
                  let html = `<b>Current Hyperliquid API Wallet:</b><br>`;
                  html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.address}')">${window.hyperliquidApiWallet.address}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.privHex}')">${window.hyperliquidApiWallet.privHex}</span><br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Hyperliquid API wallet generated in this session. Use: hyperliquid gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse gen-wallet
              if (args[1] === "gen-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot generate Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                try {
                  // Generate Solana keypair
                  const keypair = window.solanaWeb3.Keypair.generate();
                  const publicKey = keypair.publicKey.toString();
                  const privateKey = Array.from(keypair.secretKey)
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey,
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                  html += `<br>üí° Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to generate Eclipse wallet: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // eclipse wallet-info
              if (args[1] === "wallet-info") {
                if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                  let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                  html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Eclipse wallet generated in this session. Use: eclipse gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse balance
              if (args[1] === "balance") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                try {
                  const connection = new window.solanaWeb3.Connection(
                    window.eclipseWallet.rpcUrl,
                    "confirmed"
                  );
                  const publicKey = new window.solanaWeb3.PublicKey(
                    window.eclipseWallet.publicKey
                  );
                  const balance = await connection.getBalance(publicKey);
                  const balanceInSol =
                    balance / window.solanaWeb3.LAMPORTS_PER_SOL;

                  this.logHtml(`<b>Eclipse Wallet Balance:</b>`, "output");
                  this.logHtml(
                    `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`,
                    "output"
                  );
                  this.logHtml(
                    `<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`,
                    "output"
                  );
                  this.logHtml(`<b>Network:</b> Eclipse (SVM)`, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Eclipse wallet balance: " + e.message,
                    "error"
                  );
                }
                return;
              }

              this.log(
                'Unknown Hyperliquid command. Type "hyperliquid help" for available commands.',
                "error"
              );
              return;
            case "magiceden":
            case "me":
              if (args[1] === "help") {
                this.log("=== Magic Eden NFT Marketplace ===", "info");
                this.log("magiceden help - Show this help", "output");
                this.log(
                  "magiceden collections - Get all collections",
                  "output"
                );
                this.log(
                  "magiceden popular - Get popular collections",
                  "output"
                );
                this.log(
                  "magiceden activities <symbol> - Get collection activities",
                  "output"
                );
                this.log("", "output");
                this.log("Examples:", "output");
                this.log("magiceden collections", "output");
                this.log("magiceden popular", "output");
                this.log("magiceden activities okay_bears", "output");
                return;
              }

              if (args[1] === "collections") {
                await this.getMagicEdenCollections();
                return;
              }

              if (args[1] === "popular") {
                await this.getMagicEdenPopularCollections();
                return;
              }

              if (args[1] === "activities" && args.length >= 3) {
                const symbol = args[2];
                await this.getMagicEdenCollectionActivities(symbol);
                return;
              }

              this.log(
                'Unknown Magic Eden command. Type "magiceden help" for available commands.',
                "error"
              );
              return;
            case "ambassador":
              await this.handleAmbassadorCommand(args);
              break;
            case "profile":
              // Check for API key management subcommands first
              if (
                args[1] === "apikeys" ||
                args[1] === "api-keys" ||
                args[1] === "keys"
              ) {
                await this.handleProfileApiKeys(args.slice(2));
                return;
              }
              // Enhanced Profile System (ENS, Address Book, Chat, Fullscreen)
              if (window.handleEnhancedProfileCommand) {
                window.handleEnhancedProfileCommand(args.slice(1));
              } else if (window.openEnhancedProfile) {
                // Direct fallback to open profile
                window.openEnhancedProfile();
              } else {
                this.log("üë§ Enhanced Profile System", "info");
                this.log("üîó Omega ENS registration & management", "info");
                this.log("üìá Address book for contacts", "info");
                this.log("üí¨ Terminal Chatter (Telegram-like)", "info");
                this.log("üêç Python script management", "info");
                this.log("üñ•Ô∏è Fullscreen profile mode", "info");
                this.log(
                  "üí° Commands: profile open | profile help | profile apikeys",
                  "info"
                );
              }
              return;
            case "gui":
              this.handleGuiCommand(args);
              break;
            case "rome":
              this.handleRomeCommand(args);
              break;
            case "kalshi":
              await this.handleKalshiCommand(args);
              break;
            case "polymarket":
            case "poly":
              await this.handlePolymarketCommand(args);
              break;
            case "perp":
            case "perps":
              this.handlePerpCommand(args);
              break;
            default:
              if (cmd) {
                this.log(`Command not found: ${command}`, "error");
                this.log('Type "help" for available commands', "info");
              }
          }
          // --- End command parsing ---
        }

        // Solana swap helper methods
        async executeSolanaSwap(amount, fromMint, toMint) {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }

          try {
            const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                inputMint: fromMint,
                outputMint: toMint,
                amount,
                userPublicKey: this.solanaAddress,
              }),
            });
            const data = await res.json();
            if (data && (data.swapTransaction || data.transaction)) {
              // Ask Phantom to sign and send the transaction
              if (window.solana && window.solana.isPhantom) {
                try {
                  // Convert base64 transaction to Uint8Array
                  const transactionBase64 =
                    data.swapTransaction || data.transaction;
                  const transactionBuffer = Uint8Array.from(
                    atob(transactionBase64),
                    (c) => c.charCodeAt(0)
                  );

                  // Create a VersionedTransaction from the buffer
                  const transaction =
                    solanaWeb3.VersionedTransaction.deserialize(
                      transactionBuffer
                    );

                  // Sign the transaction with Phantom
                  const signedTx = await window.solana.signTransaction(
                    transaction
                  );

                  // Send the signed transaction using Helius RPC endpoint
                  const connection = new solanaWeb3.Connection(
                    "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082"
                  );
                  const signature = await connection.sendRawTransaction(
                    signedTx.serialize(),
                    {
                      maxRetries: 3,
                      skipPreflight: false,
                    }
                  );

                  // Wait for confirmation
                  this.log(
                    "Transaction sent! Waiting for confirmation...",
                    "info"
                  );

                  try {
                    const confirmation = await connection.confirmTransaction(
                      signature,
                      "confirmed"
                    );

                    if (confirmation.value.err) {
                      this.log(
                        `Transaction failed: ${JSON.stringify(
                          confirmation.value.err
                        )}`,
                        "error"
                      );
                    } else {
                      this.logHtml(
                        `<b>Swap transaction successful!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`,
                        "success"
                      );
                      this.logHtml(
                        `<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`,
                        "success"
                      );
                    }
                  } catch (confirmError) {
                    this.log(
                      `Transaction sent but confirmation failed: ${confirmError.message}`,
                      "warning"
                    );
                    this.logHtml(
                      `<b>Transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`,
                      "success"
                    );
                    this.logHtml(
                      `<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`,
                      "success"
                    );
                  }
                } catch (e) {
                  this.log(
                    "User rejected or failed to sign the swap transaction: " +
                      e.message,
                    "error"
                  );
                }
              } else {
                this.log("Phantom wallet not available for signing.", "error");
              }
            } else if (data && data.error) {
              this.logHtml(
                `<span style='color:#ff3333'>${data.error}</span>`,
                "error"
              );
            } else {
              this.logHtml(
                '<span style="color:#ff3333">Swap failed: No transaction received from relayer.</span>',
                "error"
              );
            }
          } catch (e) {
            this.log("Solana swap failed: " + e.message, "error");
          }
        }

        async updateSolanaQuote() {
          const fromToken = document.getElementById("solanaFromToken");
          const toToken = document.getElementById("solanaToToken");
          const amountInput = document.getElementById("solanaAmount");
          const quoteDisplay = document.getElementById("solanaQuoteDisplay");
          const quoteAmount = document.getElementById("solanaQuoteAmount");
          const quotePrice = document.getElementById("solanaQuotePrice");

          if (
            !fromToken ||
            !toToken ||
            !amountInput ||
            !quoteDisplay ||
            !quoteAmount ||
            !quotePrice
          ) {
            return;
          }

          const fromMint = fromToken.value;
          const toMint = toToken.value;
          const amount = parseFloat(amountInput.value);

          if (!fromMint || !toMint || isNaN(amount) || amount <= 0) {
            quoteDisplay.style.display = "none";
            return;
          }

          // Convert amount to lamports for SOL
          let amountLamports;
          if (fromMint === "So11111111111111111111111111111111111111112") {
            amountLamports = Math.floor(amount * 1000000000).toString();
          } else {
            // For other tokens, assume 6 decimals (like USDC)
            amountLamports = Math.floor(amount * 1000000).toString();
          }

          try {
            const res = await fetch(`${RELAYER_URL}/jupiter/quote`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                inputMint: fromMint,
                outputMint: toMint,
                amount: amountLamports,
                slippageBps: 50,
              }),
            });

            const data = await res.json();

            if (data && data.outAmount) {
              // Convert output amount to human readable
              let outputAmount;
              let outputSymbol;

              if (toMint === "So11111111111111111111111111111111111111112") {
                outputAmount = (parseInt(data.outAmount) / 1000000000).toFixed(
                  6
                );
                outputSymbol = "SOL";
              } else {
                outputAmount = (parseInt(data.outAmount) / 1000000).toFixed(6);
                outputSymbol =
                  toMint === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
                    ? "USDC"
                    : toMint === "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
                    ? "USDT"
                    : "Token";
              }

              quoteAmount.textContent = `${outputAmount} ${outputSymbol}`;

              // Calculate and show price impact if available
              if (data.priceImpactPct) {
                const priceImpact = parseFloat(data.priceImpactPct);
                if (priceImpact > 0.1) {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#ff6b6b";
                } else {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#51cf66";
                }
              } else {
                quotePrice.textContent = "";
              }

              quoteDisplay.style.display = "block";
            } else {
              quoteDisplay.style.display = "none";
            }
          } catch (e) {
            quoteDisplay.style.display = "none";
          }
        }

        async promptCustomSwap(tokenMint, tokenSymbol) {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }
          this.customSwapTokenMint = tokenMint;
          this.customSwapTokenSymbol = tokenSymbol;
          this.awaitingCustomSwapDirection = true;
          this.log(`Custom Swap: Choose direction:`, "info");
          this.log("1) SOL ‚Üí " + tokenSymbol, "info");
          this.log("2) " + tokenSymbol + " ‚Üí SOL", "info");
          this.log("Type 1 or 2:", "info");
        }

        async showSolanaSwapInterface() {
          this.log("üü£ Solana Swap Interface", "info");
          this.log("Loading popular tokens...", "info");

          try {
            // Create swap interface with searchable dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">üü£ Solana Swap</h3>`;

            // From token selection with searchable dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="solanaFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="solanaFromTokenDisplay">üü£ SOL (Native)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="solanaFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
            html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
            html += `<input type="text" id="solanaFromSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;
            html += `<div id="solanaFromTokenList">`;
            // Default tokens
            html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üü£ SOL (Solana)</div>`;
            html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíô USDC (USD Coin)</div>`;
            html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíö USDT (Tether USD)</div>`;
            html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üêï BONK (Bonk)</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="solanaFromToken" value="So11111111111111111111111111111111111111112">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with searchable dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="solanaToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="solanaToTokenDisplay">üíô USDC (USD Coin)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="solanaToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
            html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
            html += `<input type="text" id="solanaToSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;
            html += `<div id="solanaToTokenList">`;
            // Default tokens
            html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üü£ SOL (Solana)</div>`;
            html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíô USDC (USD Coin)</div>`;
            html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíö USDT (Tether USD)</div>`;
            html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üêï BONK (Bonk)</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="solanaToToken" value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="solanaAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Swap button
            html += `<button id="solanaSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #9945ff, #7c3aed); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">üü£ Execute Solana Swap</button>`;

            // Quote display section
            html += `<div id="solanaQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
            html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
            html += `<div id="solanaQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
            html += `<div id="solanaQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupSolanaDropdowns();
              const swapBtn = document.getElementById("solanaSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeSolanaSwapFromInterface()
                );
              }

              // Fix input event handling and add quote functionality
              const amountInput = document.getElementById("solanaAmount");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) => {
                  e.stopPropagation();
                  this.updateSolanaQuote();
                });
              }

              // Add quote update on token changes
              const fromToken = document.getElementById("solanaFromToken");
              const toToken = document.getElementById("solanaToToken");
              if (fromToken)
                fromToken.addEventListener("change", () =>
                  this.updateSolanaQuote()
                );
              if (toToken)
                toToken.addEventListener("change", () =>
                  this.updateSolanaQuote()
                );
            }, 100);
          } catch (e) {
            this.log(
              `Failed to load Solana swap interface: ${e.message}`,
              "error"
            );
          }
        }

        async handleCustomSwapInput(amount, toMint) {
          this.awaitingCustomSwap = false;
          await this.executeSolanaSwap(amount, this.customSwapFromMint, toMint);
          this.customSwapFromMint = null;
          this.customSwapSymbol = null;
        }

        async handleDexScreenerCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: dexscreener <search|trending|pair> [query]",
              "info"
            );
            return;
          }
          const sub = args[1];
          if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching DexScreener for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (Array.isArray(data) && data.length > 0) {
                data.forEach((item, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${item.symbol || ""} (${
                      item.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(`Name: <b>${item.name || ""}</b>`, "output");
                  this.logHtml(
                    `Price: <b>${item.priceUsd || item.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      item.tokenAddress || ""
                    }')">${item.tokenAddress || ""}</span>`,
                    "output"
                  );
                  if (item.url)
                    this.logHtml(
                      `<a href="${item.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else if (data.pairs && Array.isArray(data.pairs)) {
                data.pairs.forEach((pair, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.baseToken?.symbol || ""} (${
                      pair.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Name: <b>${pair.baseToken?.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${pair.priceUsd || pair.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      pair.baseToken?.address || ""
                    }')">${pair.baseToken?.address || ""}</span>`,
                    "output"
                  );
                  if (pair.url)
                    this.logHtml(
                      `<a href="${pair.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("DexScreener search failed: " + e.message, "error");
            }
          } else if (sub === "trending") {
            this.log("Fetching DexScreener trending tokens...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/dex/trending`);
              const data = await res.json();
              if (Array.isArray(data) && data.length > 0) {
                data.forEach((item, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${item.symbol || ""} (${
                      item.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(`Name: <b>${item.name || ""}</b>`, "output");
                  this.logHtml(
                    `Price: <b>${item.priceUsd || item.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      item.tokenAddress || ""
                    }')">${item.tokenAddress || ""}</span>`,
                    "output"
                  );
                  if (item.url)
                    this.logHtml(
                      `<a href="${item.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trending tokens found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("DexScreener trending failed: " + e.message, "error");
            }
          } else {
            this.log(
              "Usage: dexscreener <search|trending|pair> [query]",
              "info"
            );
          }
        }

        async handleGeckoTerminalCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: geckoterminal <search|trending|token> [network] [query]",
              "info"
            );
            return;
          }
          // Define show404Suggestion at the top so it is always in scope
          const show404Suggestion = (data) => {
            if (data && data.errors && Array.isArray(data.errors)) {
              const is404 = data.errors.some(
                (e) => e.status === "404" || e.title === "Not Found"
              );
              if (is404) {
                this.logHtml(
                  '<span style="color:#ff3333">Not Found. Try <b>cg networks</b> to see available networks and use the correct slug.</span>',
                  "error"
                );
              }
            }
          };
          const sub = args[1];
          if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching GeckoTerminal for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                data.data.forEach((item, idx) => {
                  const pair = item.attributes;
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `DEX: <b>${pair.dex_name || ""}</b> | Network: <b>${
                      pair.network || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Base: <b>${pair.base_token_symbol || ""}</b> | Quote: <b>${
                      pair.quote_token_symbol || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${
                      pair.price_usd || "N/A"
                    }</b> | Volume 24h: <b>${pair.volume_usd_24h || "N/A"}</b>`,
                    "output"
                  );
                  if (pair.gecko_terminal_url)
                    this.logHtml(
                      `<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
                this.logHtml(
                  '<span style="color:#cccccc">Tip: GeckoTerminal search only returns results for exact or popular pair names.</span>',
                  "info"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log("GeckoTerminal search failed: " + e.message, "error");
            }
          } else if (sub === "trending" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal trending tokens for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/trending`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                data.data.forEach((item, idx) => {
                  const pair = item.attributes;
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `DEX: <b>${pair.dex_name || ""}</b> | Network: <b>${
                      pair.network || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Base: <b>${pair.base_token_symbol || ""}</b> | Quote: <b>${
                      pair.quote_token_symbol || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${
                      pair.price_usd || "N/A"
                    }</b> | Volume 24h: <b>${pair.volume_usd_24h || "N/A"}</b>`,
                    "output"
                  );
                  if (pair.gecko_terminal_url)
                    this.logHtml(
                      `<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trending tokens found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log("GeckoTerminal trending failed: " + e.message, "error");
            }
          } else if (sub === "networks") {
            this.log("Fetching GeckoTerminal networks...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/gecko/networks`);
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml("<b>Available Networks:</b>", "output");
                data.data.forEach((item) => {
                  const net = item.attributes;
                  const id = item.id;
                  const cg = net.coingecko_asset_platform_id
                    ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>`
                    : "";
                  this.logHtml(
                    `<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No networks found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log(
                "GeckoTerminal networks fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "dexes" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal dexes for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/dexes`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>DEXes for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const dex = item.attributes;
                  const id = item.id;
                  this.logHtml(
                    `<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No DEXes found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal dexes fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "pools" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal pools for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>Pools for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal pools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "token" && args[2] && args[3]) {
            const network = args[2];
            const address = args[3];
            this.log(
              `Fetching GeckoTerminal token info for network: ${network}, address: ${address}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const token = data.data.attributes;
                this.logHtml(
                  `<b>${token.name} (${token.symbol})</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${token.price_usd || "N/A"}</b> | TVL: <b>${
                    token.tvl_usd || "N/A"
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `DEX Count: <b>${
                    token.dex_count || "N/A"
                  }</b> | Pool Count: <b>${token.pool_count || "N/A"}</b>`,
                  "output"
                );
                if (token.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No token info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal token fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "tokenpools" && args[2] && args[3]) {
            const network = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Pools for token ${tokenAddress} on ${network}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found for this token.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal tokenpools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "poolinfo" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const pool = data.data.attributes;
                this.logHtml(
                  `<b>${pool.name}</b> | DEX: <b>${
                    pool.dex_name
                  }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                  "output"
                );
                this.logHtml(
                  `Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${pool.price_usd || "N/A"}</b> | Volume 24h: <b>${
                    pool.volume_usd_24h || "N/A"
                  }</b>`,
                  "output"
                );
                if (pool.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pool info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal poolinfo fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "ohlcv" && args[2] && args[3] && args[4]) {
            const network = args[2];
            const poolAddress = args[3];
            const timeframe = args[4];
            this.log(
              `Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  this.logHtml(
                    `<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No OHLCV data found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal ohlcv fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "trades" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Recent trades for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.slice(0, 10).forEach((item) => {
                  const trade = item.attributes;
                  this.logHtml(
                    `<b>${trade.timestamp}</b>: <b>${
                      trade.amount_usd || "N/A"
                    } USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${
                      trade.price_usd || "N/A"
                    }</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trades found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal trades fetch failed: " + e.message,
                "error"
              );
            }
          } else {
            this.log(
              "Usage: geckoterminal <search|trending|token> [network] [query]",
              "info"
            );
          }
        }

        async handleStockCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]",
              "info"
            );
            return;
          }
          const sub = args[1];
          if (sub === "quote" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching stock quote for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/quote/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data.price) {
                this.logHtml(`<b>${symbol} Stock Quote</b>`, "output");
                this.logHtml(`Price: <b>${data.price}</b>`, "output");
                this.logHtml(
                  `Change: <b>${data.change}</b> (${data.changePercent})`,
                  "output"
                );
                this.logHtml(
                  `Open: <b>${data["02. open"] || ""}</b> | High: <b>${
                    data["03. high"] || ""
                  }</b> | Low: <b>${data["04. low"] || ""}</b>`,
                  "output"
                );
                this.logHtml(
                  `Volume: <b>${
                    data["06. volume"] || ""
                  }</b> | Previous Close: <b>${
                    data["08. previous close"] || ""
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `Latest Trading Day: <b>${
                    data["07. latest trading day"] || ""
                  }</b>`,
                  "output"
                );
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No quote found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock quote failed: " + e.message, "error");
            }
          } else if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching stocks for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (
                data &&
                data.bestMatches &&
                Array.isArray(data.bestMatches) &&
                data.bestMatches.length > 0
              ) {
                data.bestMatches.forEach((match, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${match["2. name"]} (${
                      match["1. symbol"]
                    })</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Type: <b>${match["3. type"]}</b> | Region: <b>${match["4. region"]}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Currency: <b>${match["8. currency"]}</b> | Match Score: <b>${match["9. matchScore"]}</b>`,
                    "output"
                  );
                  this.logHtml("<hr>", "output");
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock search failed: " + e.message, "error");
            }
          } else if (sub === "daily" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching daily stock data for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/daily/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data["Time Series (Daily)"]) {
                const series = data["Time Series (Daily)"];
                const dates = Object.keys(series).slice(0, 5); // Show last 5 days
                this.logHtml(`<b>${symbol} - Last 5 Days</b>`, "output");
                dates.forEach((date) => {
                  const d = series[date];
                  this.logHtml(
                    `<b>${date}</b>: Open: <b>${d["1. open"]}</b>, High: <b>${d["2. high"]}</b>, Low: <b>${d["3. low"]}</b>, Close: <b>${d["4. close"]}</b>, Volume: <b>${d["5. volume"]}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No daily data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock daily failed: " + e.message, "error");
            }
          } else if (sub === "overview" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching stock overview for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/overview/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data.Symbol) {
                this.logHtml(`<b>${data.Name} (${data.Symbol})</b>`, "output");
                this.logHtml(
                  `Sector: <b>${data.Sector}</b> | Industry: <b>${data.Industry}</b>`,
                  "output"
                );
                this.logHtml(
                  `Market Cap: <b>${data.MarketCapitalization}</b> | EPS: <b>${data.EPS}</b>`,
                  "output"
                );
                this.logHtml(
                  `PE Ratio: <b>${data.PERatio}</b> | Dividend Yield: <b>${data.DividendYield}</b>`,
                  "output"
                );
                this.logHtml(
                  `Description: <span style='color:#cccccc'>${data.Description}</span>`,
                  "output"
                );
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No overview found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock overview failed: " + e.message, "error");
            }
          } else if (sub === "inflation") {
            this.log("Fetching US inflation data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/inflation`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US Inflation (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No inflation data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Inflation fetch failed: " + e.message, "error");
            }
          } else if (sub === "cpi") {
            this.log("Fetching US CPI data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/cpi`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US CPI (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No CPI data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("CPI fetch failed: " + e.message, "error");
            }
          } else if (sub === "gdp") {
            this.log("Fetching US GDP data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/gdp`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US Real GDP (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No GDP data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("GDP fetch failed: " + e.message, "error");
            }
          } else {
            this.log(
              "Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]",
              "info"
            );
          }
        }

        async handleAlphaKeyCommand(args) {
          this.log(
            "Alpha Vantage API key is managed by the relayer. No action needed.",
            "info"
          );
        }

        async showUnifiedHelp() {
          this.logHtml(
            '<span style="color:#33bbff">=== Omega Terminal v2.0.1 Commands ===</span>',
            "info"
          );

          // NEW FEATURES SECTION (Highlighted)
          this.log("üÜï --- NEW FEATURES (v2.0.1) ----", "success");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#FF6B6B">üçé Modern UI:</span><br>' +
              '<span style="color:#99ccff">modern ui | modern-dark</span><br>' +
              '<span style="color:#888888">Apple-style glass-morphism</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#4ECDC4">üìä DexScreener Analytics:</span><br>' +
              '<span style="color:#99ccff">dexscreener search | analytics | portfolio | watchlist</span><br>' +
              '<span style="color:#888888">Complete token analysis suite</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#45B7D1">ü¶ô DeFi Llama:</span><br>' +
              '<span style="color:#99ccff">defillama tvl | protocols | price | chains</span><br>' +
              '<span style="color:#888888">TVL & price data</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#FF9500">üêç Python Scripts:</span><br>' +
              '<span style="color:#99ccff">python upload | run | list | exec</span><br>' +
              '<span style="color:#888888">Trading bots & custom scripts</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:33%;padding-right:16px;">' +
              '<span style="color:#FF6B35">üéØ PGT Portfolio:</span><br>' +
              '<span style="color:#99ccff">pgt portfolio | pgt wallets | pgt add</span><br>' +
              '<span style="color:#888888">Multi-chain portfolio tracking</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;padding-right:16px;">' +
              '<span style="color:#8B5CF6">üèóÔ∏è Terminal Builder:</span><br>' +
              '<span style="color:#99ccff">terminal create | list | launch</span><br>' +
              '<span style="color:#888888">Create custom terminals with URLs</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;">' +
              '<span style="color:#F59E0B">üéÆ Games:</span><br>' +
              '<span style="color:#99ccff">game list | play snake | play pacman</span><br>' +
              '<span style="color:#888888">Interactive popup games</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:50%;padding-right:16px;">' +
              '<span style="color:#96CEB4">üîµ NEAR Wallet:</span><br>' +
              '<span style="color:#99ccff">near connect | balance | swap</span><br>' +
              '<span style="color:#888888">NEAR ecosystem integration</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;">' +
              '<span style="color:#FF6B6B">üçé Modern UI:</span><br>' +
              '<span style="color:#99ccff">modern ui | modern-dark</span><br>' +
              '<span style="color:#888888">Apple-style glass-morphism</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#8A2BE2">üåä OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search | collection | floor | trending | portfolio</span><br>' +
              '<span style="color:#888888">Professional NFT analytics & trading</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">‚Ä¢ Search collections ‚Ä¢ Floor price tracking ‚Ä¢ Portfolio management</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // CORE FUNCTIONALITY
          this.log("--- Core Wallet Functions ----", "output");
          this.logHtml(
            '<span style="color:#33bbff">Commands: connect | disconnect | balance | faucet | send | network | forceadd | rpccheck</span>',
            "info"
          );
          this.log("--- Mining & Rewards ---", "output");
          this.logHtml(
            '<span style="color:#33bbff">Commands: mine | claim | status | stats</span>',
            "info"
          );

          // THEME SYSTEM (Updated)
          this.log("üé® --- Themes & Interface ----", "output");
          this.logHtml(
            '<span style="color:#33bbff">Themes: modern ui | modern-dark | dark | matrix | retro | bitcoin | ethereum | solana | pepe</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#33bbff">GUI Modes: gui [ios, chatgpt, discord, aol, windows95, limewire]</span>',
            "info"
          );

          // ANALYTICS & DATA
          this.log("üìä --- Analytics & Data ----", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">DexScreener:</span><br>' +
              '<span style="color:#99ccff">dexscreener search BONK</span><br>' +
              '<span style="color:#99ccff">dexscreener analytics ETH</span><br>' +
              '<span style="color:#99ccff">dexscreener portfolio</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">DeFi Llama:</span><br>' +
              '<span style="color:#99ccff">defillama tvl</span><br>' +
              '<span style="color:#99ccff">defillama price ethereum</span><br>' +
              '<span style="color:#99ccff">defillama protocols</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search azuki</span><br>' +
              '<span style="color:#99ccff">nft floor bayc</span><br>' +
              '<span style="color:#99ccff">nft trending</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#33bbff">GeckoTerminal:</span><br>' +
              '<span style="color:#99ccff">cg help</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // BLOCKCHAIN INTEGRATIONS
          this.log("--- Blockchain Networks ---", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Solana:</span><br>' +
              '<span style="color:#99ccff">solana help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Eclipse:</span><br>' +
              '<span style="color:#99ccff">eclipse help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">NEAR:</span><br>' +
              '<span style="color:#99ccff">near connect | near help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Hyperliquid:</span><br>' +
              '<span style="color:#99ccff">hyperliquid help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;">' +
              '<span style="color:#33bbff">OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search | nft trending | nft portfolio</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // ADVANCED FEATURES
          this.log("--- Advanced Features ---", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Mixer (Privacy):</span><br>' +
              '<span style="color:#99ccff">mixer help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Ambassador:</span><br>' +
              '<span style="color:#99ccff">ambassador help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Polymarket:</span><br>' +
              '<span style="color:#99ccff">polymarket help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#9B59B6">üéÆ Games:</span><br>' +
              '<span style="color:#99ccff">game list | play <game></span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#FF9500">üêç Python:</span><br>' +
              '<span style="color:#99ccff">python help | python upload</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">Upload & run Python trading bots</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Email:</span><br>' +
              '<span style="color:#99ccff">email | inbox</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">Encrypted messaging system</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // QUICK START GUIDE
          this.log("üöÄ --- Quick Start Guide ----", "info");
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#FF6B6B">modern ui</span> for beautiful Apple-style interface</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#4ECDC4">dexscreener search BONK</span> for token analysis</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#45B7D1">defillama tvl</span> for DeFi data</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#8A2BE2">nft trending</span> for hot NFT collections</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#FF9500">python help</span> for trading bot integration</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#FF6B35">pgt portfolio</span> for multi-chain portfolio tracking</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">üí° Try: <span style="color:#9B59B6">game list</span> for interactive games</span>',
            "info"
          );

          this.log("--- Economy & Trading ---", "output");
          this.logHtml(
            '<span style="color:#33bbff">alpha help</span> <span style="color:#888888">stocks & economy data</span>',
            "info"
          );
          this.log("---", "output");

          // Footer with version
          this.logHtml(
            '<span style="color:#888888">Omega Terminal v2.0.1 - Modern Apple UI ‚Ä¢ Enhanced Analytics ‚Ä¢ DeFi Integration ‚Ä¢ NFT Trading</span>',
            "info"
          );
        }

        async mine() {
          if (this.isMining) {
            this.log(
              'Mining is already running. Use "stop" to end mining.',
              "warning"
            );
            return;
          }
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          this.isMining = true;
          this.log(
            '‚õèÔ∏è Automated mining started! Use "stop" to end mining.',
            "info"
          );
          this.log(
            "üí∞ IMPROVED REWARDS: 80% chance of earning OMEGA tokens!",
            "success"
          );
          this.log(
            "üéØ Possible rewards: 0.001-1.0 OMEGA per successful mine",
            "info"
          );
          const miningAnimationFrames = ["‚õèÔ∏è", "üî®", "ü™ì", "‚õèÔ∏è", "üî®", "ü™ì"];
          let frame = 0;
          const mineLoop = async () => {
            if (!this.isMining) return;
            try {
              const address = await this.signer.getAddress();
              // Show mining animation with cool steps
              let animSteps = [
                { icon: "üîç", text: "Verifying nonce..." },
                { icon: "üîó", text: "Connecting to Omega miners..." },
                { icon: "üíæ", text: "Loading mining algorithm..." },
                {
                  icon: "üîí",
                  text: () => {
                    const lockFrames = ["/", "-", "\\", "|"];
                    let lockFrame =
                      lockFrames[Math.floor(Math.random() * lockFrames.length)];
                    const fakeHash =
                      this.generateFakeHash().slice(0, 32) + "...";
                    return `[${lockFrame}] Hash: ${fakeHash}`;
                  },
                },
                { icon: "‚ö°", text: "Crunching numbers..." },
                { icon: "üßÆ", text: "Calculating reward probability..." },
              ];
              for (let step of animSteps) {
                let line = document.createElement("div");
                line.className = "output info";
                line.textContent =
                  typeof step.text === "function"
                    ? `${step.icon} ${step.text()}`
                    : `${step.icon} ${step.text}`;
                document.getElementById("terminalContent").appendChild(line);
                document.getElementById("terminalContent").scrollTop =
                  document.getElementById("terminalContent").scrollHeight;
                await new Promise((r) => setTimeout(r, 200));
              }
              // Send mining request
              this.log("‚õèÔ∏è Sending mining request to network...", "info");
              const res = await fetch(RELAYER_URL + "/mine", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ address }),
              });
              const data = await res.json();
              if (!data.success) {
                this.log("‚õèÔ∏è  Block mined (no reward this time)", "output");
              } else {
                this.logHtml(
                  `üì§ Mining tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`,
                  "info"
                );
                if (data.reward && data.reward > 0) {
                  this.totalEarned += parseFloat(data.reward);
                  this.log(
                    `üí∞ Mining reward: +${data.reward} OMEGA`,
                    "success"
                  );
                  this.log(
                    `üèÜ Session total: ${this.totalEarned.toFixed(4)} OMEGA`,
                    "info"
                  );
                  this.log(
                    'üí° Use "claim" to withdraw your rewards!',
                    "success"
                  );
                } else {
                  this.log("‚õèÔ∏è  Block mined (no reward this time)", "output");
                }
              }
            } catch (error) {
              // Handle mining failures gracefully - just show no block mined
              this.log("‚õèÔ∏è  Block mined (no reward this time)", "output");
            }
            if (this.isMining) {
              setTimeout(mineLoop, 8000); // Faster mining - 8 seconds instead of 15
            }
          };
          mineLoop();
        }

        async startAutomatedMiningLoop() {
          const mineNextBlock = async () => {
            if (!this.isMining) return;

            try {
              this.mineCount++;
              const nonce = this.miningNonce;
              this.miningNonce++;
              const solution = this.generateRandomSolution();
              this.log(`‚õèÔ∏è  Mining block #${this.mineCount}...`, "info");
              this.log(`üéØ Nonce: ${nonce}`, "output");
              // --- Begin hashing animation ---
              const spinnerFrames = ["|", "/", "-", "\\"];
              let spinnerIndex = 0;
              for (let i = 0; i < 6; i++) {
                // Reduced from 10 to 6 iterations
                await new Promise((resolve) => setTimeout(resolve, 50)); // Faster animation - 50ms instead of 80ms
                this.log(
                  `üîí [${
                    spinnerFrames[spinnerIndex]
                  }] Hashing: ${this.generateFakeHash()}`,
                  "output"
                );
                spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
              }
              // --- End hashing animation ---
              this.log(`üîë Solution: ${solution.slice(0, 16)}...`, "output");
              const tx = await this.contract
                .connect(this.miningWallet)
                .mineBlock(nonce, solution, {
                  gasLimit: 200000,
                  gasPrice: await this.provider.getGasPrice(),
                });
              this.logHtml(
                `üì§ Transaction sent: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}').then(() => window.terminal.log('‚úÖ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy transaction hash', 'error'))">${tx.hash}</span>`,
                "info"
              );
              const receipt = await tx.wait();
              if (receipt.status === 1) {
                try {
                  const minerInfo = await this.contract.getMinerInfo(
                    this.miningWallet.address
                  );
                  const pendingRewards = minerInfo[2];
                  const rewardInWei = pendingRewards;
                  const rewardInEther =
                    this.ethers.utils.formatEther(rewardInWei);
                  if (rewardInWei.gt(0)) {
                    this.totalEarned += parseFloat(rewardInEther);
                    this.log(
                      `üí∞ Mining reward: +${rewardInEther} OMEGA`,
                      "success"
                    );
                    this.log(
                      `üí≥ Total earned this session: ${this.totalEarned.toFixed(
                        6
                      )} OMEGA`,
                      "info"
                    );
                  } else {
                    this.log(`‚õèÔ∏è  Block mined (no reward this time)`, "output");
                  }
                } catch (error) {
                  this.log(
                    `‚ö†Ô∏è Could not fetch reward info: ${error.message}`,
                    "warning"
                  );
                  const simulatedReward = this.calculateMiningReward();
                  if (simulatedReward > 0) {
                    this.totalEarned += simulatedReward;
                    this.log(
                      `üí∞ Mining reward: +${simulatedReward.toFixed(
                        6
                      )} OMEGA (simulated)`,
                      "success"
                    );
                    this.log(
                      `üí≥ Total earned this session: ${this.totalEarned.toFixed(
                        6
                      )} OMEGA`,
                      "info"
                    );
                  } else {
                    this.log(`‚õèÔ∏è  Block mined (no reward this time)`, "output");
                  }
                }
              } else {
                this.log(`‚õèÔ∏è  Block mined (no reward this time)`, "output");
              }
            } catch (error) {
              // Handle mining failures gracefully - just show no block mined
              this.log("‚õèÔ∏è  Block mined (no reward this time)", "output");

              // Still handle nonce issues silently
              if (
                error.message &&
                (error.message.includes("nonce") ||
                  error.message.includes("replacement"))
              ) {
                this.miningNonce = await this.provider.getTransactionCount(
                  this.miningWallet.address,
                  "latest"
                );
              }
            }
            if (this.isMining) setTimeout(mineNextBlock, 8000); // Faster mining - 8 seconds instead of 15
          };
          mineNextBlock();
        }

        generateRandomSolution() {
          const chars = "0123456789abcdef";
          let solution = "0x";
          for (let i = 0; i < 64; i++) {
            solution += chars[Math.floor(Math.random() * chars.length)];
          }
          return solution;
        }

        calculateMiningReward() {
          const random = Math.random();

          // IMPROVED: Much better reward distribution for user engagement
          // 5% chance for big reward (0.5-1.0 OMEGA)
          if (random < 0.05) {
            return parseFloat((Math.random() * 0.5 + 0.5).toFixed(4));
          }
          // 15% chance for good reward (0.1-0.5 OMEGA)
          else if (random < 0.2) {
            return parseFloat((Math.random() * 0.4 + 0.1).toFixed(4));
          }
          // 25% chance for medium reward (0.01-0.1 OMEGA)
          else if (random < 0.45) {
            return parseFloat((Math.random() * 0.09 + 0.01).toFixed(4));
          }
          // 35% chance for small reward (0.001-0.01 OMEGA)
          else if (random < 0.8) {
            return parseFloat((Math.random() * 0.009 + 0.001).toFixed(4));
          }
          // 20% chance for no reward (reduced from 60%)
          else {
            return 0;
          }
        }

        generateFakeHash() {
          const chars = "0123456789abcdef";
          let hash = "0x";
          for (let i = 0; i < 64; i++) {
            hash += chars[Math.floor(Math.random() * chars.length)];
          }
          return hash;
        }

        // Add missing methods that are referenced in the code
        logCommand(command) {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = "terminal-line";
          line.innerHTML = `<span class="prompt">root@omega-miner:~$</span><span class="command"> ${command}</span>`;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab) tab.history.push({ type: "command", content: command });
        }

        log(message, type = "output") {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = `output ${type}`;
          line.textContent = message;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab)
            tab.history.push({
              type: "output",
              content: message,
              logType: type,
            });
        }

        logHtml(html, type = "output") {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = `terminal-line ${type}`;
          line.innerHTML = html;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab)
            tab.history.push({ type: "output", content: html, logType: type });
        }

        clearTerminal() {
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
        }

        updateConnectionStatus(status) {
          const statusElement = document.getElementById("connectionStatus");
          if (statusElement) {
            statusElement.textContent = status;
          }
        }

        // Replace old showHelp with unified version
        showHelp() {
          this.showUnifiedHelp();
        }

        async checkNetwork() {
          this.log("üîç Checking network configuration...", "info");

          // Check if wallet is connected
          if (!this.provider) {
            this.log("‚ùå No wallet provider available", "error");
            this.log("üí° Connect your wallet first using: connect", "info");
            return;
          }

          try {
            // Get current network from provider
            const network = await this.provider.getNetwork();
            this.log(`üì° Current Network:`, "info");
            this.log(
              `   Chain ID: ${network.chainId} (0x${network.chainId.toString(
                16
              )})`,
              "info"
            );
            this.log(`   Name: ${network.name || "Unknown"}`, "info");

            // Check if we're on the correct network
            const expectedChainId = 1313161768; // 0x4e454228
            if (network.chainId === expectedChainId) {
              this.log("‚úÖ Connected to Omega Network!", "success");
            } else {
              this.log("‚ùå Not connected to Omega Network", "error");
              this.log(
                `üí° Expected Chain ID: ${expectedChainId} (0x4e454228)`,
                "info"
              );
              this.log(
                `üí° Current Chain ID: ${
                  network.chainId
                } (0x${network.chainId.toString(16)})`,
                "info"
              );
              this.log('üí° Use "connect" to switch to Omega Network', "info");
            }

            // Show network configuration that would be sent to MetaMask
            this.log("üîß Network Configuration (for MetaMask):", "info");
            this.log(
              `   Chain ID: 0x4e454228 (${parseInt("0x4e454228", 16)} decimal)`,
              "info"
            );
            this.log(
              `   RPC URL: https://0x4e454228.rpc.aurora-cloud.dev`,
              "info"
            );
            this.log(
              `   Explorer: https://0x4e454228.explorer.aurora-cloud.dev/`,
              "info"
            );

            // Check what the RPC endpoint actually returns
            this.log("üîç Checking RPC endpoint chain ID...", "info");
            try {
              const rpcResponse = await fetch(
                "https://0x4e454228.rpc.aurora-cloud.dev",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    jsonrpc: "2.0",
                    method: "eth_chainId",
                    params: [],
                    id: 1,
                  }),
                }
              );
              const rpcData = await rpcResponse.json();
              if (rpcData.result) {
                const rpcChainId = parseInt(rpcData.result, 16);
                this.log(
                  `üì° RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`,
                  "info"
                );

                if (rpcChainId === 1313161768) {
                  this.log(
                    "‚úÖ RPC endpoint returns correct chain ID",
                    "success"
                  );
                } else {
                  this.log(
                    "‚ùå RPC endpoint returns different chain ID than expected",
                    "error"
                  );
                  this.log(
                    `üí° This explains the MetaMask mismatch warning`,
                    "info"
                  );
                }
              } else {
                this.log(
                  "‚ùå Could not get chain ID from RPC endpoint",
                  "error"
                );
              }
            } catch (rpcError) {
              this.log(
                `‚ùå Error checking RPC endpoint: ${rpcError.message}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`‚ùå Error checking network: ${error.message}`, "error");
          }
        }

        async forceAddNetwork() {
          this.log(
            "üîÑ Force adding Omega Network with correct configuration...",
            "info"
          );

          if (!this.provider) {
            this.log("‚ùå No wallet provider available", "error");
            this.log("üí° Connect your wallet first using: connect", "info");
            return;
          }

          try {
            // First, try to remove any existing Omega network
            // Note: Removed old chain ID 0x330 reference to prevent conflicts
            this.log(
              "‚ÑπÔ∏è Skipping old network removal (0x330) to prevent conflicts",
              "info"
            );

            try {
              await this.provider.request({
                method: "wallet_removeEthereumChain",
                params: [{ chainId: "0x4e454228" }], // New chain ID
              });
              this.log(
                "üóëÔ∏è Removed existing Omega network configuration",
                "info"
              );
            } catch (removeError) {
              // Ignore errors if network doesn't exist
              this.log("‚ÑπÔ∏è No existing network to remove", "info");
            }

            // Now add the correct network configuration
            const networkConfig = {
              chainId: "0x4e454228",
              chainName: "Omega Network",
              nativeCurrency: { name: "OMEGA", symbol: "OMEGA", decimals: 18 },
              rpcUrls: ["https://0x4e454228.rpc.aurora-cloud.dev"],
              blockExplorerUrls: [
                "https://0x4e454228.explorer.aurora-cloud.dev/",
              ],
            };

            this.log("üîß Adding network with correct configuration:", "info");
            this.log(
              `   Chain ID: ${networkConfig.chainId} (${parseInt(
                networkConfig.chainId,
                16
              )} decimal)`,
              "info"
            );
            this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, "info");
            this.log(
              `   Explorer: ${networkConfig.blockExplorerUrls[0]}`,
              "info"
            );

            await this.provider.request({
              method: "wallet_addEthereumChain",
              params: [networkConfig],
            });

            this.log(
              "‚úÖ Successfully added Omega network with correct configuration!",
              "success"
            );
            this.log(
              "üí° You may need to manually switch to the network in MetaMask",
              "info"
            );
          } catch (error) {
            this.log(
              `‚ùå Failed to force add network: ${error.message}`,
              "error"
            );
            this.log(
              "üí° Try manually removing the Omega network from MetaMask and reconnecting",
              "info"
            );
          }
        }

        async checkRpcChainId() {
          this.log("üîç Checking RPC endpoint chain ID directly...", "info");

          try {
            const rpcResponse = await fetch(
              "https://0x4e454228.rpc.aurora-cloud.dev",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  method: "eth_chainId",
                  params: [],
                  id: 1,
                }),
              }
            );

            const rpcData = await rpcResponse.json();
            this.log("üì° RPC Response:", "info");
            this.log(`   Raw response: ${JSON.stringify(rpcData)}`, "info");

            if (rpcData.result) {
              const rpcChainId = parseInt(rpcData.result, 16);
              this.log(
                `üì° RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`,
                "info"
              );

              const expectedChainId = 1313161768; // 0x4e454228
              if (rpcChainId === expectedChainId) {
                this.log("‚úÖ RPC endpoint returns correct chain ID", "success");
              } else {
                this.log(
                  "‚ùå RPC endpoint returns different chain ID than expected",
                  "error"
                );
                this.log(
                  `üí° Expected: ${expectedChainId} (0x4e454228)`,
                  "info"
                );
                this.log(
                  `üí° Actual: ${rpcChainId} (${rpcData.result})`,
                  "info"
                );
                this.log(
                  `üí° This mismatch explains the MetaMask warning`,
                  "info"
                );
              }
            } else {
              this.log("‚ùå Could not get chain ID from RPC endpoint", "error");
              this.log(
                `üí° Error: ${rpcData.error || "Unknown error"}`,
                "error"
              );
            }
          } catch (rpcError) {
            this.log(
              `‚ùå Error checking RPC endpoint: ${rpcError.message}`,
              "error"
            );
          }
        }

        async showBalance() {
          this.logHtml("<b>Wallets:</b>", "output");

          // Omega Wallet
          this.logHtml("<b>Omega Wallet:</b>", "output");
          if (this.signer) {
            try {
              const address = await this.signer.getAddress();
              const balance = await this.provider.getBalance(address);
              const formattedBalance = this.ethers.utils.formatEther(balance);
              this.logHtml(
                `  Balance: <b>${formattedBalance} OMEGA</b>`,
                "output"
              );
              this.logHtml(
                `  Address: <span style="color:#99ccff">${address}</span>`,
                "output"
              );

              // Show claimable OMEGA from relayer
              try {
                const claimableRes = await fetch(RELAYER_URL + "/claimable", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ address }),
                });
                const claimableData = await claimableRes.json();
                if (claimableData.success && claimableData.amount > 0) {
                  this.logHtml(
                    `  ü™ô <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>${claimableData.amount} OMEGA</b>`,
                    "output"
                  );
                } else {
                  this.logHtml(
                    `  ü™ô <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>0 OMEGA</b>`,
                    "output"
                  );
                }
              } catch (err) {
                this.logHtml(
                  `  ü™ô <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>N/A</b> (Error: ${err.message})`,
                  "output"
                );
              }
            } catch (error) {
              this.logHtml("  Balance: <b>N/A OMEGA</b>", "output");
              this.logHtml(
                '  Address: <span style="color:#ff3333">N/A</span>',
                "output"
              );
              this.logHtml(
                "  [Error fetching OMEGA balance: " +
                  (error && error.message ? error.message : error) +
                  "]",
                "error"
              );
            }
          } else {
            this.logHtml("  Balance: <b>N/A OMEGA</b>", "output");
            this.logHtml(
              '  Address: <span style="color:#ff3333">Not connected</span>',
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Solana Wallet
          this.logHtml("<b>Solana Wallet:</b>", "output");
          if (this.solanaAddress) {
            try {
              const body = {
                jsonrpc: "2.0",
                id: 1,
                method: "getBalance",
                params: [this.solanaAddress],
              };
              const res = await fetch(
                "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(body),
                }
              );
              const data = await res.json();
              let sol = "N/A";
              if (
                data &&
                data.result &&
                typeof data.result.value === "number"
              ) {
                sol = data.result.value / 1e9;
              }
              this.logHtml(`  Balance: <b>${sol} SOL</b>`, "output");
            } catch (err) {
              this.logHtml("  Balance: <b>N/A (Failed to fetch)</b>", "output");
            }
            this.logHtml(
              `  Address: <span style="color:#99ccff">${this.solanaAddress}</span>`,
              "output"
            );
          } else {
            this.logHtml("  Balance: <b>N/A SOL</b>", "output");
            this.logHtml(
              '  Address: <span style="color:#ff3333">Not connected</span>',
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Hyperliquid Wallet
          this.logHtml("<b>Hyperliquid Wallet:</b>", "output");
          if (
            window.hyperliquidApiWallet &&
            window.hyperliquidApiWallet.address
          ) {
            this.logHtml(
              `  Address: <span style='color:#99ccff'>${window.hyperliquidApiWallet.address}</span>`,
              "output"
            );
            this.logHtml(
              `  Private Key: <span style='color:#ff3333'>${window.hyperliquidApiWallet.privHex}</span>`,
              "output"
            );
          } else {
            this.logHtml(
              "  No Hyperliquid API wallet generated in this session.",
              "output"
            );
            this.logHtml(
              "  To generate a wallet, type: <b>hyperliquid gen-wallet</b>",
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Eclipse Wallet
          this.logHtml("<b>Eclipse Wallet:</b>", "output");
          if (window.eclipseWallet && window.eclipseWallet.publicKey) {
            try {
              const connection = new window.solanaWeb3.Connection(
                window.eclipseWallet.rpcUrl,
                "confirmed"
              );
              const publicKey = new window.solanaWeb3.PublicKey(
                window.eclipseWallet.publicKey
              );
              const balance = await connection.getBalance(publicKey);
              const balanceInSol = (balance / 1e9).toLocaleString(undefined, {
                minimumFractionDigits: 4,
                maximumFractionDigits: 8,
              });
              this.logHtml(`  Balance: <b>${balanceInSol} SOL</b>`, "output");
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`,
                "output"
              );
            } catch (err) {
              this.logHtml("  Balance: <b>N/A SOL</b>", "output");
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`,
                "output"
              );
              this.logHtml(
                "  [Error fetching Eclipse balance: " +
                  (err && err.message ? err.message : err) +
                  "]",
                "error"
              );
            }
          } else {
            this.logHtml(
              "  No Eclipse API wallet generated in this session.",
              "output"
            );
            this.logHtml(
              "  To generate a wallet, type: <b>eclipse gen-wallet</b>",
              "output"
            );
          }
        }

        async showStatus() {
          if (!this.signer) {
            this.log("‚ùå Wallet not connected", "error");
            return;
          }

          try {
            const address = await this.signer.getAddress();
            this.log(`‚úÖ Wallet: ${address}`, "success");
            this.log(
              `‚õèÔ∏è  Mining: ${this.isMining ? "Active" : "Inactive"}`,
              "info"
            );
            this.log(
              `üí∞ Pending: ${this.totalEarned.toFixed(6)} OMEGA`,
              "info"
            );
            this.log(`üìä Blocks Mined: ${this.mineCount || 0}`, "info");
          } catch (error) {
            this.log("‚ùå Failed to get status: " + error.message, "error");
          }
        }

        async showStats() {
          this.log("üìä Mining Statistics:", "info");
          this.log(`‚õèÔ∏è  Total Blocks: ${this.mineCount || 0}`, "output");
          this.log(
            `üëª Ghost Transactions: ${this.ghostTransactionCount || 0}`,
            "output"
          );
          this.log(
            `üí∞ Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`,
            "output"
          );
          this.log(
            `‚è±Ô∏è  Session Time: ${
              this.startTime
                ? Math.floor((Date.now() - this.startTime) / 1000)
                : 0
            }s`,
            "output"
          );
          this.log(`üéØ Reward Structure: Avg 0.0001 | Max 1.0 OMEGA`, "output");
        }

        stopAll() {
          let stoppedActivities = [];

          // Stop mining
          if (this.isMining) {
            this.isMining = false;
            stoppedActivities.push("mining");
            this.log("‚èπÔ∏è  Mining stopped.", "info");
          }

          // Stop stress testing
          if (this.isStressTesting) {
            this.isStressTesting = false;
            if (this.stressTestInterval) {
              clearInterval(this.stressTestInterval);
              this.stressTestInterval = null;
            }
            stoppedActivities.push("stress testing");
          }

          // Also clear stress funding interval if running
          if (this.stressFundingInterval) {
            clearInterval(this.stressFundingInterval);
            this.stressFundingInterval = null;
          }

          if (stoppedActivities.length > 0) {
            this.log(`‚èπÔ∏è  Stopped: ${stoppedActivities.join(", ")}`, "success");
          } else {
            this.log("‚èπÔ∏è  No activities were running to stop", "info");
          }
        }

        async startMiningSession() {
          this.log("üöÄ Starting mining session...", "info");
          await this.mine();
        }

        async faucetClaim() {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (this.sessionOmegaWallet) {
            const approved = await this.confirmOmegaTransaction();
            if (!approved) return;
          }
          try {
            this.log("üö∞ Claiming from faucet...", "info");
            const faucetContract = new this.ethers.Contract(
              this.faucetAddress,
              this.faucetABI,
              this.signer
            );
            const tx = await faucetContract.claim({ gasLimit: 100000 });
            await tx.wait();
            this.log("‚úÖ Faucet claim successful!", "success");
          } catch (error) {
            this.log("‚ùå Faucet claim failed: " + error.message, "error");
          }
        }

        async showPendingRewards() {
          const minerInfo = await this.contract.getMinerInfo(
            this.miningWallet.address
          );
          const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
          this.log(`üí∞ Pending Rewards: ${pendingRewards} OMEGA`, "info");
          if (parseFloat(pendingRewards) > 0) {
            this.log('üí° Use "claim" command to collect rewards', "info");
          }
        }

        async depositForMining() {
          this.log("üí° This feature is not yet implemented", "info");
        }

        async deployContract() {
          this.log("üí° Contract deployment is handled separately", "info");
        }

        async showContractInfo() {
          this.log(`üìã Mining Contract: ${this.contractAddress}`, "info");
          this.log(`üö∞ Faucet Contract: ${this.faucetAddress}`, "info");
        }

        async startStressTest() {
          if (!this.ethers || !this.provider || !this.provider.getNetwork) {
            this.log(
              "Ethers library or provider not loaded. Please refresh the page and connect your wallet.",
              "error"
            );
            return;
          }
          const network = await this.provider.getNetwork();
          if (!network || !network.chainId || network.chainId === 0) {
            this.log(
              "‚ö†Ô∏è No valid network detected - stress test will not send real transactions.",
              "warning"
            );
            return;
          }
          if (this.isStressTesting) {
            this.log(
              'Stress test already running. Use "stopstress" to stop it.',
              "warning"
            );
            return;
          }

          // Generate a new wallet for the stress test
          this.stressWallet = this.ethers.Wallet.createRandom();
          this.log("üÜï Stress Test Wallet Generated:", "info");
          this.logHtml(
            'Address: <span class="copyable" onclick="navigator.clipboard.writeText(\'' +
              this.stressWallet.address +
              "').then(() => window.terminal.log('‚úÖ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy address', 'error'))\">" +
              this.stressWallet.address +
              "</span>",
            "output"
          );
          this.logHtml(
            'üí° <span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundStressWallet(\'0.001\')">[Click here to fund with 0.001 OMEGA]</span>',
            "info"
          );

          // Connect wallet to provider
          this.stressWallet = this.stressWallet.connect(this.provider);

          // Wait for funding
          this.log("‚è≥ Waiting for funding to initiate stress test...", "info");
          this.isStressTesting = true;
          this.stressTestStats = {
            walletsCreated: 0,
            transactionsSent: 0,
            successfulTxs: 0,
            failedTxs: 0,
            startTime: Date.now(),
          };

          // Poll for funding every 5 seconds
          this.stressFundingInterval = setInterval(async () => {
            const balance = await this.provider.getBalance(
              this.stressWallet.address
            );
            if (!balance.isZero()) {
              clearInterval(this.stressFundingInterval);
              this.log(
                "‚úÖ Funding detected! Starting stress test...",
                "success"
              );
              // Fetch and store the starting nonce
              this.localNonce = await this.provider.getTransactionCount(
                this.stressWallet.address,
                "latest"
              );
              this.startStressTestCycle();
            }
          }, 5000);
        }

        startStressTestCycle() {
          this.stressTestInterval = setInterval(() => {
            if (this.isStressTesting) {
              this.runStressTestCycle();
            }
          }, 3000);
          this.log("‚úÖ Stress test will now begin!", "success");
        }

        async runStressTestCycle() {
          try {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            const newWallet = this.ethers.Wallet.createRandom();
            this.stressTestStats.walletsCreated++;
            const gasPrice = await this.provider.getGasPrice();

            // Log stress wallet address and balance before sending
            const stressAddress = this.stressWallet.address;
            const balance = await this.provider.getBalance(stressAddress);
            this.log(
              `[DEBUG] Stress wallet: ${stressAddress}, Balance: ${this.ethers.utils.formatEther(
                balance
              )} OMEGA`,
              "info"
            );
            this.log(
              `[DEBUG] Provider: ${
                this.provider.connection && this.provider.connection.url
                  ? this.provider.connection.url
                  : "unknown"
              }`,
              "info"
            );

            // Use and increment local nonce
            const nonce = this.localNonce;
            this.localNonce++;

            const txObj = {
              to: newWallet.address,
              value: 0,
              gasLimit: 21000,
              gasPrice: gasPrice,
              nonce: nonce,
            };
            this.log(`[DEBUG] Sending tx: ${JSON.stringify(txObj)}`, "info");

            const tx = await this.stressWallet.sendTransaction(txObj);

            this.stressTestStats.transactionsSent++;
            this.log(
              `üì§ Sent empty tx to ${newWallet.address.slice(
                0,
                10
              )}... (hash: ${tx.hash})`,
              "info"
            );
            this.stressTestStats.successfulTxs++;
          } catch (err) {
            this.stressTestStats.failedTxs++;
            this.log(
              `[DEBUG] Error: ${err && err.stack ? err.stack : err}`,
              "error"
            );
            // If nonce error, re-sync local nonce
            if (
              err.message &&
              (err.message.includes("nonce") ||
                err.message.includes("replacement"))
            ) {
              this.log(
                "üîÑ Nonce error detected, re-syncing nonce from network...",
                "warning"
              );
              this.localNonce = await this.provider.getTransactionCount(
                this.stressWallet.address,
                "latest"
              );
            } else if (
              err.message &&
              err.message.includes("Internal JSON-RPC error")
            ) {
              this.log(`‚ö†Ô∏è RPC overload - slowing down...`, "warning");
              await new Promise((resolve) => setTimeout(resolve, 2000));
            } else {
              this.log(`‚ùå Transaction failed: ${err.message}`, "error");
            }
          }
        }

        stopStressTest() {
          if (!this.isStressTesting) {
            this.log("No stress test running.", "warning");
            return;
          }

          if (this.stressTestInterval) {
            clearInterval(this.stressTestInterval);
          }
          if (this.stressFundingInterval) {
            clearInterval(this.stressFundingInterval);
          }

          this.isStressTesting = false;
          this.log("üõë Stress test stopped.", "warning");
          this.showStressStats();
        }

        showStressStats() {
          if (!this.stressTestStats.startTime) {
            this.log("No stress test has been run yet.", "info");
            return;
          }

          const runtime = Math.floor(
            (Date.now() - this.stressTestStats.startTime) / 1000
          );
          const successRate =
            this.stressTestStats.transactionsSent > 0
              ? (
                  (this.stressTestStats.successfulTxs /
                    this.stressTestStats.transactionsSent) *
                  100
                ).toFixed(1)
              : 0;

          this.log("=== STRESS TEST STATISTICS ===", "info");
          this.log(`Runtime: ${runtime} seconds`, "output");
          this.log(
            `Wallets Created: ${this.stressTestStats.walletsCreated}`,
            "output"
          );
          this.log(
            `Transactions Sent: ${this.stressTestStats.transactionsSent}`,
            "output"
          );
          this.log(
            `Successful: ${this.stressTestStats.successfulTxs}`,
            "success"
          );
          this.log(`Failed: ${this.stressTestStats.failedTxs}`, "error");
          this.log(`Success Rate: ${successRate}%`, "output");
          this.log(
            `Status: ${this.isStressTesting ? "RUNNING" : "STOPPED"}`,
            this.isStressTesting ? "success" : "warning"
          );
        }

        async showMiningStats() {
          await this.showStats();
        }

        async rickroll() {
          this.log("üéµ Never gonna give you up...", "info");
          this.log("üéµ Never gonna let you down...", "info");
          this.log("üéµ Never gonna run around and desert you...", "info");
          this.log("üéµ Never gonna make you cry...", "info");
          this.log("üéµ Never gonna say goodbye...", "info");
          this.log("üéµ Never gonna tell a lie and hurt you...", "info");

          // Create and show Rickroll popup
          const modal = document.createElement("div");
          modal.id = "rickrollModal";
          modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

          const videoContainer = document.createElement("div");
          videoContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 800px;
                    height: 60%;
                    max-height: 450px;
                `;

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "√ó";
          closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
          closeBtn.onclick = () => {
            document.body.removeChild(modal);
          };

          const iframe = document.createElement("iframe");
          iframe.src = "https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1";
          iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                    border-radius: 10px;
                `;
          iframe.allow = "autoplay; encrypted-media";

          videoContainer.appendChild(closeBtn);
          videoContainer.appendChild(iframe);
          modal.appendChild(videoContainer);
          document.body.appendChild(modal);

          // Auto-close after 30 seconds
          setTimeout(() => {
            if (document.body.contains(modal)) {
              document.body.removeChild(modal);
            }
          }, 30000);
        }

        fortune() {
          const fortunes = [
            "A beautiful, smart, and loving person will be coming into your life.",
            "A dubious friend may be an enemy in camouflage.",
            "A faithful friend is a strong defense.",
            "A fresh start will put you on your way.",
            "A golden egg of opportunity falls into your lap this month.",
            "A lifetime friend shall soon be made.",
            "A light heart carries you through all the hard times.",
            "A new perspective will come with the new year.",
            "A pleasant surprise is waiting for you.",
            "A short pencil is usually better than a long memory any day.",
          ];
          const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
          this.log(`üîÆ Fortune: ${fortune}`, "info");
        }

        async matrix() {
          this.log("üåê Entering the Matrix...", "info");
          for (let i = 0; i < 5; i++) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            this.log("01010101010101010101010101010101", "output");
          }
          this.log("üåê Matrix mode activated!", "success");
        }

        async hack() {
          this.log("üíª Hacker mode activated...", "info");
          this.log("üîì Bypassing security protocols...", "output");
          this.log("üîì Accessing mainframe...", "output");
          this.log("üîì Downloading classified data...", "output");
          this.log("‚úÖ Hack complete! You are now a l33t h4x0r!", "success");
        }

        async disco() {
          this.log("üï∫ Disco mode activated!", "info");
          this.log("üíÉ Stayin' alive, stayin' alive...", "output");
          this.log(
            "üéµ Ah, ha, ha, ha, stayin' alive, stayin' alive...",
            "output"
          );
          this.log("‚ú® Disco fever!", "success");
        }

        sudoMine() {
          this.log("üîê Sudo access granted!", "info");
          this.log("‚ö° Super user mining mode activated!", "success");
          this.log("üöÄ Mining with admin privileges...", "output");
          this.totalEarned += 0.1;
          this.log("üí∞ Admin bonus: +0.1 OMEGA", "success");
        }

        async fundMiningWallet(amount) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (!this.miningWallet) {
            this.log("No mining wallet found. Start mining first.", "error");
            return;
          }
          if (!amount || isNaN(amount) || Number(amount) <= 0) {
            this.log("Invalid amount. Usage: fund <amount>", "error");
            return;
          }
          try {
            this.log(
              `üí∞ Funding mining wallet with ${amount} OMEGA...`,
              "info"
            );
            const tx = await this.signer.sendTransaction({
              to: this.miningWallet.address,
              value: this.ethers.utils.parseEther(amount),
              gasLimit: 21000,
            });
            this.log(`üì§ Funding transaction sent: ${tx.hash}`, "info");
            this.log(
              "‚è≥ Waiting for confirmation... (this may take a few seconds)",
              "info"
            );
            await tx.wait();
            this.log(
              `‚úÖ Mining wallet funded with ${amount} OMEGA!`,
              "success"
            );
          } catch (error) {
            if (error.code === 4001) {
              this.log("‚ùå Transaction rejected by user.", "error");
            } else {
              this.log(
                "‚ùå Failed to fund mining wallet: " + error.message,
                "error"
              );
            }
          }
        }

        async fundStressWallet(amount) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (!this.stressWallet) {
            this.log(
              "No stress test wallet found. Start stress test first.",
              "error"
            );
            return;
          }
          if (!amount || isNaN(amount) || Number(amount) <= 0) {
            this.log("Invalid amount. Usage: fund <amount>", "error");
            return;
          }
          try {
            this.log(
              `üí∞ Funding stress test wallet with ${amount} OMEGA...`,
              "info"
            );
            const tx = await this.signer.sendTransaction({
              to: this.stressWallet.address,
              value: this.ethers.utils.parseEther(amount),
              gasLimit: 21000,
            });
            this.log(`üì§ Funding transaction sent: ${tx.hash}`, "info");
            this.log(
              "‚è≥ Waiting for confirmation... (this may take a few seconds)",
              "info"
            );
            await tx.wait();
            this.log(
              `‚úÖ Stress test wallet funded with ${amount} OMEGA!`,
              "success"
            );
          } catch (error) {
            if (error.code === 4001) {
              this.log("‚ùå Transaction rejected by user.", "error");
            } else {
              this.log(
                "‚ùå Failed to fund stress test wallet: " + error.message,
                "error"
              );
            }
          }
        }

        async setTheme(theme) {
          const validThemes = [
            "dark",
            "light",
            "matrix",
            "retro",
            "powershell",
          ];
          if (!validThemes.includes(theme)) {
            this.log(
              "Invalid theme. Available: dark, light, matrix, retro, powershell",
              "error"
            );
            return;
          }
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro",
            "theme-powershell"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro",
              "theme-powershell"
            );
            terminal.classList.add("theme-" + theme);
          }
          localStorage.setItem("omega-terminal-theme", theme);
          this.log(`Theme set to ${theme} mode`, "success");
        }

        toggleAIMode() {
          const aiToggle = document.querySelector(".ai-toggle");
          if (aiToggle.textContent.includes("(off)")) {
            aiToggle.textContent = "AI Mode (on)";
            this.log("ü§ñ AI Mode: Coming in v2!", "info");
            this.log(
              "üí° Enhanced assistance, smart suggestions, and contextual help will be available soon.",
              "info"
            );
          } else {
            aiToggle.textContent = "AI Mode (off)";
            this.log("ü§ñ AI Mode: Disabled", "info");
          }
        }

        toggleTheme() {
          this.isDarkTheme = !this.isDarkTheme;
          this.applyTheme();
          localStorage.setItem(
            "omega-miner-theme",
            this.isDarkTheme ? "dark" : "light"
          );
        }

        applyTheme() {
          const theme = localStorage.getItem("omega-terminal-theme") || "dark";
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro",
            "theme-powershell"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro",
              "theme-powershell"
            );
            terminal.classList.add("theme-" + theme);
          }
          const themeToggle = document.querySelector(".theme-toggle");
          if (themeToggle) {
            if (theme === "dark") themeToggle.textContent = "‚òÄÔ∏è Light";
            else if (theme === "light") themeToggle.textContent = "üåô Dark";
            else if (theme === "matrix") themeToggle.textContent = "üü© Matrix";
            else if (theme === "retro") themeToggle.textContent = "üü® Retro";
            else if (theme === "powershell")
              themeToggle.textContent = "üíª PowerShell";
          }
        }

        async sendOmega(command) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          // Parse command: send <address_or_ens> <amount>
          const parts = command.trim().split(/\s+/);
          if (parts.length !== 3) {
            this.log("Usage: send <address_or_ens> <amount>", "warning");
            return;
          }
          let address = parts[1];
          const amountStr = parts[2];

          // First, try to resolve as ENS name if it's not a valid address
          if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            this.log(`üîç Resolving ENS name: ${address}...`, "info");
            try {
              const ens = this.getENSContract();
              const resolvedAddress = await ens.resolve(address);
              if (
                resolvedAddress &&
                resolvedAddress !== "0x0000000000000000000000000000000000000000"
              ) {
                this.log(
                  `‚úÖ Resolved ${address} to ${resolvedAddress}`,
                  "success"
                );
                address = resolvedAddress;
              } else {
                this.log(`‚ùå ENS name not found: ${address}`, "error");
                return;
              }
            } catch (err) {
              this.log(
                `‚ùå Failed to resolve ENS name: ${err.message}`,
                "error"
              );
              return;
            }
          }

          // Now validate the resolved address
          if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            this.log("Invalid address format.", "error");
            return;
          }

          let amount;
          try {
            amount = this.ethers.utils.parseEther(amountStr);
          } catch (e) {
            this.log("Invalid amount.", "error");
            return;
          }

          this.log(`üöÄ Sending ${amountStr} OMEGA to ${address}...`, "info");
          try {
            const tx = await this.signer.sendTransaction({
              to: address,
              value: amount,
            });
            this.log("‚è≥ Waiting for confirmation...", "info");
            await tx.wait();
            this.log(`‚úÖ Sent ${amountStr} OMEGA to ${address}!`, "success");
          } catch (error) {
            this.log("‚ùå Send failed: " + error.message, "error");
          }
        }

        async claim() {
          if (!this.signer) {
            this.log(
              'Please connect wallet first using "connect" command',
              "error"
            );
            return;
          }
          try {
            const address = await this.signer.getAddress();
            this.log("üí∏ Sending claim request to network...", "info");
            const res = await fetch(RELAYER_URL + "/claim", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ address }),
            });
            const data = await res.json();
            if (data.success) {
              this.log(
                `‚úÖ Claimed ${data.amount} OMEGA to your wallet!`,
                "success"
              );
              if (data.txHash) {
                this.logHtml(
                  `üì§ Claim tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`,
                  "info"
                );
              }
            } else {
              this.log(
                "‚ùå Claim failed: " + (data.error || "Unknown error"),
                "error"
              );
            }
          } catch (error) {
            this.log("‚ùå Claim error: " + error.message, "error");
          }
        }

        // 1. Add ENS contract setup at the top of the class (after constructor or as a helper):
        getENSContract(signerOrProvider) {
          const abi = [
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
                {
                  indexed: true,
                  internalType: "address",
                  name: "owner",
                  type: "address",
                },
              ],
              name: "NameRegistered",
              type: "event",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
              ],
              name: "register",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
                { internalType: "address", name: "newOwner", type: "address" },
              ],
              name: "transfer",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "names",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
              ],
              name: "resolve",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          ];
          return new this.ethers.Contract(
            "0xd9ce49734db4f033362d2fd51d52f24cabeb87fa",
            abi,
            signerOrProvider || this.signer || this.provider
          );
        }

        // Chat functionality
        async sendDirectMessage(recipient, message) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          // Resolve ENS if needed
          let toAddress = recipient;
          if (!/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
            try {
              const ens = this.getENSContract();
              const resolved = await ens.resolve(recipient);
              if (
                resolved &&
                resolved !== "0x0000000000000000000000000000000000000000"
              ) {
                toAddress = resolved;
              } else {
                this.log("‚ùå ENS name not found: " + recipient, "error");
                return;
              }
            } catch (err) {
              this.log("‚ùå Failed to resolve ENS: " + err.message, "error");
              return;
            }
          }
          // Send DM on-chain
          try {
            const dmABI = [
              {
                inputs: [
                  { internalType: "address", name: "to", type: "address" },
                  { internalType: "string", name: "ensName", type: "string" },
                  { internalType: "string", name: "message", type: "string" },
                ],
                name: "sendMessage",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "from",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "message",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                ],
                name: "DirectMessage",
                type: "event",
              },
            ];
            const dmContract = new this.ethers.Contract(
              "0x26e31516e5e7790f8aaa35278735970a93fee213",
              dmABI,
              this.signer
            );
            let tx;
            if (/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
              // It's an address
              tx = await dmContract.sendMessage(recipient, "", message);
            } else {
              // It's an ENS name
              tx = await dmContract.sendMessage(
                "0x0000000000000000000000000000000000000000",
                recipient,
                message
              );
            }
            this.log(
              "‚è≥ Sending Email on-chain... (tx: " + tx.hash + ")",
              "info"
            );
            await tx.wait();
            this.log("‚úÖ Email sent!", "success");
          } catch (err) {
            this.log("‚ùå Failed to send DM: " + err.message, "error");
          }
        }

        async showInbox(showAll = false) {
          try {
            // Check if wallet is connected
            if (!this.signer) {
              this.log(
                "‚ùå Please connect your wallet first using: connect",
                "error"
              );
              return;
            }

            const dmABI = [
              {
                inputs: [
                  { internalType: "address", name: "to", type: "address" },
                  { internalType: "string", name: "ensName", type: "string" },
                  { internalType: "string", name: "message", type: "string" },
                ],
                name: "sendMessage",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "from",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "message",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                ],
                name: "DirectMessage",
                type: "event",
              },
            ];
            const dmContract = new this.ethers.Contract(
              "0x26e31516e5e7790f8aaa35278735970a93fee213",
              dmABI,
              this.provider
            );
            const myAddr = await this.signer.getAddress();
            const filter = dmContract.filters.DirectMessage(null, myAddr);

            // Fetch more historical messages - last 100k blocks (about 1-2 weeks)
            this.log(
              "Fetching inbox events from last 100,000 blocks...",
              "info"
            );
            const events = await dmContract.queryFilter(filter, -100000);

            if (!events.length) {
              this.log("No direct messages found.", "info");
              return;
            }

            this.log("=== Inbox ===", "info");
            this.log(`Found ${events.length} messages total`, "info");

            // Sort events by timestamp (newest first)
            const sortedEvents = events.sort(
              (a, b) => Number(b.args.timestamp) - Number(a.args.timestamp)
            );

            // Show messages based on parameter
            const messagesToShow = showAll
              ? sortedEvents
              : sortedEvents.slice(0, 25);

            for (let i = 0; i < messagesToShow.length; i++) {
              const ev = messagesToShow[i];
              let from = ev.args.from;
              let ensName = "";
              try {
                ensName = await this.provider.lookupAddress(from);
              } catch {}
              let fromDisplay = ensName ? `(${ensName}) | ${from}` : from;

              // Format date more nicely
              const date = new Date(Number(ev.args.timestamp) * 1000);
              const timeAgo = this.getTimeAgo(date);
              const formattedDate = date.toLocaleString();

              this.log("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "output");
              this.logHtml(
                `<span id="${ev.transactionHash}"><span style="color:#fff">üìß</span> <span style="color:#99ccff">From:</span> <span style="color:#fff">${fromDisplay}</span><br><span style="color:#99ccff">Time:</span> <span style="color:#fff">${formattedDate} (${timeAgo})</span><br><span style="color:#99ccff">Message:</span> <span style="color:#fff">${ev.args.message}</span><br><span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="document.getElementById('${ev.transactionHash}').style.display='none'">Delete</span> | <span style="color:#00ccff;cursor:pointer;text-decoration:underline;" onclick="window.terminal.prefillOeMailRecipient('${from}')">Reply</span></span>`,
                "output"
              );
            }

            if (!showAll && events.length > 25) {
              this.log(
                `Showing 25 of ${events.length} messages. Use 'inbox all' to see all messages.`,
                "info"
              );
            } else if (showAll) {
              this.log(`Showing all ${events.length} messages.`, "info");
            }

            console.log("DM events:", events);
          } catch (err) {
            this.log("‚ùå Failed to fetch inbox: " + err.message, "error");
          }
        }

        prefillOeMailRecipient(address) {
          const input = document.getElementById("commandInput");
          if (input) {
            window.terminal.tempDMRecipient = address;
            window.terminal.awaitingDMRecipient = false;
            window.terminal.awaitingDMMessage = true;
            window.terminal.logHtml(
              '<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' +
                address +
                "</span>",
              "info"
            );
            window.terminal.log("Enter your message:", "info");
            input.value = "";
            input.focus();
          }
        }

        getTimeAgo(date) {
          const now = new Date();
          const diffInSeconds = Math.floor((now - date) / 1000);

          if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
          if (diffInSeconds < 3600)
            return `${Math.floor(diffInSeconds / 60)}m ago`;
          if (diffInSeconds < 86400)
            return `${Math.floor(diffInSeconds / 3600)}h ago`;
          if (diffInSeconds < 2592000)
            return `${Math.floor(diffInSeconds / 86400)}d ago`;
          if (diffInSeconds < 31536000)
            return `${Math.floor(diffInSeconds / 2592000)}mo ago`;
          return `${Math.floor(diffInSeconds / 31536000)}y ago`;
        }

        async showFaucetStatus() {
          // VERSION CHECK - If you see this message, the updated code is loaded
          this.log(
            "üîÑ UPDATED CODE VERSION: Using direct RPC provider for faucet status",
            "info"
          );

          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          try {
            const address = await this.signer.getAddress();

            // Use direct RPC provider to avoid MetaMask issues
            const OMEGA_RPC_URL = "https://0x4e454228.rpc.aurora-cloud.dev";
            const directProvider = new this.ethers.providers.JsonRpcProvider(
              OMEGA_RPC_URL
            );
            const faucetContract = new this.ethers.Contract(
              this.faucetAddress,
              this.faucetABI,
              directProvider
            );

            // Get faucet status using direct RPC
            const info = await faucetContract.getFaucetStatus(address);

            const canClaim = info.canClaimNow;
            const lastClaim = info.lastClaim;
            const timeUntil = info.timeUntilNextClaim;
            const claimAmount = info.claimAmount;
            const faucetBalance = info.faucetBalance;

            this.log("=== Faucet Status ===", "info");
            this.log(
              `Can claim now: ${canClaim ? "‚úÖ Yes" : "‚ùå No"}`,
              canClaim ? "success" : "error"
            );
            if (!canClaim) {
              const mins = Math.floor(timeUntil / 60);
              const secs = timeUntil % 60;
              this.log(`Time until next claim: ${mins}m ${secs}s`, "warning");
            }
            this.log(
              `Faucet balance: ${this.ethers.utils.formatEther(
                faucetBalance
              )} OMEGA`,
              "info"
            );
            this.log(
              `Claim amount: ${this.ethers.utils.formatEther(
                claimAmount
              )} OMEGA`,
              "info"
            );
          } catch (error) {
            this.log(
              "‚ùå Failed to fetch faucet status: " + error.message,
              "error"
            );
          }
        }

        // Add this helper method to the class
        async isRealMetaMask() {
          this.log("DEBUG: isRealMetaMask() called", "info");
          console.log("[DEBUG] isRealMetaMask() called");
          if (
            typeof window.ethereum !== "undefined" &&
            window.ethereum.isMetaMask
          ) {
            try {
              await window.ethereum.request({ method: "eth_accounts" });
              this.log("DEBUG: isRealMetaMask() returns true", "info");
              console.log("[DEBUG] isRealMetaMask() returns true");
              return true;
            } catch (e) {
              this.log(
                "DEBUG: eth_accounts call failed, MetaMask not real",
                "info"
              );
              console.log(
                "[DEBUG] eth_accounts call failed, MetaMask not real"
              );
              return false;
            }
          }
          this.log("DEBUG: isRealMetaMask() returns false", "info");
          console.log("[DEBUG] isRealMetaMask() returns false");
          return false;
        }

        // Add this method to the OmegaMinerTerminal class
        promptTerminalInput() {
          this.awaitingPromptInput = true;
          return new Promise((resolve) => {
            this.promptResolver = resolve;
            const input = document.getElementById("commandInput");
            input.focus();
          });
        }

        // Add a helper to confirm transactions for Omega Test Wallet
        async confirmOmegaTransaction() {
          if (this.sessionOmegaWallet) {
            this.log("Approve transaction? (yes / no)", "warning");
            while (true) {
              const input = await this.promptTerminalInput();
              if (input.toLowerCase() === "yes") return true;
              if (input.toLowerCase() === "no") {
                this.log("Transaction cancelled.", "error");
                return false;
              }
              this.log('Please type either "yes" or "no".', "warning");
            }
          }
          return true;
        }

        async handleDexScreenerAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">Dexscreener API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds trending</span> - Show trending tokens',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds search [query]</span> - Search for tokens',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pair [chainId] [pairId]</span> - Get pair info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools</span> - List all pools',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools [chainId] [tokenAddress]</span> - Get pools for a token',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds trending</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds search OMEGA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pair 1 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools 1 0x123...</span>',
              "output"
            );
            return;
          }
          // Map ds commands to relayer endpoints
          if (args[1] === "trending") {
            await this.handleDexScreenerCommand(["dexscreener", "trending"]);
          } else if (args[1] === "search" && args[2]) {
            await this.handleDexScreenerCommand([
              "dexscreener",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "pair" && args[2] && args[3]) {
            // /dex/pair/:chainId/:pairId
            const chainId = args[2];
            const pairId = args[3];
            this.log(
              `Fetching DexScreener pair info for chain ${chainId}, pair ${pairId}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/pair/${chainId}/${pairId}`
              );
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pair fetch failed: " + e.message, "error");
            }
          } else if (args[1] === "pools" && !args[2]) {
            // /dex/pools
            this.log("Fetching all DexScreener pools...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/dex/pools`);
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pools fetch failed: " + e.message, "error");
            }
          } else if (args[1] === "pools" && args[2] && args[3]) {
            // /dex/pools/:chainId/:tokenAddress
            const chainId = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching DexScreener pools for chain ${chainId}, token ${tokenAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/pools/${chainId}/${tokenAddress}`
              );
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pools fetch failed: " + e.message, "error");
            }
          } else {
            this.log("Type ds help for available commands.", "info");
          }
        }

        async handleGeckoTerminalAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">GeckoTerminal API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg search [query]</span> - Search for pairs',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg networks</span> - List networks',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg dexes [network]</span> - List dexes for a network',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg pools [network]</span> - List pools for a network',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg token [network] [address]</span> - Get token info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg tokenpools [network] [token_address]</span> - Get pools for a token',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg poolinfo [network] [pool_address]</span> - Get pool info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg ohlcv [network] [pool_address] [timeframe]</span> - Get OHLCV data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg trades [network] [pool_address]</span> - Get trades for a pool',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg search OMEGA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg networks</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg dexes ethereum</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg pools ethereum</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg token ethereum 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg tokenpools ethereum 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg poolinfo ethereum 0xabc...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg ohlcv ethereum 0xabc... 1d</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg trades ethereum 0xabc...</span>',
              "output"
            );
            return;
          }
          // Map cg commands to relayer endpoints
          if (args[1] === "search" && args[2]) {
            await this.handleGeckoTerminalCommand([
              "geckoterminal",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "networks") {
            this.log("Fetching GeckoTerminal networks...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/gecko/networks`);
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml("<b>Available Networks:</b>", "output");
                data.data.forEach((item) => {
                  const net = item.attributes;
                  const id = item.id;
                  const cg = net.coingecko_asset_platform_id
                    ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>`
                    : "";
                  this.logHtml(
                    `<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No networks found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log(
                "GeckoTerminal networks fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "dexes" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal dexes for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/dexes`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>DEXes for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const dex = item.attributes;
                  const id = item.id;
                  this.logHtml(
                    `<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No DEXes found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal dexes fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "pools" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal pools for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>Pools for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal pools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "token" && args[2] && args[3]) {
            const network = args[2];
            const address = args[3];
            this.log(
              `Fetching GeckoTerminal token info for network: ${network}, address: ${address}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const token = data.data.attributes;
                this.logHtml(
                  `<b>${token.name} (${token.symbol})</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${token.price_usd || "N/A"}</b> | TVL: <b>${
                    token.tvl_usd || "N/A"
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `DEX Count: <b>${
                    token.dex_count || "N/A"
                  }</b> | Pool Count: <b>${token.pool_count || "N/A"}</b>`,
                  "output"
                );
                if (token.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No token info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal token fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "tokenpools" && args[2] && args[3]) {
            const network = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Pools for token ${tokenAddress} on ${network}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found for this token.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal tokenpools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "poolinfo" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const pool = data.data.attributes;
                this.logHtml(
                  `<b>${pool.name}</b> | DEX: <b>${
                    pool.dex_name
                  }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                  "output"
                );
                this.logHtml(
                  `Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${pool.price_usd || "N/A"}</b> | Volume 24h: <b>${
                    pool.volume_usd_24h || "N/A"
                  }</b>`,
                  "output"
                );
                if (pool.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pool info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal poolinfo fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "ohlcv" && args[2] && args[3] && args[4]) {
            const network = args[2];
            const poolAddress = args[3];
            const timeframe = args[4];
            this.log(
              `Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  this.logHtml(
                    `<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No OHLCV data found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal ohlcv fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "trades" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Recent trades for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.slice(0, 10).forEach((item) => {
                  const trade = item.attributes;
                  this.logHtml(
                    `<b>${trade.timestamp}</b>: <b>${
                      trade.amount_usd || "N/A"
                    } USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${
                      trade.price_usd || "N/A"
                    }</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trades found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal trades fetch failed: " + e.message,
                "error"
              );
            }
          } else {
            this.log("Type cg help for available commands.", "info");
          }
        }

        async handleAlphaAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">Alpha Vantage API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha quote [symbol]</span> - Get stock quote',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha search [query]</span> - Search for stocks',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha daily [symbol]</span> - Get daily stock data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha overview [symbol]</span> - Get stock overview',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha inflation</span> - Get US inflation data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha cpi</span> - Get US CPI data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha gdp</span> - Get US GDP data',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha quote IBM</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha search Microsoft</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha daily TSLA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha overview AAPL</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha inflation</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha cpi</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha gdp</span>',
              "output"
            );
            return;
          }
          // Map alpha commands to relayer endpoints
          if (args[1] === "quote" && args[2]) {
            await this.handleStockCommand(["stock", "quote", args[2]]);
          } else if (args[1] === "search" && args[2]) {
            await this.handleStockCommand([
              "stock",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "daily" && args[2]) {
            await this.handleStockCommand(["stock", "daily", args[2]]);
          } else if (args[1] === "overview" && args[2]) {
            await this.handleStockCommand(["stock", "overview", args[2]]);
          } else if (args[1] === "inflation") {
            await this.handleStockCommand(["stock", "inflation"]);
          } else if (args[1] === "cpi") {
            await this.handleStockCommand(["stock", "cpi"]);
          } else if (args[1] === "gdp") {
            await this.handleStockCommand(["stock", "gdp"]);
          } else {
            this.log("Type alpha help for available commands.", "info");
          }
        }

        async handleCreateCommand(args) {
          if (!this.provider || !this.signer) {
            this.log(
              'Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          // OmegaTokenFactory contract details
          const FACTORY_ADDRESS = "0x1f568dbb3a7b9ea05062b132094a848ef1443cfe";
          const FACTORY_ABI = [
            {
              inputs: [
                { internalType: "string", name: "name_", type: "string" },
                { internalType: "string", name: "symbol_", type: "string" },
                { internalType: "uint8", name: "decimals_", type: "uint8" },
                {
                  internalType: "uint256",
                  name: "initialSupply_",
                  type: "uint256",
                },
                { internalType: "bool", name: "mintable_", type: "bool" },
                { internalType: "bool", name: "pausable_", type: "bool" },
              ],
              name: "createToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "address",
                  name: "creator",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "address",
                  name: "token",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
                {
                  indexed: false,
                  internalType: "string",
                  name: "symbol",
                  type: "string",
                },
              ],
              name: "TokenCreated",
              type: "event",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allTokens",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "getAllTokens",
              outputs: [
                { internalType: "address[]", name: "", type: "address[]" },
              ],
              stateMutability: "view",
              type: "function",
            },
          ];

          try {
            this.log("üöÄ Omega Token Creator", "info");
            this.log(
              "This will deploy a new ERC20 token on the Omega Network",
              "info"
            );
            this.log("", "info");

            // Get token name
            this.log('Enter token name (e.g., "My Awesome Token"):', "info");
            let name = await this.promptTerminalInput(
              'Enter token name (e.g., "My Awesome Token"):'
            );
            name = name ? name.trim() : "";
            if (!name) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            // Get token symbol
            this.log('Enter token symbol (e.g., "MAT"):', "info");
            let symbol = await this.promptTerminalInput(
              'Enter token symbol (e.g., "MAT"):'
            );
            symbol = symbol ? symbol.trim() : "";
            if (!symbol) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            // Get decimals
            this.log("Enter decimals (default 18):", "info");
            let decimalsInput = await this.promptTerminalInput(
              "Enter decimals (default 18):"
            );
            decimalsInput = decimalsInput ? decimalsInput.trim() : "";
            let decimals = 18;
            if (decimalsInput) {
              const parsed = parseInt(decimalsInput);
              if (!isNaN(parsed) && parsed >= 0 && parsed <= 36)
                decimals = parsed;
            }
            document.getElementById("commandInput").value = "";

            // Get initial supply
            this.log("Enter initial supply (e.g., 1000000):", "info");
            let supplyInput = await this.promptTerminalInput(
              "Enter initial supply (e.g., 1000000):"
            );
            supplyInput = supplyInput ? supplyInput.trim() : "";
            if (!supplyInput) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";
            const initialSupply = this.ethers.BigNumber.from(supplyInput);
            if (initialSupply.lte(0)) {
              this.log(
                "Invalid supply amount. Please enter a positive number.",
                "error"
              );
              return;
            }

            // Get mintable
            this.log("Mintable? (yes/no, default yes):", "info");
            let mintableInput = await this.promptTerminalInput(
              "Mintable? (yes/no, default yes):"
            );
            mintableInput = mintableInput
              ? mintableInput.trim().toLowerCase()
              : "";
            let mintable = true;
            if (mintableInput === "no" || mintableInput === "false")
              mintable = false;
            document.getElementById("commandInput").value = "";

            // Get pausable
            this.log("Pausable? (yes/no, default yes):", "info");
            let pausableInput = await this.promptTerminalInput(
              "Pausable? (yes/no, default yes):"
            );
            pausableInput = pausableInput
              ? pausableInput.trim().toLowerCase()
              : "";
            let pausable = true;
            if (pausableInput === "no" || pausableInput === "false")
              pausable = false;
            document.getElementById("commandInput").value = "";

            this.log("", "info");
            this.log("üìã Token Details:", "info");
            this.log(`Name: ${name}`, "output");
            this.log(`Symbol: ${symbol}`, "output");
            this.log(`Decimals: ${decimals}`, "output");
            this.log(
              `Initial Supply: ${initialSupply.toLocaleString()}`,
              "output"
            );
            this.log(`Mintable: ${mintable ? "Yes" : "No"}`, "output");
            this.log(`Pausable: ${pausable ? "Yes" : "No"}`, "output");
            this.log("", "info");

            this.log("Deploy token? (yes/no):", "info");
            let confirm = await this.promptTerminalInput(
              "Deploy token? (yes/no):"
            );
            confirm = confirm ? confirm.trim().toLowerCase() : "";
            if (confirm !== "yes") {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            this.log("‚è≥ Deploying token...", "info");

            // Create contract instance
            const factory = new this.ethers.Contract(
              FACTORY_ADDRESS,
              FACTORY_ABI,
              this.signer
            );

            try {
              // Deploy token
              const tx = await factory.createToken(
                name,
                symbol,
                decimals,
                initialSupply,
                mintable,
                pausable
              );
              this.log(`Transaction sent: ${tx.hash}`, "info");

              // Wait for confirmation
              const receipt = await tx.wait();
              this.log("‚úÖ Token deployed successfully!", "success");
              this.log("", "info");

              // Extract token address from events
              let tokenAddress = null;
              for (const log of receipt.logs) {
                try {
                  const parsedLog = factory.interface.parseLog(log);
                  if (parsedLog.name === "TokenCreated") {
                    tokenAddress = parsedLog.args.token;
                    break;
                  }
                } catch (e) {
                  // Continue searching
                }
              }

              if (tokenAddress) {
                this.logHtml(
                  '<span class="success">üéâ <b>Token Deployed!</b></span>',
                  "success"
                );
                this.logHtml(
                  `Token Address: <span class="copyable" onclick="navigator.clipboard.writeText('${tokenAddress}')" style="color:#33bbff;cursor:pointer;">${tokenAddress}</span>`,
                  "output"
                );
                this.logHtml(
                  `Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`,
                  "output"
                );
                this.logHtml(
                  `<b>Name:</b> ${name}<br><b>Symbol:</b> ${symbol}<br><b>Decimals:</b> ${decimals}<br><b>Initial Supply:</b> ${initialSupply.toString()}<br><b>Mintable:</b> ${
                    mintable ? "Yes" : "No"
                  }<br><b>Pausable:</b> ${pausable ? "Yes" : "No"}`,
                  "output"
                );
                this.logHtml(
                  '<span style="color:#99ccff">üí° You can now add liquidity or trade your token!</span>',
                  "info"
                );
              } else {
                this.logHtml(
                  '<span class="warning">‚ö†Ô∏è Token deployed but address not found in events</span>',
                  "warning"
                );
                this.logHtml(
                  `Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`,
                  "output"
                );
              }
            } catch (error) {
              this.log(`‚ùå Token creation failed: ${error.message}`, "error");
              if (error.code === "ACTION_REJECTED") {
                this.log("Transaction was rejected by user.", "warning");
              } else if (error.code === "INSUFFICIENT_FUNDS") {
                this.log("Insufficient funds for gas fees.", "error");
              } else if (error.code === "UNPREDICTABLE_GAS_LIMIT") {
                this.log(
                  "Tip: Check that the contract address, ABI, and network are correct. Make sure MetaMask is on the right network and the contract is deployed.",
                  "warning"
                );
              }
            }
          } catch (error) {
            this.log(`‚ùå Token creation failed: ${error.message}`, "error");
            if (error.code === "ACTION_REJECTED") {
              this.log("Transaction was rejected by user.", "warning");
            } else if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("Insufficient funds for gas fees.", "error");
            }
          }
        }

        // üèÜ AMBASSADOR COMMAND HANDLER
        async handleAmbassadorCommand(args) {
          if (!args || args.length < 2) {
            this.log("üèÜ OMEGA NETWORK AMBASSADOR COMMANDS", "info");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
            this.log("", "info");
            this.log("üìã BASIC COMMANDS:", "info");
            this.log(
              "  ambassador profile [address]     View ambassador profile",
              "output"
            );
            this.log(
              "  ambassador stats [address]       View ambassador statistics",
              "output"
            );
            this.log(
              "  ambassador leaderboard [limit]   View top ambassadors",
              "output"
            );
            this.log(
              "  ambassador directory             View all public ambassadors",
              "output"
            );
            this.log(
              "  ambassador referrals [address]   View ambassador referrals",
              "output"
            );
            this.log(
              "  ambassador generate              Generate referral code",
              "output"
            );
            this.log("", "info");
            this.log("üéØ EXAMPLES:", "info");
            this.log(
              "  ambassador profile 0x1234...     # Specific ambassador",
              "info"
            );
            this.log(
              "  ambassador stats                 # Your stats (if connected)",
              "info"
            );
            this.log(
              "  ambassador leaderboard 20        # Top 20 ambassadors",
              "info"
            );
            this.log(
              "  ambassador generate              # Create referral code",
              "info"
            );
            this.log("", "info");
            this.log(
              "üí° Tip: Connect your wallet first for personalized commands!",
              "success"
            );
            return;
          }

          const subCommand = args[1].toLowerCase();

          try {
            switch (subCommand) {
              case "profile":
                await this.getAmbassadorProfile(args[2]);
                break;
              case "stats":
                await this.getAmbassadorStats(args[2]);
                break;
              case "leaderboard":
                await this.getAmbassadorLeaderboard(args[2]);
                break;
              case "directory":
                await this.getAmbassadorDirectory();
                break;
              case "referrals":
                await this.getAmbassadorReferrals(args[2]);
                break;
              case "generate":
                await this.generateAmbassadorCode();
                break;
              case "help":
                await this.handleAmbassadorCommand([]);
                break;
              default:
                this.log(
                  `‚ùå Unknown ambassador command: ${subCommand}`,
                  "error"
                );
                this.log(
                  'Type "ambassador help" for available commands',
                  "info"
                );
            }
          } catch (error) {
            console.error("Ambassador command error:", error);
            this.log(`‚ùå Ambassador command failed: ${error.message}`, "error");
          }
        }

        // üë§ PROFILE COMMAND HANDLER - Enhanced Profile System
        async handleProfileCommand(args) {
          // Use the enhanced profile system
          if (window.handleEnhancedProfileCommand) {
            window.handleEnhancedProfileCommand(args.slice(1));
          } else if (window.openEnhancedProfile) {
            // Direct fallback to open profile
            window.openEnhancedProfile();
          } else {
            this.log("üë§ Enhanced Profile System", "info");
            this.log("üîó Omega ENS registration & management", "info");
            this.log("üìá Address book for contacts", "info");
            this.log("üí¨ Terminal Chatter (Telegram-like)", "info");
            this.log("üêç Python script management", "info");
            this.log("üñ•Ô∏è Fullscreen profile mode", "info");
            this.log("üí° Commands: profile open | profile help", "info");
          }
        }

        // üîë API KEY MANAGEMENT
        async handleProfileApiKeys(args) {
          if (!args || args.length === 0) {
            this.showApiKeysHelp();
            return;
          }

          const subcommand = args[0];

          switch (subcommand) {
            case "list":
              await this.listApiKeys();
              break;
            case "set":
              await this.setApiKey(args[1], args.slice(2).join(" "));
              break;
            case "remove":
            case "delete":
              await this.removeApiKey(args[1]);
              break;
            case "show":
              await this.showApiKey(args[1]);
              break;
            case "help":
              this.showApiKeysHelp();
              break;
            default:
              this.log(`‚ùå Unknown API keys command: ${subcommand}`, "error");
              this.showApiKeysHelp();
          }
        }

        showApiKeysHelp() {
          this.log("üîë API KEY MANAGEMENT", "info");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
          this.log("", "info");
          this.log("üìã AVAILABLE COMMANDS:", "info");
          this.log(
            "  profile apikeys list             List all stored API keys",
            "output"
          );
          this.log(
            "  profile apikeys set <service>    Set an API key for a service",
            "output"
          );
          this.log(
            "  profile apikeys show <service>   Show an API key (masked)",
            "output"
          );
          this.log(
            "  profile apikeys remove <service> Remove an API key",
            "output"
          );
          this.log(
            "  profile apikeys help             Show this help message",
            "output"
          );
          this.log("", "info");
          this.log("üéØ SUPPORTED SERVICES:", "info");
          this.log("  ‚Ä¢ kalshi     - Kalshi prediction markets", "output");
          this.log("  ‚Ä¢ alpha      - Alpha Vantage stock data", "output");
          this.log("  ‚Ä¢ opensea    - OpenSea NFT marketplace", "output");
          this.log("  ‚Ä¢ magiceden  - Magic Eden NFT marketplace", "output");
          this.log("  ‚Ä¢ coingecko  - CoinGecko crypto data", "output");
          this.log("", "info");
          this.log("üéØ EXAMPLES:", "info");
          this.log("  profile apikeys list", "info");
          this.log("  profile apikeys set kalshi YOUR_KALSHI_API_KEY", "info");
          this.log(
            "  profile apikeys set alpha YOUR_ALPHA_VANTAGE_KEY",
            "info"
          );
          this.log("  profile apikeys show kalshi", "info");
          this.log("  profile apikeys remove kalshi", "info");
          this.log("", "info");
          this.log("üí° API keys are stored locally in your browser", "info");
        }

        getApiKeyStorageKey() {
          return "omega_terminal_api_keys";
        }

        getAllApiKeys() {
          const keysJson = localStorage.getItem(this.getApiKeyStorageKey());
          if (!keysJson) {
            return {};
          }
          try {
            return JSON.parse(keysJson);
          } catch (e) {
            console.error("Failed to parse API keys:", e);
            return {};
          }
        }

        saveAllApiKeys(keys) {
          try {
            localStorage.setItem(
              this.getApiKeyStorageKey(),
              JSON.stringify(keys)
            );
            return true;
          } catch (e) {
            console.error("Failed to save API keys:", e);
            return false;
          }
        }

        getApiKey(service) {
          const keys = this.getAllApiKeys();
          return keys[service.toLowerCase()] || null;
        }

        async listApiKeys() {
          const keys = this.getAllApiKeys();
          const serviceNames = Object.keys(keys);

          if (serviceNames.length === 0) {
            this.log("üì≠ No API keys stored", "warning");
            this.log("", "info");
            this.log(
              'üí° Use "profile apikeys set <service> <key>" to add an API key',
              "info"
            );
            return;
          }

          this.log("üîë STORED API KEYS", "success");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
          this.log("", "info");

          serviceNames.forEach((service, index) => {
            const key = keys[service];
            const maskedKey = this.maskApiKey(key);
            this.log(`${index + 1}. ${service.toUpperCase()}`, "output");
            this.log(`   Key: ${maskedKey}`, "info");
            this.log(`   Status: ‚úÖ Active`, "success");
            this.log("", "info");
          });

          this.log(
            'üí° Use "profile apikeys show <service>" to see full key',
            "info"
          );
        }

        async setApiKey(service, key) {
          if (!service) {
            this.log("‚ùå Please specify a service", "error");
            this.log("Usage: profile apikeys set <service> <key>", "info");
            this.log(
              "Example: profile apikeys set kalshi YOUR_API_KEY_HERE",
              "info"
            );
            return;
          }

          if (!key || key.trim() === "") {
            this.log("‚ùå Please provide an API key", "error");
            this.log("Usage: profile apikeys set <service> <key>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const keys = this.getAllApiKeys();
          keys[serviceLower] = key.trim();

          if (this.saveAllApiKeys(keys)) {
            this.log(
              `‚úÖ API key for ${service.toUpperCase()} saved successfully!`,
              "success"
            );
            this.log("", "info");
            this.log(
              `üéØ You can now use ${serviceLower} commands without setting the API key each time`,
              "info"
            );

            // Special handling for different services
            switch (serviceLower) {
              case "kalshi":
                this.log("üí° Try: kalshi markets", "info");
                break;
              case "alpha":
                this.log("üí° Try: alpha quote AAPL", "info");
                break;
              case "opensea":
                this.log(
                  "üí° Try: opensea collection <collection-slug>",
                  "info"
                );
                break;
            }
          } else {
            this.log("‚ùå Failed to save API key", "error");
          }
        }

        async removeApiKey(service) {
          if (!service) {
            this.log("‚ùå Please specify a service", "error");
            this.log("Usage: profile apikeys remove <service>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const keys = this.getAllApiKeys();

          if (!keys[serviceLower]) {
            this.log(
              `‚ùå No API key found for ${service.toUpperCase()}`,
              "error"
            );
            return;
          }

          delete keys[serviceLower];

          if (this.saveAllApiKeys(keys)) {
            this.log(
              `‚úÖ API key for ${service.toUpperCase()} removed successfully!`,
              "success"
            );
          } else {
            this.log("‚ùå Failed to remove API key", "error");
          }
        }

        async showApiKey(service) {
          if (!service) {
            this.log("‚ùå Please specify a service", "error");
            this.log("Usage: profile apikeys show <service>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const key = this.getApiKey(serviceLower);

          if (!key) {
            this.log(
              `‚ùå No API key found for ${service.toUpperCase()}`,
              "error"
            );
            this.log('üí° Use "profile apikeys set" to add one', "info");
            return;
          }

          this.log(`üîë API KEY: ${service.toUpperCase()}`, "info");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
          this.log("", "info");
          this.log(`üîê Full Key: ${key}`, "output");
          this.log("", "info");
          this.log(
            "‚ö†Ô∏è  Keep your API key secure and never share it publicly!",
            "warning"
          );
        }

        maskApiKey(key) {
          if (!key || key.length < 8) {
            return "****";
          }
          const start = key.substring(0, 4);
          const end = key.substring(key.length - 4);
          return `${start}${"*".repeat(Math.min(key.length - 8, 20))}${end}`;
        }

        async getAmbassadorProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "‚ùå Please provide a wallet address or connect your wallet",
                  "error"
                );
                this.log("Usage: ambassador profile 0x1234...", "info");
                return;
              }
            } else {
              this.log(
                "‚ùå Please provide a wallet address or connect your wallet",
                "error"
              );
              this.log("Usage: ambassador profile 0x1234...", "info");
              return;
            }
          }

          this.log(
            `üë§ Loading ambassador profile for: ${walletAddress}`,
            "info"
          );

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/${encodeURIComponent(
                walletAddress
              )}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            const profile = data.data;

            this.log("‚úÖ AMBASSADOR PROFILE", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log(`üë§ Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `üè∑Ô∏è  Display Name: ${profile.display_name || "Not set"}`,
              "info"
            );
            this.log(`üìç Location: ${profile.location || "Not set"}`, "info");
            this.log(`üê¶ Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`üí¨ Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`üåê Website: ${profile.website || "Not set"}`, "info");
            this.log(`üìä Level: ${profile.level || 1}`, "info");
            this.log(`üèÜ Points: ${profile.total_points || 0}`, "info");
            this.log(`üéØ Referrals: ${profile.referrals_count || 0}`, "info");
            this.log(`üèÖ Tier: ${profile.rank || "BRONZE"}`, "info");
          } catch (error) {
            this.log(
              `‚ùå Failed to load ambassador profile: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorStats(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "‚ùå Please provide a wallet address or connect your wallet",
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "‚ùå Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log(`üìä Loading ambassador stats for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            const profile = data.data.profile;
            const interactions = data.data.discoverInteractions || [];

            this.log("‚úÖ AMBASSADOR STATISTICS", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log(`üë§ Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `üè∑Ô∏è  Display Name: ${profile.displayName || "Not set"}`,
              "info"
            );
            this.log(`üê¶ Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`üí¨ Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`üìä Recent Activities: ${interactions.length}`, "info");
            this.log(
              `üîó Profile Public: ${profile.isPublic ? "Yes" : "No"}`,
              "info"
            );

            // Try to get referral data separately
            try {
              const refResponse = await fetch(
                `${OMEGA_API_URL}/v1/referrals/validate/${
                  profile.username || "unknown"
                }`
              );
              const refData = await refResponse.json();
              if (refData.success && refData.data.isValid) {
                this.log(`üéØ Referral Status: Active Ambassador`, "success");
              }
            } catch (refError) {
              this.log(`üéØ Referral Status: Unknown`, "warning");
            }
          } catch (error) {
            this.log(
              `‚ùå Failed to load ambassador stats: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorLeaderboard(limit) {
          const queryLimit = limit || 10;

          this.log(`üèÜ Loading top ${queryLimit} ambassadors...`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/leaderboard?limit=${queryLimit}`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            this.log("üèÜ AMBASSADOR LEADERBOARD", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log("", "info");

            data.data.forEach((ambassador, index) => {
              const emoji =
                ambassador.rank === 1
                  ? "ü•á"
                  : ambassador.rank === 2
                  ? "ü•à"
                  : ambassador.rank === 3
                  ? "ü•â"
                  : "üèÖ";

              this.log(
                `${emoji} #${ambassador.rank} ${ambassador.displayName}`,
                "info"
              );
              this.log(
                `   üë§ @${ambassador.username} | üéØ ${ambassador.totalReferrals} referrals | üèÜ ${ambassador.totalPoints} points`,
                "info"
              );
              this.log(
                `   üèÖ ${ambassador.tier} | üìà Level ${ambassador.level}`,
                "info"
              );
              this.log("", "info");
            });

            if (data.pagination) {
              this.log(
                `üìä Showing ${data.data.length} of ${data.pagination.total} ambassadors`,
                "info"
              );
            }
          } catch (error) {
            this.log(
              `‚ùå Failed to load ambassador leaderboard: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorDirectory() {
          this.log("üåê Loading ambassador directory...", "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/directory`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            this.log("üåê AMBASSADOR DIRECTORY", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log("", "info");

            data.data.forEach((ambassador, index) => {
              this.log(
                `üë§ ${ambassador.display_name || ambassador.username}`,
                "success"
              );
              if (ambassador.bio) {
                this.log(`   üìù ${ambassador.bio}`, "info");
              }
              this.log(
                `   üéØ ${ambassador.referral_count || 0} referrals | üèÜ ${
                  ambassador.total_points || 0
                } points`,
                "info"
              );
              if (ambassador.website) {
                this.logHtml(
                  `   üåê <a href="${ambassador.website}" target="_blank" style="color:#33bbff;">${ambassador.website}</a>`,
                  "info"
                );
              }
              this.log("", "info");
            });
          } catch (error) {
            this.log(
              `‚ùå Failed to load ambassador directory: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorReferrals(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "‚ùå Please provide a wallet address or connect your wallet",
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "‚ùå Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log(`üîó Loading referrals for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/${walletAddress}/referrals`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            this.log("üîó AMBASSADOR REFERRALS", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log("", "info");

            if (data.data.length === 0) {
              this.log(
                "üì≠ No referrals yet. Start sharing your ambassador link!",
                "info"
              );
              return;
            }

            data.data.forEach((referral, index) => {
              const status = referral.status === "COMPLETED" ? "‚úÖ" : "‚è≥";
              const date = new Date(referral.created_at).toLocaleDateString();

              this.log(`${status} ${referral.referral_code}`, "info");

              if (referral.referred_address) {
                this.log(
                  `   üë§ Referred: ${referral.referred_address.substring(
                    0,
                    10
                  )}...`,
                  "info"
                );
                this.log(
                  `   ‚úÖ Completed: ${new Date(
                    referral.completed_at
                  ).toLocaleDateString()}`,
                  "success"
                );
              } else {
                this.log("   ‚è≥ Pending - waiting for signup", "warning");
              }

              this.log(`   üìÖ Created: ${date}`, "info");
              this.log("", "info");
            });
          } catch (error) {
            this.log(
              `‚ùå Failed to load ambassador referrals: ${error.message}`,
              "error"
            );
          }
        }

        async generateAmbassadorCode() {
          if (!this.signer) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("üéØ Generating ambassador referral code...", "info");

          try {
            // First get user's profile to retrieve username
            this.log("üìù Checking your profile for username...", "info");
            let username = null;

            try {
              const profileResponse = await fetch(
                `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
              );
              const profileData = await profileResponse.json();

              if (profileData.success && profileData.data.profile.username) {
                username = profileData.data.profile.username;
                this.log(`‚úÖ Found username: ${username}`, "success");
              } else {
                this.log(
                  '‚ö†Ô∏è No username found in profile. Please set up your profile first using "profile register"',
                  "error"
                );
                this.log(
                  "   This is required for proper referral credit tracking.",
                  "error"
                );
                return;
              }
            } catch (profileError) {
              this.log(
                '‚ö†Ô∏è Could not retrieve your profile. Please set up your profile first using "profile register"',
                "error"
              );
              this.log(
                "   This is required for proper referral credit tracking.",
                "error"
              );
              return;
            }

            // Generate the referral code
            const response = await fetch(
              `${OMEGA_API_URL}/v1/referrals/generate-code`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ walletAddress: walletAddress }),
              }
            );

            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå ${data.error}`, "error");
              return;
            }

            const result = data.data;

            if (result.alreadyExists) {
              this.log("‚ÑπÔ∏è You already have an ambassador code!", "info");
            } else {
              this.log("‚úÖ Ambassador code generated successfully!", "success");
            }

            this.log("üéØ YOUR AMBASSADOR CODE", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log(`üîë Code: ${result.referralCode}`, "success");
            this.log(`üë§ Username: ${username}`, "success");
            this.logHtml(
              `üîó Link: <span class="copyable" onclick="navigator.clipboard.writeText('https://omeganetwork.co/${username}/${result.referralCode}').then(() => window.terminal.log('‚úÖ Ambassador link copied to clipboard!', 'success'))" style="color:#33bbff; cursor:pointer; text-decoration:underline;">https://omeganetwork.co/${username}/${result.referralCode}</span>`,
              "info"
            );
            this.log("", "info");
            this.log(
              "üí° Use: ambassador stats (to track your progress)",
              "info"
            );
          } catch (error) {
            this.log(
              `‚ùå Failed to generate ambassador code: ${error.message}`,
              "error"
            );
          }
        }

        // üë§ PROFILE MANAGEMENT FUNCTIONS
        async getUserProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '‚ùå Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                '‚ùå Please connect your wallet first using "connect"',
                "error"
              );
              return;
            }
          }

          this.log(`üë§ Loading profile for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(
                `‚ùå Profile not found. Use "profile register" to create one.`,
                "error"
              );
              return;
            }

            const profile = data.data.profile;

            this.log("üë§ USER PROFILE", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log(`üè∑Ô∏è  Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `üìù Display Name: ${profile.displayName || "Not set"}`,
              "info"
            );
            this.log(`üìç Location: ${profile.location || "Not set"}`, "info");
            this.log(`üí¨ Bio: ${profile.bio || "Not set"}`, "info");
            this.log(`üåê Website: ${profile.website || "Not set"}`, "info");
            this.log(`üê¶ Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`üí¨ Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`üêô GitHub: ${profile.github || "Not set"}`, "info");
            this.log(`üì± Telegram: ${profile.telegram || "Not set"}`, "info");
            this.log(`üìß Email: ${profile.email || "Not set"}`, "info");
            this.log(`üîì Public: ${profile.isPublic ? "Yes" : "No"}`, "info");
            this.log("", "info");
            this.log(
              "üí° Use: profile update (to modify your profile)",
              "success"
            );
          } catch (error) {
            this.log(`‚ùå Failed to load profile: ${error.message}`, "error");
          }
        }

        async registerUserProfile() {
          if (!this.signer) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("üë§ PROFILE REGISTRATION", "success");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
          this.log("", "info");
          this.log("üìù Let's set up your Omega Network profile!", "info");
          this.log("üí° You can skip any field by pressing Enter", "info");
          this.log("", "info");

          // Start guided registration
          this.profileRegistrationStep = 1;
          this.profileData = { walletAddress };
          this.awaitingInput = true;
          this.inputType = "profile_username";

          this.log("üè∑Ô∏è  Enter your username:", "info");
          this.log("    (3-20 characters, letters/numbers only)", "output");
        }

        async updateUserProfile() {
          if (!this.signer) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          // First check if profile exists
          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(
                '‚ùå No profile found. Use "profile register" to create one first.',
                "error"
              );
              return;
            }

            this.log("üë§ PROFILE UPDATE", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log("", "info");
            this.log("üìù Let's update your profile! Current values:", "info");

            const profile = data.data.profile;
            this.log(
              `üè∑Ô∏è  Username: ${profile.username || "Not set"}`,
              "output"
            );
            this.log(
              `üìù Display Name: ${profile.displayName || "Not set"}`,
              "output"
            );
            this.log(`üìç Location: ${profile.location || "Not set"}`, "output");
            this.log("", "info");
            this.log(
              "üí° Enter new values (or press Enter to keep current)",
              "info"
            );
            this.log("", "info");

            // Start guided update
            this.profileRegistrationStep = 1;
            this.profileData = { walletAddress, ...profile };
            this.awaitingInput = true;
            this.inputType = "profile_username";

            this.log("üè∑Ô∏è  Enter new username:", "info");
            this.log(`    Current: ${profile.username || "Not set"}`, "output");
          } catch (error) {
            this.log(
              `‚ùå Failed to load current profile: ${error.message}`,
              "error"
            );
          }
        }

        async getUserActivity(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '‚ùå Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                '‚ùå Please connect your wallet first using "connect"',
                "error"
              );
              return;
            }
          }

          this.log(`üìä Loading activity for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/activity?limit=10`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå No activity found for this address`, "error");
              return;
            }

            this.log("üìä USER ACTIVITY (Last 10)", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");

            const activities = data.data;
            if (activities.length === 0) {
              this.log("üì≠ No recent activity found", "info");
              return;
            }

            activities.forEach((activity, index) => {
              const date = new Date(activity.createdAt).toLocaleDateString();
              this.log(`${index + 1}. ${activity.action} - ${date}`, "output");
            });
          } catch (error) {
            this.log(`‚ùå Failed to load activity: ${error.message}`, "error");
          }
        }

        // Profile registration input handler
        async handleProfileRegistrationInput(input) {
          switch (this.inputType) {
            case "profile_username":
              if (
                input &&
                input.length >= 3 &&
                input.length <= 20 &&
                /^[a-zA-Z0-9_]+$/.test(input)
              ) {
                this.profileData.username = input;
                this.log(`‚úÖ Username: ${input}`, "success");
              } else if (input) {
                this.log(
                  "‚ùå Username must be 3-20 characters, letters/numbers/underscore only",
                  "error"
                );
                this.log("üè∑Ô∏è  Enter your username:", "info");
                return;
              }

              this.profileRegistrationStep = 2;
              this.inputType = "profile_display_name";
              this.log("", "info");
              this.log("üìù Enter your display name:", "info");
              this.log("    (The name others will see)", "output");
              break;

            case "profile_display_name":
              if (input && input.length <= 50) {
                this.profileData.displayName = input;
                this.log(`‚úÖ Display Name: ${input}`, "success");
              }

              this.profileRegistrationStep = 3;
              this.inputType = "profile_bio";
              this.log("", "info");
              this.log("üí¨ Enter your bio:", "info");
              this.log("    (Optional - tell others about yourself)", "output");
              break;

            case "profile_bio":
              if (input && input.length <= 200) {
                this.profileData.bio = input;
                this.log(`‚úÖ Bio: ${input}`, "success");
              }

              this.profileRegistrationStep = 4;
              this.inputType = "profile_location";
              this.log("", "info");
              this.log("üìç Enter your location:", "info");
              this.log("    (Optional - country, city, etc.)", "output");
              break;

            case "profile_location":
              if (input && input.length <= 100) {
                this.profileData.location = input;
                this.log(`‚úÖ Location: ${input}`, "success");
              }

              this.profileRegistrationStep = 5;
              this.inputType = "profile_twitter";
              this.log("", "info");
              this.log("üê¶ Enter your Twitter handle:", "info");
              this.log("    (Optional - without @)", "output");
              break;

            case "profile_twitter":
              if (input && input.length <= 50) {
                this.profileData.twitter = input;
                this.log(`‚úÖ Twitter: @${input}`, "success");
              }

              this.profileRegistrationStep = 6;
              this.inputType = "profile_discord";
              this.log("", "info");
              this.log("üí¨ Enter your Discord ID:", "info");
              this.log(
                "    (Optional - your Discord username or ID)",
                "output"
              );
              break;

            case "profile_discord":
              if (input && input.length <= 50) {
                this.profileData.discord = input;
                this.log(`‚úÖ Discord: ${input}`, "success");
              }

              this.profileRegistrationStep = 7;
              this.inputType = "profile_email";
              this.log("", "info");
              this.log("üìß Enter your email address:", "info");
              this.log(
                "    (Optional - for notifications and updates)",
                "output"
              );
              break;

            case "profile_email":
              if (
                input &&
                input.includes("@") &&
                input.includes(".") &&
                input.length <= 100
              ) {
                this.profileData.email = input;
                this.log(`‚úÖ Email: ${input}`, "success");
              } else if (input && input.length > 0) {
                this.log("‚ùå Please enter a valid email address", "error");
                this.log("üìß Enter your email address:", "info");
                return;
              }

              this.profileRegistrationStep = 8;
              this.inputType = "profile_confirmation";
              this.log("", "info");
              this.log("‚ú® PROFILE SUMMARY", "success");
              this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
              this.log(
                `üè∑Ô∏è  Username: ${this.profileData.username || "Not set"}`,
                "info"
              );
              this.log(
                `üìù Display Name: ${this.profileData.displayName || "Not set"}`,
                "info"
              );
              this.log(`üí¨ Bio: ${this.profileData.bio || "Not set"}`, "info");
              this.log(
                `üìç Location: ${this.profileData.location || "Not set"}`,
                "info"
              );
              this.log(
                `üê¶ Twitter: ${this.profileData.twitter || "Not set"}`,
                "info"
              );
              this.log(
                `üí¨ Discord: ${this.profileData.discord || "Not set"}`,
                "info"
              );
              this.log(
                `üìß Email: ${this.profileData.email || "Not set"}`,
                "info"
              );
              this.log("", "info");
              this.log("‚úÖ Confirm registration? (yes/no):", "info");
              break;

            case "profile_confirmation":
              const confirm = input.toLowerCase();
              this.awaitingInput = false;
              this.inputType = null;

              if (confirm === "yes" || confirm === "y") {
                await this.submitUserProfile();
              } else {
                this.log("‚ùå Profile registration cancelled", "error");
                this.log('üí° Use "profile register" to try again', "info");
              }
              break;
          }
        }

        async submitUserProfile() {
          this.log("üì§ Submitting your profile...", "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${this.profileData.walletAddress}/profile`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  username: this.profileData.username,
                  displayName: this.profileData.displayName,
                  bio: this.profileData.bio,
                  location: this.profileData.location,
                  twitter: this.profileData.twitter,
                  discord: this.profileData.discord,
                  email: this.profileData.email,
                }),
              }
            );

            const data = await response.json();

            if (!data.success) {
              this.log(`‚ùå Registration failed: ${data.error}`, "error");
              return;
            }

            this.log("üéâ PROFILE REGISTERED SUCCESSFULLY!", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
            this.log(
              `‚úÖ Welcome to Omega Network, ${
                this.profileData.displayName || this.profileData.username
              }!`,
              "success"
            );
            this.log("", "info");
            this.log("üéØ What's next:", "info");
            this.log('  ‚Ä¢ Use "profile" to view your profile', "output");
            this.log(
              '  ‚Ä¢ Use "ambassador generate" to become an ambassador',
              "output"
            );
            this.log(
              '  ‚Ä¢ Use "profile activity" to track your progress',
              "output"
            );
            this.log("", "info");

            // Clear registration data
            this.profileData = null;
            this.profileRegistrationStep = 0;
          } catch (error) {
            this.log(`‚ùå Registration failed: ${error.message}`, "error");
          }
        }

        // üêõ PROFILE DEBUG FUNCTIONS
        async debugUserProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '‚ùå Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "‚ùå Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log("üêõ PROFILE DEBUG MODE", "success");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");
          this.log(`üîç Testing profile for: ${walletAddress}`, "info");
          this.log("", "info");

          // Test MAIN API endpoint
          this.log("1. üåê OMEGA API TEST (omeganetwork.co)", "info");
          this.log("   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "info");
          try {
            const localResponse = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   üì° Status: ${localResponse.status}`,
              localResponse.ok ? "success" : "error"
            );

            const localData = await localResponse.json();
            this.log(
              `   üìù Success: ${localData.success}`,
              localData.success ? "success" : "error"
            );

            if (localData.success && localData.data.profile) {
              const profile = localData.data.profile;
              this.log(
                `   üë§ Username: ${profile.username || "NOT FOUND"}`,
                profile.username ? "success" : "error"
              );
              this.log(
                `   üìù Display Name: ${profile.displayName || "NOT FOUND"}`,
                "info"
              );
              this.log(`   üìß Email: ${profile.email || "NOT FOUND"}`, "info");
              this.log(`   üîì Public: ${profile.isPublic}`, "info");
            } else {
              this.log(
                `   ‚ùå Error: ${localData.error || "No profile data"}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`   üí• Failed: ${error.message}`, "error");
          }

          this.log("", "info");

          // Test PRODUCTION RELAYER endpoint
          this.log(
            "2. ‚öôÔ∏è PRODUCTION RELAYER TEST (terminal-v1-5-9.onrender.com)",
            "info"
          );
          this.log("   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", "info");
          try {
            const prodResponse = await fetch(
              `${RELAYER_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   üì° Status: ${prodResponse.status}`,
              prodResponse.ok ? "success" : "error"
            );

            const prodData = await prodResponse.json();
            this.log(
              `   üìù Success: ${prodData.success}`,
              prodData.success ? "success" : "error"
            );

            if (prodData.success && prodData.data.profile) {
              const profile = prodData.data.profile;
              this.log(
                `   üë§ Username: ${profile.username || "NOT FOUND"}`,
                profile.username ? "success" : "error"
              );
              this.log(
                `   üìù Display Name: ${profile.displayName || "NOT FOUND"}`,
                "info"
              );
              this.log(`   üìß Email: ${profile.email || "NOT FOUND"}`, "info");
              this.log(`   üîì Public: ${profile.isPublic}`, "info");
            } else {
              this.log(
                `   ‚ùå Error: ${prodData.error || "No profile data"}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`   üí• Failed: ${error.message}`, "error");
          }

          this.log("", "info");
          this.log("üéØ DIAGNOSIS:", "success");
          this.log(
            "‚Ä¢ If OMEGA API has username but RELAYER doesn't: Use main API for profiles",
            "info"
          );
          this.log(
            "‚Ä¢ If both have same username: Data sync is working",
            "info"
          );
          this.log(
            "‚Ä¢ If neither has username: Profile registration failed",
            "info"
          );
          this.log(
            "‚Ä¢ If RELAYER shows 404: Production relayer missing profile endpoints",
            "info"
          );
        }

        async testProfileEndpoints() {
          if (!this.signer) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '‚ùå Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("üß™ PROFILE ENDPOINT TESTS", "success");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "success");

          // Test 1: Check if production relayer is running
          this.log("1. üîó Testing production relayer connection...", "info");
          try {
            const healthResponse = await fetch(
              `${RELAYER_URL}/api/health/liveness`
            );
            if (healthResponse.ok) {
              this.log("   ‚úÖ Production relayer is running!", "success");
            } else {
              this.log(
                "   ‚ùå Production relayer returned error status",
                "error"
              );
            }
          } catch (error) {
            this.log(
              `   üí• Production relayer connection failed: ${error.message}`,
              "error"
            );
            this.log(
              "   üí° Check if terminal-v1-5-9.onrender.com is up",
              "info"
            );
          }

          // Test 2: Test profile GET endpoint
          this.log("", "info");
          this.log("2. üìñ Testing profile GET endpoint...", "info");
          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   üì° Response status: ${response.status}`,
              response.ok ? "success" : "error"
            );

            const data = await response.json();
            this.log(`   üìù Response data:`, "info");
            this.log(`      ${JSON.stringify(data, null, 2)}`, "output");
          } catch (error) {
            this.log(`   üí• GET test failed: ${error.message}`, "error");
          }

          // Test 3: Test profile POST endpoint with dummy data
          this.log("", "info");
          this.log("3. üìù Testing profile POST endpoint (dry run)...", "info");
          try {
            const testData = {
              username: "test_user_debug",
              displayName: "Debug Test User",
              bio: "This is a test profile for debugging",
              email: "debug@test.com",
            };

            this.log(
              `   üì§ Test payload: ${JSON.stringify(testData, null, 2)}`,
              "output"
            );
            this.log("   ‚ÑπÔ∏è This would POST to:", "info");
            this.log(
              `   ${OMEGA_API_URL}/v1/users/${walletAddress}/profile`,
              "output"
            );
            this.log(
              '   üí° Use "profile register" to actually save data',
              "info"
            );
          } catch (error) {
            this.log(`   üí• POST test setup failed: ${error.message}`, "error");
          }

          this.log("", "info");
          this.log("üéØ NEXT STEPS:", "success");
          this.log(
            "‚Ä¢ If connection fails: Check if production servers are up",
            "info"
          );
          this.log(
            '‚Ä¢ If GET works: Use "profile debug" to compare main API vs relayer',
            "info"
          );
          this.log(
            '‚Ä¢ If POST endpoint exists: Try "profile register" again',
            "info"
          );
        }

        // üé® GUI THEME COMMAND HANDLER
        handleGuiCommand(args) {
          if (!args || args.length < 2) {
            this.log("üé® OMEGA TERMINAL GUI THEMES", "info");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
            this.log("", "info");
            this.log("üì± AVAILABLE THEMES:", "info");
            this.log(
              "  gui ios          iOS Messages-style interface",
              "output"
            );
            this.log(
              "  gui chatgpt      ChatGPT-style conversation interface",
              "output"
            );
            this.log(
              "  gui discord      Discord-style chat interface",
              "output"
            );
            this.log(
              "  gui aol          Retro AOL instant messenger style",
              "output"
            );
            this.log(
              "  gui windows95    Authentic Windows 95 DOS interface",
              "output"
            );
            this.log(
              "  gui limewire     P2P file sharing retro interface",
              "output"
            );
            this.log(
              "  gui off          Return to standard terminal",
              "output"
            );
            this.log("", "info");
            this.log("üéØ EXAMPLES:", "info");
            this.log(
              "  gui ios          # Switch to iOS Messages theme",
              "info"
            );
            this.log("  gui chatgpt      # Switch to ChatGPT theme", "info");
            this.log("  gui discord      # Switch to Discord theme", "info");
            this.log("  gui off          # Back to normal terminal", "info");
            this.log("", "info");
            this.log(
              "üí° Each theme completely transforms the interface!",
              "success"
            );
            return;
          }

          const theme = args[1].toLowerCase();

          // Remove all existing GUI theme classes
          document.body.classList.remove(
            "gui-chatgpt",
            "gui-ios",
            "gui-discord",
            "gui-aol",
            "gui-windows95",
            "gui-limewire"
          );

          switch (theme) {
            case "ios":
              document.body.classList.add("gui-ios");
              this.setupiOSInterface();
              this.log("‚úÖ Switched to iOS Messages theme", "success");
              this.log(
                "üì± You now have an iPhone-style messaging interface!",
                "info"
              );
              break;
            case "chatgpt":
              document.body.classList.add("gui-chatgpt");
              this.setupChatGPTInterface();
              this.log("‚úÖ Switched to ChatGPT theme", "success");
              this.log(
                "üí¨ You now have a conversational AI interface!",
                "info"
              );
              break;
            case "discord":
              document.body.classList.add("gui-discord");
              this.setupDiscordInterface();
              this.log("‚úÖ Switched to Discord theme", "success");
              this.log(
                "üéÆ You now have a Discord-style chat interface!",
                "info"
              );
              break;
            case "aol":
              document.body.classList.add("gui-aol");
              this.setupAOLInterface();
              this.log("‚úÖ Switched to AOL theme", "success");
              this.log(
                "üìû Welcome to the 90s instant messenger experience!",
                "info"
              );
              break;
            case "windows95":
              document.body.classList.add("gui-windows95");
              this.setupWindows95Interface();
              this.log("‚úÖ Switched to Windows 95 theme", "success");
              this.log("üíª Authentic retro DOS window experience!", "info");
              break;
            case "limewire":
              document.body.classList.add("gui-limewire");
              this.setupLimewireInterface();
              this.log("‚úÖ Switched to Limewire theme", "success");
              this.log(
                "üéµ P2P file sharing retro interface activated!",
                "info"
              );
              break;
            case "off":
            case "normal":
            case "default":
              this.restoreOriginalTerminal();
              this.log("‚úÖ Returned to standard terminal theme", "success");
              this.log("üñ•Ô∏è Classic terminal interface restored", "info");
              break;
            default:
              this.log(`‚ùå Unknown GUI theme: ${theme}`, "error");
              this.log('Type "gui" for available themes', "info");
          }
        }

        setupChatGPTInterface() {
          // Transform terminal into ChatGPT-style interface
          this.log("ü§ñ ChatGPT interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-chatgpt";

          // Create ChatGPT interface structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: #212121; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <!-- Header with back button -->
                        <div style="position: absolute; top: 20px; left: 20px; z-index: 100;">
                            <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                    style="background: #424242; color: #ececec; border: 1px solid #565656; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                                ‚Üê Terminal
                            </button>
                        </div>
                        
                        <!-- Conversation area -->
                        <div class="chatgpt-conversation" style="flex: 1; overflow-y: auto; padding: 80px 20px 200px 20px; max-width: 768px; margin: 0 auto; width: 100%;">
                            <div style="text-align: center; margin-bottom: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ü§ñ</div>
                                <h1 style="color: #ececec; font-size: 32px; font-weight: 300; margin: 0;">Omega Terminal AI</h1>
                                <p style="color: #8e8ea0; margin-top: 12px; font-size: 16px;">Type any command below!</p>
                            </div>
                        </div>
                        
                        <!-- Centered input at bottom -->
                        <div style="position: fixed; bottom: 0; left: 0; right: 0; background: #212121; padding: 32px 20px; border-top: 1px solid #424242;">
                            <div style="max-width: 768px; margin: 0 auto;">
                                <div style="position: relative; display: flex; align-items: center; background: #2f2f2f; border: 1px solid #565656; border-radius: 24px; padding: 12px 16px;">
                                    <div style="color: #8e8ea0; margin-right: 12px; font-size: 20px;">+</div>
                                    <input type="text" 
                                           placeholder="Type any terminal command..." 
                                           id="chatgptInput" 
                                           onkeypress="if(event.key==='Enter') window.terminal.handleChatGPTCommand();"
                                           style="flex: 1; background: none; border: none; color: #ececec; font-size: 16px; outline: none; padding: 4px 0;" />
                                    <div style="display: flex; gap: 8px; margin-left: 12px;">
                                        <div style="color: #8e8ea0; cursor: pointer; padding: 4px;">üé§</div>
                                        <div onclick="window.terminal.handleChatGPTCommand()" 
                                             style="background: #19c37d; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                            ‚û§
                                        </div>
                                    </div>
                                </div>
                                <p style="text-align: center; color: #8e8ea0; font-size: 13px; margin-top: 16px; margin-bottom: 0;">
                                    Try: balance, help, connect, mine, faucet
                                </p>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "chatgpt";
          this.log(
            "üí¨ Chat bubbles and conversation mode activated",
            "success"
          );

          // Focus input
          setTimeout(() => {
            document.getElementById("chatgptInput")?.focus();
          }, 100);
        }

        setupiOSInterface() {
          // Transform terminal into iOS Messages-style interface
          this.log("üì± iOS Messages interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-ios";

          // Create iOS Messages interface structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: linear-gradient(180deg, #000000 0%, #1c1c1e 100%); font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;">
                        <!-- iOS Status Bar -->
                        <div style="background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; color: white; font-size: 17px; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                        style="background: none; border: none; color: #007AFF; font-size: 17px; cursor: pointer;">‚Üê Terminal</button>
                                <div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #007AFF, #34C759); display: flex; align-items: center; justify-content: center; color: white; font-size: 16px; font-weight: bold;">Œ©</div>
                                <span style="color: white; font-weight: 600;">Omega Network</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; font-size: 14px;">
                                <span>‚óè‚óè‚óè</span>
                                <span style="background: #34C759; width: 18px; height: 10px; border-radius: 2px;"></span>
                                <span>100%</span>
                            </div>
                        </div>
                        
                        <!-- Messages Area -->
                        <div style="flex: 1; padding: 16px; overflow-y: auto; background: #000000;" id="iosConversation">
                            <!-- Welcome message from system -->
                            <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                                <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4;">
                                    üëã Welcome to Omega Terminal<br/>
                                    Try: <strong>balance</strong>, <strong>mine</strong>, <strong>claim</strong>, or <strong>help</strong>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Input Area -->
                        <div style="background: rgba(28, 28, 30, 0.95); backdrop-filter: blur(20px); padding: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px; background: rgba(58, 58, 60, 0.8); border-radius: 24px; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.1);">
                                <input type="text" 
                                       placeholder="iMessage" 
                                       id="iosInput" 
                                       onkeypress="if(event.key==='Enter'){window.terminal.handleiOSCommand();}"
                                       style="flex: 1; background: none; border: none; color: #FFFFFF; font-size: 17px; outline: none; padding: 8px 0; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;" />
                                <button onclick="window.terminal.handleiOSCommand()" 
                                        style="background: #007AFF; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);">
                                    ‚Üë
                                </button>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "ios";
          this.log("üì± iOS Messages interface activated", "success");

          // Focus input
          setTimeout(() => {
            document.getElementById("iosInput")?.focus();
          }, 100);
        }

        setupDiscordInterface() {
          // Transform terminal into Discord-style interface
          this.log("üéÆ Discord interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-discord";

          // Create Discord interface structure that matches CSS
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div class="discord-app">
                        <div class="discord-sidebar">
                            <div class="discord-server">Œ©</div>
                            <div class="discord-channels">
                                <div class="channel-category">Text Channels</div>
                                <div class="channel active"># omega-terminal</div>
                                <div class="channel"># general</div>
                                <div class="channel"># mining</div>
                                <div class="channel"># ambassador</div>
                            </div>
                        </div>
                        <div class="discord-main">
                            <div class="discord-header">
                                # omega-terminal
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" style="background: #f04747; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; margin-left: auto;">Exit</button>
                            </div>
                            <div class="discord-messages" id="discordMessages">
                                <div class="discord-message">
                                    <div class="message-author">Omega Bot</div>
                                    <div class="message-text">Welcome to Omega Terminal Discord mode! Type any command to continue.</div>
                                </div>
                            </div>
                            <div class="discord-input">
                                <input type="text" placeholder="Message #omega-terminal" id="discordInput" onkeypress="if(event.key==='Enter'){window.terminal.handleDiscordCommand();}">
                                <button onclick="window.terminal.handleDiscordCommand()">Send</button>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "discord";
          this.log("üí¨ Full-screen chat mode activated", "success");

          // Input handler is now inline in HTML - no setup needed
        }

        setupAOLInterface() {
          // Create AOL-style interface
          // Add GUI body class
          document.body.className = "gui-aol";

          this.log("üìû AOL Instant Messenger loading...", "info");

          // Create AOL interface structure that matches CSS
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div class="aol-window">
                        <div class="aol-titlebar">
                            <span>AOL Instant Messenger - Omega Terminal</span>
                            <div class="aol-buttons">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])">X</button>
                            </div>
                        </div>
                        <div class="aol-content">
                            <div class="aol-buddylist">
                                <div class="aol-section">
                                    <strong>Online Buddies (3)</strong>
                                    <div class="buddy">OmegaMiner42</div>
                                    <div class="buddy">CryptoTrader</div>
                                    <div class="buddy">Web3Ninja</div>
                                </div>
                                <div class="aol-section">
                                    <strong>Away (1)</strong>
                                    <div class="buddy">Ambassador1</div>
                                </div>
                            </div>
                            <div class="aol-chat">
                                <div class="aol-messages" id="aolMessages">
                                    <div class="aol-message">
                                        <strong>OmegaBot:</strong> Welcome to AOL Omega Terminal! Type commands to chat.
                                    </div>
                                </div>
                                <div class="aol-input">
                                    <input type="text" placeholder="Type your message..." id="aolInput" onkeypress="if(event.key==='Enter'){window.terminal.handleAOLCommand();}">
                                    <button onclick="window.terminal.handleAOLCommand()">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "aol";
          this.log("‚ú® 90s nostalgia mode activated", "success");

          // Input handler is now inline in HTML - no setup needed
        }

        setupWindows95Interface() {
          // Create Windows 95-style interface
          // Add GUI body class
          document.body.className = "gui-windows95";

          this.log("üíª Windows 95 interface loading...", "info");
          this.log("üñ•Ô∏è Authentic DOS window experience", "success");
          this.log("‚ö° Retro computing mode activated", "info");
        }

        setupLimewireInterface() {
          // Create Limewire-style interface
          // Add GUI body class
          document.body.className = "gui-limewire";

          this.log("üéµ Limewire interface loading...", "info");
          this.log("üîó P2P file sharing theme activated", "success");
          this.log("üíö Retro green interface ready", "info");
        }

        async executeCommandInGUI(command, theme) {
          try {
            // Store current GUI interface
            const currentHTML = document.getElementById("terminal").innerHTML;

            // Temporarily restore basic terminal structure for command execution
            document.getElementById("terminal").innerHTML = `
                        <div class="terminal-content" id="terminalContent"></div>
                        <div style="display: none;">
                            <input id="commandInput" value="">
                        </div>
                    `;

            // Execute the actual terminal command
            await this.executeCommand(command);

            // Get the output from the terminal content
            const output =
              document.getElementById("terminalContent").textContent ||
              "Command executed";

            // Restore GUI interface
            document.getElementById("terminal").innerHTML = currentHTML;

            // Re-apply body class for styling
            if (theme === "ios") {
              document.body.className = "gui-ios";
            } else if (theme === "chatgpt") {
              document.body.className = "gui-chatgpt";
            } else if (theme === "discord") {
              document.body.className = "gui-discord";
            } else if (theme === "aol") {
              document.body.className = "gui-aol";
            }

            // Clean up output for better display
            const cleanOutput = output
              .replace(
                /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,
                ""
              )
              .trim();

            // Display result in appropriate GUI theme
            if (theme === "ios") {
              this.addiOSMessage(
                `${cleanOutput || "‚úÖ Command completed successfully!"}`,
                "system"
              );
            } else if (theme === "chatgpt") {
              this.addChatGPTMessage(
                `${cleanOutput || "Command completed successfully!"}`,
                "assistant"
              );
            } else if (theme === "discord") {
              this.addDiscordMessage(
                `‚úÖ ${cleanOutput || "Command completed!"}`,
                "bot"
              );
            } else if (theme === "aol") {
              this.addAOLMessage(`${cleanOutput || "Command done!"}`, "bot");
            }
          } catch (error) {
            // Restore GUI on error
            const currentHTML = document.getElementById("terminal").innerHTML;
            if (
              !currentHTML.includes("iosConversation") &&
              !currentHTML.includes("chatgpt-conversation") &&
              !currentHTML.includes("discord") &&
              !currentHTML.includes("aol")
            ) {
              // Need to restore GUI - something went wrong
              if (theme === "ios") {
                this.setupiOSInterface();
              } else if (theme === "chatgpt") {
                this.setupChatGPTInterface();
              } else if (theme === "discord") {
                this.setupDiscordInterface();
              } else if (theme === "aol") {
                this.setupAOLInterface();
              }
            }

            if (theme === "ios") {
              this.addiOSMessage(`‚ùå Error: ${error.message}`, "system");
            } else if (theme === "chatgpt") {
              this.addChatGPTMessage(`‚ùå Error: ${error.message}`, "assistant");
            } else if (theme === "discord") {
              this.addDiscordMessage(`‚ùå Error: ${error.message}`, "bot");
            } else if (theme === "aol") {
              this.addAOLMessage(`Error: ${error.message}`, "bot");
            }
          }
        }

        async safeExecuteCommand(command) {
          try {
            // Store original DOM functions that might fail in GUI mode
            const originalLog = this.log;
            const originalLogHtml = this.logHtml;

            // Mock the log functions to prevent DOM errors
            this.log = () => {}; // Silently ignore
            this.logHtml = () => {}; // Silently ignore

            // Mock getElementById to prevent null errors
            const originalGetElementById = document.getElementById;
            document.getElementById = function (id) {
              const element = originalGetElementById.call(document, id);
              if (
                !element &&
                (id === "terminalContent" || id === "commandInput")
              ) {
                // Return a mock element for critical terminal elements
                return {
                  innerHTML: "",
                  appendChild: () => {},
                  scrollTop: 0,
                  style: {},
                  focus: () => {},
                  value: "",
                };
              }
              return element;
            };

            // Execute the command
            await this.executeCommand(command);

            // Restore original functions
            this.log = originalLog;
            this.logHtml = originalLogHtml;
            document.getElementById = originalGetElementById;

            return { success: true };
          } catch (error) {
            // Restore functions in case of error
            this.log = this.log.bind ? this.log : () => {};
            this.logHtml = this.logHtml.bind ? this.logHtml : () => {};
            document.getElementById = document.getElementById.bind
              ? document.getElementById
              : (id) => document.querySelector("#" + id);

            return { success: false, error: error.message };
          }
        }

        async handleChatGPTCommand() {
          const input = document.getElementById("chatgptInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addChatGPTMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addChatGPTMessage(
              "Available commands:\n‚Ä¢ **test** - Test GUI functionality\n‚Ä¢ **balance** - Check your OMEGA balance\n‚Ä¢ **mine** - Start mining session\n‚Ä¢ **claim** - Claim your rewards\n‚Ä¢ **gui off** - Exit ChatGPT mode",
              "assistant"
            );
          } else if (command === "test") {
            this.addChatGPTMessage(
              "‚úÖ ChatGPT GUI is working perfectly!",
              "assistant"
            );
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addChatGPTMessage("Checking your balance...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else if (command === "mine") {
            this.addChatGPTMessage("Starting mining session...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else if (command === "claim") {
            this.addChatGPTMessage("Processing claim...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else {
            this.addChatGPTMessage(`Processing "${command}"...`, "assistant");
            // Try to execute other commands
            this.safeExecuteCommand(command).then((result) => {
              this.addChatGPTMessage(
                result.success
                  ? `‚úÖ ${command} completed`
                  : `‚ùå ${result.error}`,
                "assistant"
              );
            });
          }
        }

        async handleiOSCommand() {
          const input = document.getElementById("iosInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message (blue bubble on right)
          this.addiOSMessage(command, "user");
          input.value = "";

          // Process command with a small delay for realistic feel
          setTimeout(() => {
            if (command === "help") {
              this.addiOSMessage(
                "Available commands:\n‚Ä¢ balance - Check your OMEGA balance\n‚Ä¢ mine - Start mining session\n‚Ä¢ claim - Claim your rewards\n‚Ä¢ gui off - Exit iOS mode",
                "system"
              );
            } else if (command === "test") {
              this.addiOSMessage(
                "‚úÖ iOS GUI is working perfectly! üì±",
                "system"
              );
            } else if (command === "gui off") {
              this.handleGuiCommand(["gui", "off"]);
            } else if (command === "balance") {
              this.addiOSMessage("‚è≥ Checking your balance...", "system");
              this.executeCommandInGUI(command, "ios");
            } else if (command === "mine") {
              this.addiOSMessage("‚õèÔ∏è Starting mining session...", "system");
              this.executeCommandInGUI(command, "ios");
            } else if (command === "claim") {
              this.addiOSMessage("üí∞ Processing claim...", "system");
              this.executeCommandInGUI(command, "ios");
            } else {
              this.addiOSMessage(`‚ö° Processing "${command}"...`, "system");
              // Try to execute other commands
              this.safeExecuteCommand(command).then((result) => {
                this.addiOSMessage(
                  result.success
                    ? `‚úÖ ${command} completed`
                    : `‚ùå ${result.error}`,
                  "system"
                );
              });
            }
          }, 300); // Small delay for realistic messaging feel
        }

        async handleDiscordCommand() {
          const input = document.getElementById("discordInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addDiscordMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addDiscordMessage(
              "**Available Commands:**\n`test` - Test functionality\n`balance` - Check OMEGA balance\n`mine` - Start mining session\n`claim` - Claim rewards\n`gui off` - Exit Discord",
              "bot"
            );
          } else if (command === "test") {
            this.addDiscordMessage("‚úÖ **Discord GUI Working!**", "bot");
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addDiscordMessage("üí∞ Checking balance...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else if (command === "mine") {
            this.addDiscordMessage("‚õèÔ∏è Starting mining...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else if (command === "claim") {
            this.addDiscordMessage("üíé Processing claim...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else {
            this.addDiscordMessage(`üîÑ Processing "${command}"...`, "bot");
            this.safeExecuteCommand(command).then((result) => {
              this.addDiscordMessage(
                result.success
                  ? `‚úÖ ${command} completed`
                  : `‚ùå ${result.error}`,
                "bot"
              );
            });
          }
        }

        addDiscordMessage(content, sender) {
          const messages = document.getElementById("discordMessages");
          if (!messages) return;

          const messageEl = document.createElement("div");
          messageEl.className = "discord-message";

          const username = sender === "user" ? "You" : "Omega Bot";

          messageEl.innerHTML = `
                    <div class="message-author">${username}</div>
                    <div class="message-text">
                        <pre style="font-family: monospace; white-space: pre-wrap; margin: 0; color: #dcddde;">${content}</pre>
                    </div>
                `;

          messages.appendChild(messageEl);
          messages.scrollTop = messages.scrollHeight;
        }

        async handleAOLCommand() {
          const input = document.getElementById("aolInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addAOLMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addAOLMessage(
              "Commands: test, balance, mine, claim, gui off",
              "bot"
            );
          } else if (command === "test") {
            this.addAOLMessage("AOL GUI working!", "bot");
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addAOLMessage("Checking balance...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else if (command === "mine") {
            this.addAOLMessage("Mining started...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else if (command === "claim") {
            this.addAOLMessage("Processing claim...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else {
            this.addAOLMessage(`Processing "${command}"...`, "bot");
            this.safeExecuteCommand(command).then((result) => {
              this.addAOLMessage(
                result.success ? `${command} done` : `Error: ${result.error}`,
                "bot"
              );
            });
          }
        }

        addAOLMessage(content, sender) {
          const messages = document.getElementById("aolMessages");
          if (!messages) return;

          const messageEl = document.createElement("div");
          messageEl.className = "aol-message";

          const username = sender === "user" ? "You" : "OmegaBot";
          messageEl.innerHTML = `<strong>${username}:</strong> ${content}`;

          messages.appendChild(messageEl);
          messages.scrollTop = messages.scrollHeight;
        }

        addChatGPTMessage(content, sender) {
          const conversation = document.querySelector(".chatgpt-conversation");
          if (!conversation) return;

          const messageEl = document.createElement("div");
          messageEl.className = `chat-message ${sender}`;

          if (sender === "user") {
            // User messages on the right - GREEN BUBBLES!
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 10px 0;">
                            <div style="background: #19c37d; color: white; padding: 12px 16px; border-radius: 18px; max-width: 70%; margin-right: 12px;">
                                ${content}
                            </div>
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #19c37d; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px;">üë§</div>
                        </div>
                    `;
          } else {
            // Assistant messages on the left - PURPLE AVATAR!
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #ab68ff; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px; margin-right: 12px;">ü§ñ</div>
                            <div style="background: transparent; color: #ececec; padding: 12px 16px; border-radius: 18px; max-width: 70%;">
                                ${content}
                            </div>
                        </div>
                    `;
          }

          conversation.appendChild(messageEl);
          conversation.scrollTop = conversation.scrollHeight;
        }

        addiOSMessage(content, sender) {
          const conversation = document.getElementById("iosConversation");
          if (!conversation) return;

          const messageEl = document.createElement("div");
          messageEl.className = `ios-message ${sender}`;

          if (sender === "user") {
            // User messages on the right - Blue iOS bubbles
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 8px 0; animation: slideInRight 0.3s ease-out;">
                            <div style="background: #007AFF; color: white; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3); word-wrap: break-word;">
                                ${content.replace(/\n/g, "<br>")}
                            </div>
                        </div>
                    `;
          } else {
            // System messages on the left - Gray iOS bubbles
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 8px 0; animation: slideInLeft 0.3s ease-out;">
                            <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; border: 1px solid rgba(255,255,255,0.1); word-wrap: break-word;">
                                ${content.replace(/\n/g, "<br>")}
                            </div>
                        </div>
                    `;
          }

          conversation.appendChild(messageEl);
          conversation.scrollTop = conversation.scrollHeight;

          // Add subtle haptic-like effect
          messageEl.style.transform = "scale(0.95)";
          setTimeout(() => {
            messageEl.style.transform = "scale(1)";
            messageEl.style.transition = "transform 0.1s ease-out";
          }, 50);
        }

        restoreOriginalTerminal() {
          // Remove all GUI body classes
          document.body.className = "";

          // Store current interface state
          const currentInterface = this.currentInterface;
          this.currentInterface = "terminal";

          // Restore original terminal HTML structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "";
          terminal.innerHTML = `
                    <div class="terminal-header">
                        <div class="terminal-title">Omega Terminal v2.0.1</div>
                        <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                            <button class="ai-toggle" title="Toggle AI Mode" id="aiToggle">AI Mode (off)</button>
                            <button class="theme-toggle" title="Toggle Theme"></button>
                            <div class="terminal-status" id="connectionStatus">CONNECTED</div>
                        </div>
                    </div>
                    <div class="tab-bar" id="tabBar" style="display: flex; align-items: center; background: #111; border-bottom: 1px solid #fff;">
                        <div class="tab active" data-tab="0" style="padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold;">Terminal 1</div>
                        <div id="addTabBtn" style="padding: 8px 18px; cursor: pointer; color: #00bcf2; font-size: 1.3em;">+</div>
                    </div>
                    <div class="terminal-content" id="terminalContent"></div>
                    <div class="terminal-input-section">
                        <div class="input-line">
                            <span class="input-prompt">root@omega-miner:~$</span>
                            <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                            <span class="cursor">|</span>
                        </div>
                    </div>
                `;

          // Restore event listeners
          this.setupEventListeners();
        }

        renderTabs() {
          const tabBar = document.getElementById("tabBar");
          if (!tabBar) return;
          // Clear existing tabs except the add button
          const addBtn = document.getElementById("addTabBtn");
          tabBar.innerHTML = "";
          if (addBtn) tabBar.appendChild(addBtn);
          this.tabs.forEach((tab, index) => {
            const tabElement = document.createElement("div");
            tabElement.className = `tab ${
              index === this.activeTab ? "active" : ""
            }`;
            tabElement.dataset.tab = index;
            tabElement.style.cssText =
              "padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold; display: flex; align-items: center; position: relative;";
            tabElement.onclick = (e) => {
              // Prevent switching if close button is clicked
              if (e.target.classList.contains("tab-close")) return;
              this.switchTab(index);
            };
            tabElement.textContent = tab.name;
            // Add close button for all tabs except the first
            if (index > 0) {
              const closeBtn = document.createElement("span");
              closeBtn.textContent = " √ó";
              closeBtn.className = "tab-close";
              closeBtn.style.cssText =
                "margin-left: 8px; color: #ff3333; cursor: pointer; font-weight: bold;";
              closeBtn.onclick = (e) => {
                e.stopPropagation();
                this.closeTab(index);
              };
              tabElement.appendChild(closeBtn);
            }
            tabBar.insertBefore(tabElement, addBtn);
          });
        }

        switchTab(index) {
          if (index === this.activeTab) return;
          this.activeTab = index;
          this.renderTabs();
          this.loadTabContent();
        }

        closeTab(index) {
          if (index === 0) return; // Never close the first tab
          this.tabs.splice(index, 1);
          // Adjust activeTab if needed
          if (this.activeTab >= index) {
            this.activeTab = Math.max(0, this.activeTab - 1);
          }
          this.renderTabs();
          this.loadTabContent();
        }

        loadTabContent() {
          const tab = this.tabs[this.activeTab];
          if (!tab) return;
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
          // Load tab history
          if (tab.history && tab.history.length) {
            tab.history.forEach((item) => {
              if (item.type === "command") {
                this.logCommand(item.content);
              } else {
                this.logHtml(item.content, item.logType || "output");
              }
            });
          }
        }

        clearTerminalContent() {
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
          // Also clear the tab's history
          const tab = this.tabs[this.activeTab];
          if (tab) tab.history = [];
        }

        async airdrop() {
          this.log("üéÅ Incoming airdrop!", "info");
          // Create and show Airdrop popup
          const modal = document.createElement("div");
          modal.id = "airdropModal";
          modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
          const imgContainer = document.createElement("div");
          imgContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 600px;
                    height: 60%;
                    max-height: 400px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background: #111;
                    border-radius: 10px;
                    box-shadow: 0 0 30px #00bcf2;
                `;
          const closeBtn = document.createElement("button");
          closeBtn.textContent = "√ó";
          closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
          closeBtn.onclick = () => {
            document.body.removeChild(modal);
          };
          const img = document.createElement("img");
          img.src =
            "https://i.postimg.cc/g08SBcPg/Metal-Pole-Bang-for-nearly-15-minutes-crazy-art-dance.gif"; // user-provided gif
          img.alt = "Airdrop";
          img.style.cssText =
            "max-width:100%; max-height:100%; border-radius:10px;";
          imgContainer.appendChild(closeBtn);
          imgContainer.appendChild(img);
          // Add Roy message below the GIF with spacing and centered
          const msg = document.createElement("div");
          msg.innerHTML = `<div style="color:#fff; text-align:center; font-size:1.5em; margin-top:28px; font-weight:bold;">Roy says not yet</div>`;
          imgContainer.appendChild(msg);
          modal.appendChild(imgContainer);
          document.body.appendChild(modal);
          // Auto-close after 30 seconds
          setTimeout(() => {
            if (document.body.contains(modal)) {
              document.body.removeChild(modal);
            }
          }, 30000);
        }

        // Helper methods for Eclipse swaps
        async executeSolarSwap(inputMint, outputMint, amount, slippageBps) {
          // Step 1: Get quote using GET request with query parameters
          this.log("Getting Solar DEX quote...", "info");

          // Ensure we have the correct SOL mint address
          const solMintAddress = "So11111111111111111111111111111111111111112";
          const actualInputMint =
            inputMint === "11111111111111111111111111111111"
              ? solMintAddress
              : inputMint;
          const actualOutputMint =
            outputMint === "11111111111111111111111111111111"
              ? solMintAddress
              : outputMint;

          // Convert amount to proper decimals (assuming 9 decimals for most tokens)
          const amountInDecimals = amount * 1e9;

          // Build query parameters
          const queryParams = new URLSearchParams({
            inputMint: actualInputMint,
            outputMint: actualOutputMint,
            amount: amountInDecimals.toString(),
            slippageBps: slippageBps.toString(),
            txVersion: "LEGACY",
          });

          // this.log(`Quote URL: https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`, 'info');

          const quoteResponse = await fetch(
            `https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`,
            {
              method: "GET",
              headers: { "Content-Type": "application/json" },
            }
          );

          if (!quoteResponse.ok) {
            const errorText = await quoteResponse.text();
            this.log(
              `Solar quote failed: HTTP ${quoteResponse.status}`,
              "error"
            );
            this.log(`Error details: ${errorText}`, "error");
            this.log(`Debug: Request URL: ${quoteResponse.url}`, "info");
            throw new Error("Solar quote failed");
          }

          const quoteData = await quoteResponse.json();
          // this.log(`Solar quote received: ${JSON.stringify(quoteData)}`, 'success');

          if (!quoteData.success) {
            this.log(
              `Quote failed: ${quoteData.msg || "Unknown error"}`,
              "error"
            );
            throw new Error("Solar quote failed");
          }

          // Step 2: Get transaction using the quote response
          this.log("Getting Solar transaction...", "info");

          const transactionPayload = {
            computeUnitPriceMicroLamports: String(300000),
            swapResponse: quoteData,
            txVersion: "LEGACY",
            wallet: window.eclipseWallet.keypair.publicKey.toString(),
            wrapSol: actualInputMint === solMintAddress,
            unwrapSol: actualOutputMint === solMintAddress,
            inputAccount: window.eclipseWallet.keypair.publicKey.toString(), // Simplified for now
            outputAccount: window.eclipseWallet.keypair.publicKey.toString(), // Simplified for now
          };

          // this.log(`Transaction payload: ${JSON.stringify(transactionPayload)}`, 'info');

          const txResponse = await fetch(
            "https://api.solarstudios.co/transaction/swap-base-in",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(transactionPayload),
            }
          );

          if (!txResponse.ok) {
            const errorText = await txResponse.text();
            this.log(`Solar transaction failed: ${errorText}`, "error");
            throw new Error("Solar transaction failed");
          }

          const txData = await txResponse.json();
          // this.log(`Solar transaction received: ${JSON.stringify(txData)}`, 'success');

          if (!txData.success) {
            this.log(
              `Transaction failed: ${txData.msg || "Unknown error"}`,
              "error"
            );
            throw new Error("Solar transaction failed");
          }

          // Step 3: Sign and send transactions
          this.log("Signing and sending transactions...", "info");

          const connection = new window.solanaWeb3.Connection(
            window.eclipseWallet.rpcUrl,
            "confirmed"
          );

          // Handle multiple transactions (like the dev's code)
          const allTxBuf = txData.data.map((tx) =>
            Buffer.from(tx.transaction, "base64")
          );
          const allTransactions = allTxBuf.map((txBuf) =>
            window.solanaWeb3.Transaction.from(txBuf)
          );

          this.log(
            `Total ${allTransactions.length} transactions to process`,
            "info"
          );

          for (let idx = 0; idx < allTransactions.length; idx++) {
            const transaction = allTransactions[idx];

            // Add blockhash
            const { blockhash, lastValidBlockHeight } =
              await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;

            // Sign the transaction
            transaction.sign(window.eclipseWallet.keypair);

            // Serialize and send
            const txId = await connection.sendRawTransaction(
              transaction.serialize(),
              {
                skipPreflight: false,
              }
            );

            this.log(
              `${idx + 1} transaction sending..., txId: ${txId}`,
              "info"
            );

            await connection.confirmTransaction(
              {
                blockhash,
                lastValidBlockHeight,
                signature: txId,
              },
              "confirmed"
            );

            this.log(`${idx + 1} transaction confirmed`, "success");

            this.log(`‚úÖ Solar swap completed successfully!`, "success");
            this.log(
              `Transaction: https://explorer.eclipse.xyz/tx/${txId}`,
              "info"
            );
            return;
          }
        }

        async executeDeserializeSwap(
          inputMint,
          outputMint,
          amount,
          slippageBps
        ) {
          // Step 0: Check balances first
          this.log("Checking wallet balances...", "info");

          try {
            const connection = new window.solanaWeb3.Connection(
              window.eclipseWallet.rpcUrl,
              "confirmed"
            );

            // Check SOL balance for transaction fees
            const solBalance = await connection.getBalance(
              window.eclipseWallet.publicKey
            );
            const solBalanceSol = solBalance / 1e9; // Convert lamports to SOL

            this.log(`SOL balance: ${solBalanceSol.toFixed(6)} SOL`, "info");

            if (solBalanceSol < 0.001) {
              this.log(
                "‚ùå Insufficient SOL for transaction fees. Need at least 0.001 SOL.",
                "error"
              );
              throw new Error("Insufficient SOL for transaction fees");
            }

            // Check token balance if it's not SOL
            if (inputMint !== "So11111111111111111111111111111111111111112") {
              // Not SOL
              const tokenAccount = await connection.getTokenAccountsByOwner(
                window.eclipseWallet.publicKey,
                {
                  mint: new window.solanaWeb3.PublicKey(inputMint),
                }
              );

              if (tokenAccount.value.length === 0) {
                this.log(`‚ùå No ${inputMint} tokens found in wallet.`, "error");
                throw new Error(`No ${inputMint} tokens in wallet`);
              }

              const tokenBalance = await connection.getTokenAccountBalance(
                tokenAccount.value[0].pubkey
              );
              const tokenAmount = tokenBalance.value.uiAmount;

              this.log(`Token balance: ${tokenAmount} tokens`, "info");

              if (tokenAmount < amount) {
                this.log(
                  `‚ùå Insufficient token balance. Have: ${tokenAmount}, Need: ${amount}`,
                  "error"
                );
                throw new Error("Insufficient token balance");
              }
            }

            this.log("‚úÖ Balance check passed", "success");
          } catch (e) {
            if (e.message.includes("balance") || e.message.includes("tokens")) {
              throw e; // Re-throw balance errors
            }
            this.log(
              "‚ö†Ô∏è Could not verify balances, proceeding anyway...",
              "warning"
            );
          }

          // Step 1: Get quote
          this.log("Getting Deserialize quote...", "info");

          const quotePayload = {
            tokenA: inputMint,
            tokenB: outputMint,
            amountIn: amount.toString(),
            dexId: "ALL",
            options: {
              reduceToTwoHops: false,
              targetRouteNumber: 0,
            },
          };

          const quoteResponse = await fetch(
            "https://api.deserialize.xyz/quote",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(quotePayload),
            }
          );

          if (!quoteResponse.ok) {
            const errorText = await quoteResponse.text();
            this.log(
              `Deserialize quote failed: HTTP ${quoteResponse.status}`,
              "error"
            );
            this.log(`Error details: ${errorText}`, "error");

            // Try with different parameters
            this.log("Trying Deserialize with different parameters...", "info");
            const altPayload = {
              tokenA: inputMint,
              tokenB: outputMint,
              amountIn: amount.toString(),
              dexId: "ALL", // Use ALL instead of JUPITER
              options: {
                reduceToTwoHops: true,
                targetRouteNumber: 0,
              },
            };

            const altResponse = await fetch(
              "https://api.deserialize.xyz/quote",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(altPayload),
              }
            );

            if (!altResponse.ok) {
              const altErrorText = await altResponse.text();
              this.log(
                `Deserialize alternative attempt also failed: HTTP ${altResponse.status}`,
                "error"
              );
              this.log(`Error details: ${altErrorText}`, "error");
              throw new Error("Deserialize quote failed - service may be down");
            }

            // Use the alternative response
            const quoteData = await altResponse.json();
            this.log(
              `Deserialize quote received (alternative): ${quoteData.amountOut} output tokens`,
              "success"
            );
            this.log(`Price impact: ${quoteData.priceImpact}%`, "info");
            return quoteData;
          }

          const quoteData = await quoteResponse.json();
          this.log(
            `Deserialize quote received: ${quoteData.amountOut} output tokens`,
            "success"
          );
          this.log(`Price impact: ${quoteData.priceImpact}%`, "info");

          // Step 2: Get transaction
          this.log("Getting Deserialize transaction...", "info");
          const swapPayload = {
            publicKey: window.eclipseWallet.publicKey,
            quote: quoteData,
            fee: {
              devFeeRate: 0.1, // 0.1% fee
              partnerFeeAddress: window.eclipseWallet.publicKey,
            },
          };

          const txResponse = await fetch("https://api.deserialize.xyz/swap", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(swapPayload),
          });

          if (!txResponse.ok) {
            const errorText = await txResponse.text();
            this.log(`Deserialize transaction failed: ${errorText}`, "error");
            throw new Error("Deserialize transaction failed");
          }

          const txData = await txResponse.json();
          this.log("Deserialize transaction received, signing...", "info");

          // Step 3: Sign and send transaction
          const connection = new window.solanaWeb3.Connection(
            window.eclipseWallet.rpcUrl,
            "confirmed"
          );

          // Handle both regular and versioned transactions
          let transaction;
          let signature;

          try {
            // First try to deserialize as a regular transaction
            transaction = window.solanaWeb3.Transaction.from(
              Buffer.from(txData.transaction, "base64")
            );
            transaction.sign(window.eclipseWallet.keypair);
            signature = await connection.sendTransaction(transaction, [
              window.eclipseWallet.keypair,
            ]);
          } catch (e) {
            // If that fails, try as a versioned transaction
            if (e.message.includes("VersionedMessage")) {
              this.log(
                "Detected versioned transaction, using VersionedTransaction...",
                "info"
              );
              transaction = window.solanaWeb3.VersionedTransaction.deserialize(
                Buffer.from(txData.transaction, "base64")
              );
              transaction.sign([window.eclipseWallet.keypair]);
              signature = await connection.sendTransaction(transaction);
            } else {
              throw e; // Re-throw if it's a different error
            }
          }

          this.log(
            `‚úÖ Deserialize swap transaction submitted! Signature: ${signature}`,
            "success"
          );
          this.log("Waiting for confirmation...", "info");

          const confirmation = await connection.confirmTransaction(
            signature,
            "confirmed"
          );
          if (confirmation.value.err) {
            this.log(
              `‚ùå Deserialize transaction failed: ${confirmation.value.err}`,
              "error"
            );
            throw new Error("Deserialize transaction failed");
          } else {
            this.log(`‚úÖ Deserialize swap completed successfully!`, "success");
            this.log(
              `Transaction: https://explorer.eclipse.xyz/tx/${signature}`,
              "info"
            );
          }
        }

        async showEclipseSwapInterface() {
          this.log("üîÑ Eclipse Swap Interface", "info");
          this.log("Loading available tokens...", "info");

          try {
            // Fetch tokens from both APIs
            const [solarResponse, deserializeResponse] = await Promise.all([
              fetch("https://api.solarstudios.co/mint/list"),
              fetch("https://api.deserialize.xyz/tokenList"),
            ]);

            let solarTokens = [];
            let deserializeTokens = [];

            if (solarResponse.ok) {
              const solarData = await solarResponse.json();
              if (
                solarData.success &&
                solarData.data &&
                solarData.data.mintList
              ) {
                solarTokens = solarData.data.mintList;
              }
            }

            if (deserializeResponse.ok) {
              const deserializeData = await deserializeResponse.json();
              if (deserializeData.data && Array.isArray(deserializeData.data)) {
                deserializeTokens = deserializeData.data;
              }
            }

            // Merge tokens
            const allTokens = new Map();

            solarTokens.forEach((token) => {
              allTokens.set(token.address, {
                address: token.address,
                symbol: token.symbol,
                name: token.name,
                decimals: token.decimals,
                source: "Solar",
              });
            });

            deserializeTokens.forEach((token) => {
              allTokens.set(token.address, {
                address: token.address,
                symbol: token.metadata?.symbol || "N/A",
                name: token.metadata?.name || "N/A",
                decimals: token.decimals,
                source: allTokens.has(token.address) ? "Both" : "Deserialize",
              });
            });

            const tokens = Array.from(allTokens.values()).sort((a, b) =>
              a.symbol.localeCompare(b.symbol)
            );

            // Find ETH and SOLAR tokens for defaults (do this first)
            const ethToken = tokens.find(
              (t) => t.symbol === "ETH" || t.name.includes("Ethereum")
            );
            const solarToken = tokens.find(
              (t) => t.symbol === "SOLAR" || t.name.includes("SOLAR")
            );

            const defaultFromToken = ethToken || tokens[0];
            const defaultToToken = solarToken || tokens[1] || tokens[0];

            // Create swap interface with custom dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">üîÑ Eclipse Swap</h3>`;

            // From token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseFromTokenDisplay">üü¢ ${
              defaultFromToken?.name || "Ethereum"
            }</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            tokens.forEach((token) => {
              const sourceIcon =
                token.source === "Solar"
                  ? "üîµ"
                  : token.source === "Deserialize"
                  ? "üü†"
                  : "üü¢";
              html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${sourceIcon} ${token.name}`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="eclipseFromToken" value="${
              defaultFromToken?.address || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseToTokenDisplay">üîµ ${
              defaultToToken?.name || "SOLAR STUDIOS"
            }</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            tokens.forEach((token) => {
              const sourceIcon =
                token.source === "Solar"
                  ? "üîµ"
                  : token.source === "Deserialize"
                  ? "üü†"
                  : "üü¢";
              html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${sourceIcon} ${token.name}`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="eclipseToToken" value="${
              defaultToToken?.address || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="eclipseAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Slippage selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseSlippageDisplay">1.0% (Standard)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
            html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
            html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
            html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="eclipseSlippage" value="100">`;
            html += `</div>`;
            html += `</div>`;

            // Quote display section
            html += `<div id="eclipseQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
            html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
            html += `<div id="eclipseQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
            html += `<div id="eclipseQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
            html += `</div>`;

            // Swap button
            html += `<button id="eclipseSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">üîÑ Execute Swap</button>`;

            // Info section
            html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
            html += `<p><strong>Smart Routing:</strong> Automatically uses Solar DEX for SOLAR token, Deserialize Aggregator for others.</p>`;
            html += `<p><strong>Icons:</strong> üîµ Solar DEX | üü† Deserialize | üü¢ Both DEXes</p>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupEclipseDropdowns();
              const swapBtn = document.getElementById("eclipseSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeEclipseSwapFromInterface()
                );
              }

              // Fix amount input event handling and add quote functionality
              const amountInput = document.getElementById("eclipseAmount");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) => {
                  e.stopPropagation();
                  this.updateEclipseQuote();
                });
              }

              // Add quote update on token changes
              const fromToken = document.getElementById("eclipseFromToken");
              const toToken = document.getElementById("eclipseToToken");
              const slippage = document.getElementById("eclipseSlippage");
              if (fromToken)
                fromToken.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
              if (toToken)
                toToken.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
              if (slippage)
                slippage.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
            }, 100);
          } catch (e) {
            this.log(`Failed to load swap interface: ${e.message}`, "error");
          }
        }

        setupEclipseDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("eclipseFromTokenHeader");
          const fromDropdown = document.getElementById(
            "eclipseFromTokenDropdown"
          );
          const fromHidden = document.getElementById("eclipseFromToken");
          const fromDisplay = document.getElementById(
            "eclipseFromTokenDisplay"
          );

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            fromDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";

                // Update quote when token changes
                this.updateEclipseQuote();
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("eclipseToTokenHeader");
          const toDropdown = document.getElementById("eclipseToTokenDropdown");
          const toHidden = document.getElementById("eclipseToToken");
          const toDisplay = document.getElementById("eclipseToTokenDisplay");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            toDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";

                // Update quote when token changes
                this.updateEclipseQuote();
              }
            });
          }

          // Slippage dropdown
          const slippageHeader = document.getElementById(
            "eclipseSlippageHeader"
          );
          const slippageDropdown = document.getElementById(
            "eclipseSlippageDropdown"
          );
          const slippageHidden = document.getElementById("eclipseSlippage");
          const slippageDisplay = document.getElementById(
            "eclipseSlippageDisplay"
          );

          if (slippageHeader && slippageDropdown) {
            slippageHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = slippageDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== slippageDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              slippageDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            slippageDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                slippageHidden.value = value;
                slippageDisplay.textContent = text;
                slippageDropdown.style.display = "none";
              }
            });
          }
        }

        async updateEclipseQuote() {
          const fromToken = document.getElementById("eclipseFromToken");
          const toToken = document.getElementById("eclipseToToken");
          const amountInput = document.getElementById("eclipseAmount");
          const slippage = document.getElementById("eclipseSlippage");
          const quoteDisplay = document.getElementById("eclipseQuoteDisplay");
          const quoteAmount = document.getElementById("eclipseQuoteAmount");
          const quotePrice = document.getElementById("eclipseQuotePrice");

          if (
            !fromToken ||
            !toToken ||
            !amountInput ||
            !slippage ||
            !quoteDisplay ||
            !quoteAmount ||
            !quotePrice
          ) {
            return;
          }

          const fromMint = fromToken.value;
          const toMint = toToken.value;
          const amount = parseFloat(amountInput.value);
          const slippageBps = parseInt(slippage.value);

          if (
            !fromMint ||
            !toMint ||
            isNaN(amount) ||
            amount <= 0 ||
            isNaN(slippageBps)
          ) {
            quoteDisplay.style.display = "none";
            return;
          }

          try {
            // Smart routing logic - same as swap execution
            const solarTokenAddress =
              "CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze";
            const useSolarDex =
              fromMint === solarTokenAddress || toMint === solarTokenAddress;

            let quoteData;
            if (useSolarDex) {
              // Get Solar DEX quote
              const res = await fetch(`${RELAYER_URL}/solar/quote`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  inputMint: fromMint,
                  outputMint: toMint,
                  amount: amount.toString(),
                  slippageBps: slippageBps,
                }),
              });
              quoteData = await res.json();
            } else {
              // Get Deserialize quote
              const res = await fetch(`${RELAYER_URL}/deserialize/quote`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  inputMint: fromMint,
                  outputMint: toMint,
                  amount: amount.toString(),
                  slippageBps: slippageBps,
                }),
              });
              quoteData = await res.json();
            }

            if (quoteData && quoteData.outAmount) {
              // Get token symbols for display
              const fromTokenElement = document.querySelector(
                '#eclipseFromTokenDropdown .dropdown-item[data-value="' +
                  fromMint +
                  '"]'
              );
              const toTokenElement = document.querySelector(
                '#eclipseToTokenDropdown .dropdown-item[data-value="' +
                  toMint +
                  '"]'
              );
              const fromSymbol = fromTokenElement
                ? fromTokenElement.getAttribute("data-symbol")
                : "Unknown";
              const toSymbol = toTokenElement
                ? toTokenElement.getAttribute("data-symbol")
                : "Unknown";

              // Convert output amount to human readable
              const outputAmount = parseFloat(quoteData.outAmount).toFixed(6);
              quoteAmount.textContent = `${outputAmount} ${toSymbol}`;

              // Show price impact if available
              if (quoteData.priceImpact) {
                const priceImpact = parseFloat(quoteData.priceImpact);
                if (priceImpact > 0.1) {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#ff6b6b";
                } else {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#51cf66";
                }
              } else {
                quotePrice.textContent = "";
              }

              quoteDisplay.style.display = "block";
            } else {
              quoteDisplay.style.display = "none";
            }
          } catch (e) {
            quoteDisplay.style.display = "none";
          }
        }

        async executeEclipseSwapFromInterface() {
          const fromToken = document.getElementById("eclipseFromToken");
          const toToken = document.getElementById("eclipseToToken");
          const amount = document.getElementById("eclipseAmount");
          const slippage = document.getElementById("eclipseSlippage");

          if (!fromToken || !toToken || !amount || !slippage) {
            this.log("Swap interface not found. Please try again.", "error");
            return;
          }

          const inputMint = fromToken.value;
          const outputMint = toToken.value;
          const amountValue = parseFloat(amount.value);
          const slippageBps = parseInt(slippage.value);

          if (
            !inputMint ||
            !outputMint ||
            isNaN(amountValue) ||
            isNaN(slippageBps)
          ) {
            this.log("Please fill in all fields with valid values.", "error");
            return;
          }

          if (inputMint === outputMint) {
            this.log("Cannot swap the same token.", "error");
            return;
          }

          if (amountValue <= 0) {
            this.log("Amount must be greater than 0.", "error");
            return;
          }

          // Smart routing logic
          const solarTokenAddress =
            "CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze";
          const useSolarDex =
            inputMint === solarTokenAddress || outputMint === solarTokenAddress;
          const dexName = useSolarDex ? "Solar DEX" : "Deserialize Aggregator";

          // Get symbols from the hidden inputs' data attributes
          const fromTokenElement = document.querySelector(
            '#eclipseFromTokenDropdown .dropdown-item[data-value="' +
              inputMint +
              '"]'
          );
          const toTokenElement = document.querySelector(
            '#eclipseToTokenDropdown .dropdown-item[data-value="' +
              outputMint +
              '"]'
          );
          const fromSymbol = fromTokenElement
            ? fromTokenElement.getAttribute("data-symbol")
            : "Unknown";
          const toSymbol = toTokenElement
            ? toTokenElement.getAttribute("data-symbol")
            : "Unknown";

          this.log(
            `Starting Eclipse swap: ${amountValue} ${fromSymbol} ‚Üí ${toSymbol}`,
            "info"
          );
          this.log(`Using: ${dexName}`, "info");
          this.log(`Slippage: ${slippageBps / 100}%`, "info");

          try {
            if (useSolarDex) {
              await this.executeSolarSwap(
                inputMint,
                outputMint,
                amountValue,
                slippageBps
              );
            } else {
              await this.executeDeserializeSwap(
                inputMint,
                outputMint,
                amountValue,
                slippageBps
              );
            }
          } catch (e) {
            this.log(`Eclipse swap failed: ${e.message}`, "error");
          }
        }

        async showNearSwapInterface() {
          this.log("üîÑ Near Intents Swap Interface", "info");
          this.log("Loading available tokens...", "info");

          try {
            // Fetch tokens from Near Intents API
            const response = await fetch(
              "https://1click.chaindefuser.com/v0/tokens"
            );
            if (!response.ok) {
              this.log(
                `Failed to fetch tokens: HTTP ${response.status}`,
                "error"
              );
              return;
            }

            const tokens = await response.json();
            const sortedTokens = tokens.sort((a, b) =>
              a.symbol.localeCompare(b.symbol)
            );

            // Debug: Show what tokens were loaded
            this.log(
              `Loaded ${tokens.length} tokens for swap interface:`,
              "info"
            );
            tokens.slice(0, 10).forEach((token) => {
              this.log(
                `- ${token.symbol} (${token.blockchain}): ${token.assetId}`,
                "info"
              );
            });
            if (tokens.length > 10) {
              this.log(`... and ${tokens.length - 10} more tokens`, "info");
            }

            // Create swap interface with custom dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">üîÑ Near Intents Cross-Chain Swap</h3>`;

            // From token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearFromTokenDisplay">üîµ wNEAR (NEAR)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            sortedTokens.forEach((token) => {
              const blockchainIcon =
                token.blockchain === "near"
                  ? "üîµ"
                  : token.blockchain === "solana"
                  ? "üü£"
                  : token.blockchain === "ethereum"
                  ? "üî∂"
                  : "‚ö™";
              html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${blockchainIcon} ${
                token.symbol
              } (${token.blockchain.toUpperCase()})`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="nearFromToken" value="${
              sortedTokens[0]?.assetId || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearToTokenDisplay">üü£ SOL (Solana)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            sortedTokens.forEach((token) => {
              const blockchainIcon =
                token.blockchain === "near"
                  ? "üîµ"
                  : token.blockchain === "solana"
                  ? "üü£"
                  : token.blockchain === "ethereum"
                  ? "üî∂"
                  : "‚ö™";
              html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${blockchainIcon} ${
                token.symbol
              } (${token.blockchain.toUpperCase()})`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="nearToToken" value="${
              sortedTokens.find((t) => t.blockchain === "solana")?.assetId ||
              sortedTokens[1]?.assetId ||
              ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="nearAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Recipient input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Recipient Address:</label>`;
            html += `<input type="text" id="nearRecipient" placeholder="account.near for NEAR, 0x... for EVM, or Solana address" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Slippage selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearSlippageDisplay">1.0% (Standard)</span>`;
            html += `<span style="color: #666;">‚ñº</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
            html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
            html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
            html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="nearSlippage" value="100">`;
            html += `</div>`;
            html += `</div>`;

            // Swap button
            html += `<button id="nearSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">üîÑ Execute Cross-Chain Swap</button>`;

            // Info section
            html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
            html += `<p><strong>Cross-Chain Swaps:</strong> Swap tokens across different blockchains using NEAR Intents.</p>`;
            html += `<p><strong>Icons:</strong> üîµ NEAR | üü£ Solana | üî∂ Ethereum | ‚ö™ Other</p>`;
            html += `<p><strong>Note:</strong> You'll need to manually send tokens to the deposit address provided.</p>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupNearDropdowns();
              const swapBtn = document.getElementById("nearSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeNearSwapFromInterface()
                );
              }

              // Fix input event handling
              const amountInput = document.getElementById("nearAmount");
              const recipientInput = document.getElementById("nearRecipient");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) =>
                  e.stopPropagation()
                );
              }
              if (recipientInput) {
                recipientInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                recipientInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                recipientInput.addEventListener("input", (e) =>
                  e.stopPropagation()
                );
              }
            }, 100);
          } catch (e) {
            this.log(
              `Failed to load Near Intents swap interface: ${e.message}`,
              "error"
            );
          }
        }

        setupSolanaDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("solanaFromTokenHeader");
          const fromDropdown = document.getElementById(
            "solanaFromTokenDropdown"
          );
          const fromHidden = document.getElementById("solanaFromToken");
          const fromDisplay = document.getElementById("solanaFromTokenDisplay");
          const fromSearch = document.getElementById("solanaFromSearch");
          const fromTokenList = document.getElementById("solanaFromTokenList");

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
              if (!isOpen && fromSearch) {
                fromSearch.focus();
              }
            });

            // Handle search input
            if (fromSearch) {
              fromSearch.addEventListener("input", async (e) => {
                e.stopPropagation();
                const query = e.target.value.trim();
                if (query.length >= 2) {
                  fromTokenList.innerHTML =
                    '<div style="padding: 8px; color: #666;">Searching...</div>';
                  try {
                    const res = await fetch(
                      `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                        query
                      )}`
                    );
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                      let html = "";
                      data.slice(0, 10).forEach((token) => {
                        const icon = token.symbol === "SOL" ? "üü£" : "üíé";
                        html += `<div class="dropdown-item" data-value="${
                          token.address || token.id
                        }" data-symbol="${token.symbol}" data-name="${
                          token.name
                        }" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${icon} ${token.symbol} (${token.name})`;
                        html += `</div>`;
                      });
                      fromTokenList.innerHTML = html;
                    } else {
                      fromTokenList.innerHTML =
                        '<div style="padding: 8px; color: #666;">No tokens found</div>';
                    }
                  } catch (err) {
                    fromTokenList.innerHTML =
                      '<div style="padding: 8px; color: #666;">Search failed</div>';
                  }
                } else if (query.length === 0) {
                  // Reset to default tokens
                  fromTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üü£ SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíô USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíö USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üêï BONK (Bonk)</div>
                                `;
                }
              });

              fromSearch.addEventListener("click", (e) => e.stopPropagation());
              fromSearch.addEventListener("focus", (e) => e.stopPropagation());
            }

            // Handle item selection
            fromTokenList.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const name = e.target.getAttribute("data-name");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";
                if (fromSearch) fromSearch.value = "";

                // Update quote when token changes
                this.updateSolanaQuote();
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("solanaToTokenHeader");
          const toDropdown = document.getElementById("solanaToTokenDropdown");
          const toHidden = document.getElementById("solanaToToken");
          const toDisplay = document.getElementById("solanaToTokenDisplay");
          const toSearch = document.getElementById("solanaToSearch");
          const toTokenList = document.getElementById("solanaToTokenList");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
              if (!isOpen && toSearch) {
                toSearch.focus();
              }
            });

            // Handle search input
            if (toSearch) {
              toSearch.addEventListener("input", async (e) => {
                e.stopPropagation();
                const query = e.target.value.trim();
                if (query.length >= 2) {
                  toTokenList.innerHTML =
                    '<div style="padding: 8px; color: #666;">Searching...</div>';
                  try {
                    const res = await fetch(
                      `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                        query
                      )}`
                    );
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                      let html = "";
                      data.slice(0, 10).forEach((token) => {
                        const icon = token.symbol === "SOL" ? "üü£" : "üíé";
                        html += `<div class="dropdown-item" data-value="${
                          token.address || token.id
                        }" data-symbol="${token.symbol}" data-name="${
                          token.name
                        }" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${icon} ${token.symbol} (${token.name})`;
                        html += `</div>`;
                      });
                      toTokenList.innerHTML = html;
                    } else {
                      toTokenList.innerHTML =
                        '<div style="padding: 8px; color: #666;">No tokens found</div>';
                    }
                  } catch (err) {
                    toTokenList.innerHTML =
                      '<div style="padding: 8px; color: #666;">Search failed</div>';
                  }
                } else if (query.length === 0) {
                  // Reset to default tokens
                  toTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üü£ SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíô USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üíö USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">üêï BONK (Bonk)</div>
                                `;
                }
              });

              toSearch.addEventListener("click", (e) => e.stopPropagation());
              toSearch.addEventListener("focus", (e) => e.stopPropagation());
            }

            // Handle item selection
            toTokenList.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const name = e.target.getAttribute("data-name");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";
                if (toSearch) toSearch.value = "";

                // Update quote when token changes
                this.updateSolanaQuote();
              }
            });
          }
        }

        async executeSolanaSwapFromInterface() {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }

          const fromMint = document.getElementById("solanaFromToken")?.value;
          const toMint = document.getElementById("solanaToToken")?.value;
          const amount = document.getElementById("solanaAmount")?.value;

          if (!fromMint || !toMint || !amount) {
            this.log(
              "Please fill in all fields: From Token, To Token, and Amount",
              "error"
            );
            return;
          }

          if (fromMint === toMint) {
            this.log("From and To tokens cannot be the same", "error");
            return;
          }

          // Convert amount to lamports (raw amount)
          let amountLamports;
          if (fromMint === "So11111111111111111111111111111111111111112") {
            // SOL: 1 SOL = 1,000,000,000 lamports
            amountLamports = Math.floor(
              parseFloat(amount) * 1000000000
            ).toString();
          } else {
            // For other tokens, we need to get their decimals
            // For now, assume 6 decimals (like USDC)
            amountLamports = Math.floor(
              parseFloat(amount) * 1000000
            ).toString();
          }

          this.log(
            `Executing swap: ${amount} SOL (${amountLamports} lamports) from ${fromMint} to ${toMint}`,
            "info"
          );
          await this.executeSolanaSwap(amountLamports, fromMint, toMint);
        }

        setupNearDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("nearFromTokenHeader");
          const fromDropdown = document.getElementById("nearFromTokenDropdown");
          const fromHidden = document.getElementById("nearFromToken");
          const fromDisplay = document.getElementById("nearFromTokenDisplay");

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            fromDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("nearToTokenHeader");
          const toDropdown = document.getElementById("nearToTokenDropdown");
          const toHidden = document.getElementById("nearToToken");
          const toDisplay = document.getElementById("nearToTokenDisplay");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            toDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";
              }
            });
          }

          // Slippage dropdown
          const slippageHeader = document.getElementById("nearSlippageHeader");
          const slippageDropdown = document.getElementById(
            "nearSlippageDropdown"
          );
          const slippageHidden = document.getElementById("nearSlippage");
          const slippageDisplay = document.getElementById(
            "nearSlippageDisplay"
          );

          if (slippageHeader && slippageDropdown) {
            slippageHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = slippageDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== slippageDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              slippageDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            slippageDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                slippageHidden.value = value;
                slippageDisplay.textContent = text;
                slippageDropdown.style.display = "none";
              }
            });
          }
        }

        // Helper functions for Near Intents address validation
        getOriginChainFromAsset(asset) {
          // Check for explicit chain prefixes first
          if (asset.includes("nep141:")) return "NEAR";
          if (asset.includes("sol:")) return "Solana";
          if (asset.includes("eth:")) return "Ethereum";
          if (asset.includes("polygon:")) return "Polygon";
          if (asset.includes("arbitrum:")) return "Arbitrum";

          // Check for specific token patterns
          if (asset.includes("wrap.near") || asset.includes("NEAR (NEAR)"))
            return "NEAR";
          if (asset.includes("SOL (Solana)") || asset.includes("sol-"))
            return "Solana";
          if (asset.includes("(ETH)") || asset.includes("(Ethereum)"))
            return "Ethereum";
          if (asset.includes("(Polygon)")) return "Polygon";
          if (asset.includes("(Arbitrum)")) return "Arbitrum";

          // Default to Ethereum for most tokens
          return "Ethereum";
        }

        getDestinationChainFromAsset(asset) {
          // Check for explicit chain prefixes first
          if (asset.includes("nep141:")) return "NEAR";
          if (asset.includes("sol:")) return "Solana";
          if (asset.includes("eth:")) return "Ethereum";
          if (asset.includes("polygon:")) return "Polygon";
          if (asset.includes("arbitrum:")) return "Arbitrum";

          // Check for specific token patterns
          if (asset.includes("wrap.near") || asset.includes("NEAR (NEAR)"))
            return "NEAR";
          if (asset.includes("SOL (Solana)") || asset.includes("sol-"))
            return "Solana";
          if (asset.includes("(ETH)") || asset.includes("(Ethereum)"))
            return "Ethereum";
          if (asset.includes("(Polygon)")) return "Polygon";
          if (asset.includes("(Arbitrum)")) return "Arbitrum";

          // Default to Ethereum for most tokens
          return "Ethereum";
        }

        async executeNearSwapFromInterface() {
          const fromToken = document.getElementById("nearFromToken");
          const toToken = document.getElementById("nearToToken");
          const amount = document.getElementById("nearAmount");
          const recipient = document.getElementById("nearRecipient");
          const slippage = document.getElementById("nearSlippage");

          if (!fromToken || !toToken || !amount || !recipient || !slippage) {
            this.log("Swap interface not found. Please try again.", "error");
            return;
          }

          const originAsset = fromToken.value;
          const destinationAsset = toToken.value;
          const amountValue = parseFloat(amount.value);
          const recipientAddress = recipient.value.trim();
          const slippageBps = parseInt(slippage.value);

          if (
            !originAsset ||
            !destinationAsset ||
            isNaN(amountValue) ||
            !recipientAddress ||
            isNaN(slippageBps)
          ) {
            this.log("Please fill in all fields with valid values.", "error");
            return;
          }

          // Validate and format recipient address based on destination chain
          let formattedRecipient = recipientAddress;
          let refundAddress = recipientAddress;

          // Determine destination chain from asset
          const destinationChain =
            this.getDestinationChainFromAsset(destinationAsset);
          const originChain = this.getOriginChainFromAsset(originAsset);

          // Debug logging
          this.log(
            `Debug: Origin asset "${originAsset}" detected as ${originChain}`,
            "info"
          );
          this.log(
            `Debug: Destination asset "${destinationAsset}" detected as ${destinationChain}`,
            "info"
          );

          // Format addresses based on chain
          if (destinationChain === "NEAR") {
            // NEAR addresses should be in format: account.near or account.testnet
            if (
              !recipientAddress.includes(".near") &&
              !recipientAddress.includes(".testnet")
            ) {
              this.log(
                "For NEAR destination, recipient should be in format: account.near",
                "error"
              );
              this.log("Example: myaccount.near or myaccount.testnet", "info");
              this.log(
                "Note: Even though the token shows (ETH), it's wrapped on NEAR chain",
                "info"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          } else if (
            destinationChain === "Ethereum" ||
            destinationChain === "Polygon" ||
            destinationChain === "Arbitrum"
          ) {
            // EVM addresses should be 0x format
            if (
              !recipientAddress.startsWith("0x") ||
              recipientAddress.length !== 42
            ) {
              this.log(
                "For EVM chains, recipient should be a valid 0x address",
                "error"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          } else if (destinationChain === "Solana") {
            // Solana addresses should be base58 format
            if (recipientAddress.length < 32 || recipientAddress.length > 44) {
              this.log(
                "For Solana destination, recipient should be a valid Solana address",
                "error"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          }

          if (originAsset === destinationAsset) {
            this.log("Cannot swap the same token.", "error");
            return;
          }

          if (amountValue <= 0) {
            this.log("Amount must be greater than 0.", "error");
            return;
          }

          // Get token info for display
          const fromTokenElement = document.querySelector(
            '#nearFromTokenDropdown .dropdown-item[data-value="' +
              originAsset +
              '"]'
          );
          const toTokenElement = document.querySelector(
            '#nearToTokenDropdown .dropdown-item[data-value="' +
              destinationAsset +
              '"]'
          );
          const fromSymbol = fromTokenElement
            ? fromTokenElement.getAttribute("data-symbol")
            : "Unknown";
          const toSymbol = toTokenElement
            ? toTokenElement.getAttribute("data-symbol")
            : "Unknown";

          this.log(
            `Starting Near Intents swap: ${amountValue} ${fromSymbol} ‚Üí ${toSymbol}`,
            "info"
          );
          this.log(`Recipient: ${recipientAddress}`, "info");
          this.log(`Slippage: ${slippageBps / 100}%`, "info");

          try {
            // Step 1: Get quote
            this.log("Getting quote...", "info");
            const quotePayload = {
              dry: false, // Real swap
              swapType: "EXACT_INPUT",
              slippageTolerance: slippageBps,
              originAsset,
              depositType: "ORIGIN_CHAIN",
              destinationAsset,
              amount: amountValue.toString(),
              refundTo: refundAddress,
              refundType: "ORIGIN_CHAIN",
              recipient: formattedRecipient,
              recipientType: "DESTINATION_CHAIN",
              deadline: new Date(
                Date.now() + 24 * 60 * 60 * 1000
              ).toISOString(),
              quoteWaitingTimeMs: 3000,
            };

            const quoteResponse = await fetch(
              "https://1click.chaindefuser.com/v0/quote",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(quotePayload),
              }
            );

            if (!quoteResponse.ok) {
              const errorText = await quoteResponse.text();
              this.log(`Quote failed: HTTP ${quoteResponse.status}`, "error");
              this.log(`Error details: ${errorText}`, "error");
              return;
            }

            const quoteData = await quoteResponse.json();
            this.log(`‚úÖ Quote received!`, "success");
            this.log(
              `Input: ${quoteData.quote.amountInFormatted} ${fromSymbol}`,
              "info"
            );
            this.log(
              `Output: ${quoteData.quote.amountOutFormatted} ${toSymbol}`,
              "info"
            );
            this.log(
              `Deposit Address: ${quoteData.quote.depositAddress}`,
              "info"
            );
            this.log(
              `Deadline: ${new Date(
                quoteData.quote.deadline
              ).toLocaleString()}`,
              "info"
            );

            // Store swap info for status checking
            window.nearSwapInfo = {
              depositAddress: quoteData.quote.depositAddress,
              originAsset,
              destinationAsset,
              amount: amountValue.toString(),
              recipient: recipientAddress,
              timestamp: Date.now(),
            };

            this.log(
              `<br><b>‚ö†Ô∏è IMPORTANT:</b> Send ${quoteData.quote.amountInFormatted} ${fromSymbol} to:`,
              "warning"
            );
            this.log(`<b>${quoteData.quote.depositAddress}</b>`, "info");
            this.log(
              `<br>Use <b>near status ${quoteData.quote.depositAddress}</b> to check swap progress`,
              "info"
            );
          } catch (e) {
            this.log(`Swap failed: ${e.message}`, "error");
          }
        }

        // Polymarket Prediction Market Functions
        async getPolymarketMarkets() {
          try {
            this.log("Fetching Polymarket prediction markets...", "info");

            // Try multiple API endpoints
            let data = null;
            let response = null;

            // Try the main API first
            try {
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=20",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Primary API failed, trying alternative...", "warning");
            }

            // If primary failed, try alternative endpoint
            if (!data) {
              try {
                response = await fetch("https://clob.polymarket.com/markets", {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                });

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e) {
                this.log("Alternative API also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              let html = `<b>üîÆ Polymarket Prediction Markets (${data.length} shown)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

              data.forEach((market, index) => {
                const status = market.active
                  ? "üü¢ Active"
                  : market.closed
                  ? "üî¥ Closed"
                  : "üü° Archived";
                const endDate = market.end_date_iso
                  ? new Date(market.end_date_iso).toLocaleDateString()
                  : "N/A";
                const outcomes = market.tokens
                  ? market.tokens.map((t) => t.outcome).join(" / ")
                  : "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  market.question || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'>${status}</td>`;
                html += `<td style='padding:8px;'>${endDate}</td>`;
                html += `<td style='padding:8px;'>${outcomes}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;
              html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
              this.logHtml(html, "output");
            } else if (data && typeof data === "object") {
              // Handle different response formats
              const markets = data.markets || data.data || data.results || [];
              if (Array.isArray(markets) && markets.length > 0) {
                let html = `<b>üîÆ Polymarket Prediction Markets (${markets.length} shown)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                markets.forEach((market, index) => {
                  const status = market.active
                    ? "üü¢ Active"
                    : market.closed
                    ? "üî¥ Closed"
                    : "üü° Archived";
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${status}</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
                this.logHtml(html, "output");
              } else {
                this.log("No markets found in response.", "warning");
                this.log(
                  `Response structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            } else {
              this.log(
                "No markets found or invalid response format.",
                "warning"
              );
              if (response) {
                this.log(`HTTP Status: ${response.status}`, "info");
                const text = await response.text();
                this.log(`Response: ${text.substring(0, 200)}...`, "info");
              }
            }
          } catch (e) {
            this.log(
              `Failed to fetch Polymarket markets: ${e.message}`,
              "error"
            );
            this.log(
              "This might be due to CORS restrictions or API changes.",
              "info"
            );

            // Show sample data for demonstration
            this.log(
              "Showing sample Polymarket data for demonstration:",
              "info"
            );
            const sampleMarkets = [
              {
                question: "Will Bitcoin reach $100,000 by end of 2024?",
                active: true,
                end_date_iso: "2024-12-31T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
              {
                question: "Will Ethereum 2.0 launch before June 2024?",
                active: true,
                end_date_iso: "2024-06-30T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
              {
                question: "Will the US have a recession in 2024?",
                active: true,
                end_date_iso: "2024-12-31T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
            ];

            let html = `<b>üîÆ Sample Polymarket Prediction Markets (Demo)</b><br>`;
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            sampleMarkets.forEach((market, index) => {
              const status = market.active ? "üü¢ Active" : "üî¥ Closed";
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'>${status}</td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;
            html += `<br><small>Note: This is sample data. Real API access requires server-side proxy due to CORS restrictions.</small>`;
            this.logHtml(html, "output");
          }
        }

        async getPolymarketLiveMarkets() {
          try {
            this.log("Fetching live Polymarket prediction markets...", "info");

            let data = null;
            let response = null;

            try {
              // Use the same approach as active markets but with different endpoint
              this.log(
                "Attempting API call to Polymarket live markets...",
                "info"
              );
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (!response.ok) {
                // Try with CORS proxy
                this.log("Direct API failed, trying CORS proxy...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try alternative CORS proxy
                this.log(
                  "First CORS proxy failed, trying alternative...",
                  "info"
                );
                response = await fetch(
                  "https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
                throw new Error(`API returned status: ${response.status}`);
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              // Handle object response format (same as active markets)
              this.log("Processing live markets response format...", "info");

              // Handle GraphQL response format
              let markets = [];
              if (data.data && data.data.markets) {
                markets = data.data.markets;
                this.log("Processing GraphQL response format...", "info");
              } else {
                markets = data.markets || data.data || data.results || [];
                this.log("Processing REST API response format...", "info");
              }

              this.log(`Found ${markets.length} live markets`, "info");

              // Filter for active markets
              let liveMarkets = markets.filter((market) => {
                if (
                  !market.active ||
                  !market.question ||
                  !market.tokens ||
                  market.tokens.length === 0
                ) {
                  return false;
                }

                // Check if market is still open
                if (market.end_date_iso) {
                  const endDate = new Date(market.end_date_iso);
                  const now = new Date();
                  const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);

                  // Only include markets that haven't ended or ended within the last 7 days
                  if (daysDiff < -7) {
                    return false;
                  }
                }

                return true;
              });

              this.log(
                `Found ${liveMarkets.length} truly live markets`,
                "info"
              );

              if (liveMarkets.length > 0) {
                const displayMarkets = liveMarkets.slice(0, 20);

                let html = `<b>üü¢ Live Polymarket Prediction Markets (${liveMarkets.length} total, showing first 20)</b><br>`;

                // Add category filter buttons
                html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                html += `<b>Quick Filters:</b> `;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${liveMarkets.length})</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                html += `</div>`;

                // Add search box
                html += `<div style='margin: 10px 0;'>`;
                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                html += `</div>`;

                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                displayMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const category = this.getMarketCategory(
                    market.question || ""
                  );

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;

                // Store markets for filtering
                window.polymarketActiveMarkets = liveMarkets;

                this.logHtml(html, "output");

                // Add search functionality
                this.setupPolymarketSearch();
              } else {
                this.log("No live markets found.", "warning");
              }
            } else {
              this.log("No valid data received for live markets.", "warning");
            }
          } catch (e) {
            this.log(
              `Failed to fetch live Polymarket markets: ${e.message}`,
              "error"
            );
          }
        }

        async getPolymarketRecentMarkets() {
          try {
            this.log(
              "Fetching recent Polymarket prediction markets (last 30 days)...",
              "info"
            );

            let data = null;
            let response = null;

            try {
              // Try to get recent markets with different parameters
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=1000&sort=created_at&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              const markets = data.markets || data.data || data.results || [];
              this.log(`Found ${markets.length} total markets`, "info");

              // Filter for markets created in the last 30 days
              const thirtyDaysAgo = new Date();
              thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

              let recentMarkets = markets.filter((market) => {
                if (
                  !market.active ||
                  !market.question ||
                  !market.tokens ||
                  market.tokens.length === 0
                ) {
                  return false;
                }

                // Check creation date if available
                if (market.created_at) {
                  const createdDate = new Date(market.created_at);
                  return createdDate >= thirtyDaysAgo;
                }

                // If no creation date, check end date (must be in the future or recent past)
                if (market.end_date_iso) {
                  const endDate = new Date(market.end_date_iso);
                  const now = new Date();
                  const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);
                  return daysDiff > -30; // Within 30 days of end date
                }

                return true; // Include if no date info available
              });

              this.log(
                `Found ${recentMarkets.length} recent markets (last 30 days)`,
                "info"
              );

              if (recentMarkets.length > 0) {
                const displayMarkets = recentMarkets.slice(0, 20);

                let html = `<b>üü¢ Recent Polymarket Prediction Markets (${recentMarkets.length} total, showing first 20)</b><br>`;

                // Add category filter buttons
                html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                html += `<b>Quick Filters:</b> `;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${recentMarkets.length})</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                html += `</div>`;

                // Add search box
                html += `<div style='margin: 10px 0;'>`;
                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                html += `</div>`;

                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                displayMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const category = this.getMarketCategory(
                    market.question || ""
                  );

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;

                // Store markets for filtering
                window.polymarketActiveMarkets = recentMarkets;

                this.logHtml(html, "output");

                // Add search functionality
                this.setupPolymarketSearch();
              } else {
                this.log("No recent markets found.", "warning");
              }
            } else {
              this.log("No valid data received for recent markets.", "warning");
            }
          } catch (e) {
            this.log(
              `Failed to fetch recent Polymarket markets: ${e.message}`,
              "error"
            );
          }
        }

        async getPolymarketActiveMarkets() {
          try {
            this.log(
              "Fetching active Polymarket prediction markets...",
              "info"
            );

            let data = null;
            let response = null;

            try {
              // Try direct API call first (might work in some browsers)
              this.log("Attempting direct API call to Polymarket...", "info");
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (!response.ok) {
                // Try with different CORS proxy
                this.log("Direct API failed, trying CORS proxy...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try another CORS proxy
                this.log(
                  "First CORS proxy failed, trying alternative...",
                  "info"
                );
                response = await fetch(
                  "https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try Polymarket's public API
                this.log("CORS proxies failed, trying public API...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api.polymarket.com/markets?limit=200&status=open",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
                throw new Error(`API returned status: ${response.status}`);
              }

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
                this.log(
                  `Total markets received: ${
                    Array.isArray(data) ? data.length : "N/A"
                  }`,
                  "info"
                );
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              // Handle object response format (this is what the API actually returns)
              this.log("Processing object response format...", "info");
              this.log(`Object keys: ${Object.keys(data).join(", ")}`, "info");

              // Handle GraphQL response format
              let markets = [];
              if (data.data && data.data.markets) {
                markets = data.data.markets;
                this.log("Processing GraphQL response format...", "info");
              } else {
                markets = data.markets || data.data || data.results || [];
                this.log("Processing REST API response format...", "info");
              }

              this.log(`Found ${markets.length} markets in object`, "info");

              if (markets.length > 0) {
                this.log(
                  `Processing ${markets.length} markets from API...`,
                  "info"
                );

                // Filter for truly active markets with strict date checking
                let activeMarkets = markets.filter((market) => {
                  // Must be active
                  if (!market.active) {
                    return false;
                  }

                  // Must have valid question and tokens
                  if (
                    !market.question ||
                    !market.tokens ||
                    market.tokens.length === 0
                  ) {
                    return false;
                  }

                  // Check if market has ended - only show markets that haven't ended or ended very recently
                  if (market.end_date_iso) {
                    const endDate = new Date(market.end_date_iso);
                    const now = new Date();
                    const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);

                    // Only include markets that haven't ended or ended within the last 7 days
                    if (daysDiff < -7) {
                      return false;
                    }
                  }

                  return true;
                });

                this.log(
                  `Found ${activeMarkets.length} truly active markets after filtering`,
                  "info"
                );

                // If no active markets found, try to get some recent ones
                if (activeMarkets.length === 0) {
                  this.log(
                    "No active markets found, looking for recent markets...",
                    "info"
                  );
                  activeMarkets = markets
                    .filter(
                      (market) =>
                        market.active &&
                        market.question &&
                        market.tokens &&
                        market.tokens.length > 0
                    )
                    .slice(0, 20);

                  this.log(
                    `Found ${activeMarkets.length} recent markets as fallback`,
                    "info"
                  );
                }

                if (activeMarkets.length > 0) {
                  // Limit to first 20 markets for better readability
                  const displayMarkets = activeMarkets.slice(0, 20);

                  let html = `<b>üü¢ Active Polymarket Prediction Markets (${activeMarkets.length} total, showing first 20)</b><br>`;

                  // Add category filter buttons
                  html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                  html += `<b>Quick Filters:</b> `;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${activeMarkets.length})</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                  html += `</div>`;

                  // Add search box
                  html += `<div style='margin: 10px 0;'>`;
                  html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                  html += `</div>`;

                  html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                  html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                  displayMarkets.forEach((market, index) => {
                    const endDate = market.end_date_iso
                      ? new Date(market.end_date_iso).toLocaleDateString()
                      : "N/A";
                    const outcomes = market.tokens
                      ? market.tokens.map((t) => t.outcome).join(" / ")
                      : "N/A";
                    const category = this.getMarketCategory(
                      market.question || ""
                    );

                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${
                      market.question || "N/A"
                    }</td>`;
                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                    html += `<td style='padding:8px;'>${endDate}</td>`;
                    html += `<td style='padding:8px;'>${outcomes}</td>`;
                    html += `</tr>`;
                  });

                  html += `</table>`;

                  // Add "Show More" button if there are more results
                  if (activeMarkets.length > 20) {
                    html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                      activeMarkets.length - 20
                    } remaining)</button>`;
                  }

                  // Store markets for filtering
                  window.polymarketActiveMarkets = activeMarkets;

                  this.logHtml(html, "output");

                  // Add search functionality
                  this.setupPolymarketSearch();
                } else {
                  this.log(
                    "No active markets found after filtering.",
                    "warning"
                  );
                }
              } else {
                this.log("No markets found in object response.", "warning");
                this.log(
                  `Debug: Data structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            } else if (data && Array.isArray(data)) {
              // Handle direct array response (fallback)
              this.log(
                `Processing array response format with ${data.length} markets...`,
                "info"
              );

              // Filter for truly active markets with better date checking
              let activeMarkets = data.filter((market) => {
                // Debug: Log what we're checking
                const endDate = market.end_date_iso
                  ? new Date(market.end_date_iso)
                  : null;
                const now = new Date();
                const daysDiff = endDate
                  ? (now - endDate) / (1000 * 60 * 60 * 24)
                  : 0;

                // Must be active (but allow closed markets if they're recent)
                if (!market.active) {
                  this.log(`Filtered out: not active`, "info");
                  return false;
                }

                // Additional checks for market validity
                if (market.tokens && market.tokens.length === 0) {
                  this.log(`Filtered out: no tokens`, "info");
                  return false;
                }
                if (!market.question || market.question.trim() === "") {
                  this.log(`Filtered out: no question`, "info");
                  return false;
                }

                // Check if market has ended - but be very lenient (90 days)
                if (market.end_date_iso) {
                  if (endDate < now) {
                    if (daysDiff > 90) {
                      this.log(
                        `Filtered out: ended ${daysDiff.toFixed(0)} days ago`,
                        "info"
                      );
                      return false;
                    }
                  }
                }

                return true;
              });

              this.log(
                `Found ${activeMarkets.length} truly active markets after date filtering`,
                "info"
              );
              this.log(
                `Found ${activeMarkets.length} active markets after filtering`,
                "info"
              );

              if (activeMarkets.length > 0) {
                let html = `<b>üü¢ Active Polymarket Prediction Markets (${activeMarkets.length} found)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th><th style='padding:8px;text-align:left;'>Min Order</th></tr>`;

                activeMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const minOrder = market.minimum_order_size
                    ? `$${market.minimum_order_size}`
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `<td style='padding:8px;'>${minOrder}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                this.logHtml(html, "output");
              } else {
                this.log("No active markets found.", "warning");
              }
            } else {
              this.log("No valid data received.", "warning");
              if (data) {
                this.log(`Debug: Received data type: ${typeof data}`, "info");
                this.log(
                  `Debug: Data structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            }
          } catch (e) {
            this.log(
              `Failed to fetch active Polymarket markets: ${e.message}`,
              "error"
            );
            this.log(
              "This might be due to CORS restrictions or API changes.",
              "info"
            );
          }
        }

        // Helper function to categorize markets
        getMarketCategory(question) {
          const q = question.toLowerCase();

          // Sports categories
          if (
            q.includes("nfl") ||
            q.includes("nba") ||
            q.includes("mlb") ||
            q.includes("nhl") ||
            q.includes("soccer") ||
            q.includes("football") ||
            q.includes("basketball") ||
            q.includes("baseball") ||
            q.includes("hockey") ||
            q.includes("ufc") ||
            q.includes("boxing") ||
            q.includes("tennis") ||
            q.includes("golf") ||
            q.includes("champion") ||
            q.includes("vs") ||
            q.includes("beat") ||
            q.includes("super bowl") ||
            q.includes("playoff") ||
            q.includes("final") ||
            q.includes("league") ||
            q.includes("cup") ||
            q.includes("tournament")
          ) {
            return "Sports";
          }

          // Politics categories
          if (
            q.includes("election") ||
            q.includes("president") ||
            q.includes("biden") ||
            q.includes("trump") ||
            q.includes("congress") ||
            q.includes("senate") ||
            q.includes("house") ||
            q.includes("democrat") ||
            q.includes("republican") ||
            q.includes("state of the union") ||
            q.includes("hearing") ||
            q.includes("secretary") ||
            q.includes("campaign") ||
            q.includes("vote") ||
            q.includes("poll") ||
            q.includes("government") ||
            q.includes("policy") ||
            q.includes("law")
          ) {
            return "Politics";
          }

          // Entertainment categories
          if (
            q.includes("movie") ||
            q.includes("film") ||
            q.includes("box office") ||
            q.includes("gross") ||
            q.includes("oscar") ||
            q.includes("award") ||
            q.includes("tv") ||
            q.includes("television") ||
            q.includes("show") ||
            q.includes("album") ||
            q.includes("music") ||
            q.includes("concert") ||
            q.includes("actor") ||
            q.includes("actress") ||
            q.includes("director") ||
            q.includes("streaming") ||
            q.includes("netflix") ||
            q.includes("disney")
          ) {
            return "Entertainment";
          }

          // Crypto categories - Much more comprehensive
          if (
            q.includes("bitcoin") ||
            q.includes("ethereum") ||
            q.includes("crypto") ||
            q.includes("token") ||
            q.includes("coin") ||
            q.includes("blockchain") ||
            q.includes("defi") ||
            q.includes("nft") ||
            q.includes("airdrop") ||
            q.includes("btc") ||
            q.includes("eth") ||
            q.includes("sol") ||
            q.includes("solana") ||
            q.includes("xrp") ||
            q.includes("ripple") ||
            q.includes("dogecoin") ||
            q.includes("doge") ||
            q.includes("cardano") ||
            q.includes("ada") ||
            q.includes("polkadot") ||
            q.includes("dot") ||
            q.includes("chainlink") ||
            q.includes("link") ||
            q.includes("uniswap") ||
            q.includes("uni") ||
            q.includes("opensea") ||
            q.includes("blur") ||
            q.includes("pump.fun") ||
            q.includes("price") ||
            q.includes("market cap") ||
            q.includes("fdv") ||
            q.includes("merge") ||
            q.includes("eip") ||
            q.includes("upgrade") ||
            q.includes("wallet") ||
            q.includes("exchange") ||
            q.includes("dex") ||
            q.includes("staking") ||
            q.includes("yield") ||
            q.includes("liquidity") ||
            q.includes("dao") ||
            q.includes("governance") ||
            q.includes("protocol")
          ) {
            return "Crypto";
          }

          // Economy categories
          if (
            q.includes("inflation") ||
            q.includes("recession") ||
            q.includes("gdp") ||
            q.includes("unemployment") ||
            q.includes("fed") ||
            q.includes("interest rate") ||
            q.includes("economy") ||
            q.includes("market") ||
            q.includes("stock") ||
            q.includes("dollar") ||
            q.includes("currency") ||
            q.includes("trade") ||
            q.includes("tariff") ||
            q.includes("tax") ||
            q.includes("debt") ||
            q.includes("bond") ||
            q.includes("treasury") ||
            q.includes("central bank")
          ) {
            return "Economy";
          }

          return "Other";
        }

        // Filter markets by category
        filterPolymarketMarkets(category) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available for filtering.", "warning");
            return;
          }

          let filteredMarkets = window.polymarketActiveMarkets;

          if (category !== "all") {
            // Convert category to proper case for comparison
            const categoryMap = {
              sports: "Sports",
              politics: "Politics",
              entertainment: "Entertainment",
              crypto: "Crypto",
              economy: "Economy",
            };
            const targetCategory = categoryMap[category] || category;

            filteredMarkets = window.polymarketActiveMarkets.filter(
              (market) =>
                this.getMarketCategory(market.question || "") === targetCategory
            );
          }

          // Display filtered results
          const displayMarkets = filteredMarkets.slice(0, 20);

          let html = `<b>üü¢ ${
            category.charAt(0).toUpperCase() + category.slice(1)
          } Markets (${
            filteredMarkets.length
          } total, showing first 20)</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are more results
            if (filteredMarkets.length > 20) {
              html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - 20
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found in this category.</p>`;
          }

          this.logHtml(html, "output");
        }

        // Show more markets for a category
        showMorePolymarketMarkets(category, currentCount) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available.", "warning");
            return;
          }

          let filteredMarkets = window.polymarketActiveMarkets;

          if (category !== "all") {
            // Convert category to proper case for comparison
            const categoryMap = {
              sports: "Sports",
              politics: "Politics",
              entertainment: "Entertainment",
              crypto: "Crypto",
              economy: "Economy",
            };
            const targetCategory = categoryMap[category] || category;

            filteredMarkets = window.polymarketActiveMarkets.filter(
              (market) =>
                this.getMarketCategory(market.question || "") === targetCategory
            );
          }

          // Show next batch of results
          const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
          const displayMarkets = filteredMarkets.slice(0, nextBatch);

          let html = `<b>üü¢ ${
            category.charAt(0).toUpperCase() + category.slice(1)
          } Markets (${
            filteredMarkets.length
          } total, showing ${nextBatch})</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < filteredMarkets.length) {
              html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found in this category.</p>`;
          }

          this.logHtml(html, "output");
        }

        // Search within displayed markets
        searchPolymarketResults(query) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available for search.", "warning");
            return;
          }

          // If query is empty, show all markets
          if (!query || !query.trim()) {
            this.filterPolymarketMarkets("all");
            return;
          }

          const filteredMarkets = window.polymarketActiveMarkets.filter(
            (market) =>
              market.question &&
              market.question.toLowerCase().includes(query.toLowerCase())
          );

          const displayMarkets = filteredMarkets.slice(0, 20);

          let html = `<b>üîç Search Results for "${query}" (${filteredMarkets.length} found, showing first 20)</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const category = this.getMarketCategory(market.question || "");

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are more results
            if (filteredMarkets.length > 20) {
              html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - 20
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found matching "${query}".</p>`;
          }

          this.logHtml(html, "output");
        }

        // Show more all markets
        showMoreAllPolymarketMarkets(currentCount) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available.", "warning");
            return;
          }

          // Show next batch of results
          const nextBatch = Math.min(
            currentCount + 20,
            window.polymarketActiveMarkets.length
          );
          const displayMarkets = window.polymarketActiveMarkets.slice(
            0,
            nextBatch
          );

          let html = `<b>üü¢ Active Polymarket Prediction Markets (${window.polymarketActiveMarkets.length} total, showing ${nextBatch})</b><br>`;

          // Add category filter buttons
          html += `<div style='margin: 10px 0;'><b>Quick Filters:</b><br>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${window.polymarketActiveMarkets.length})</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
          html += `</div>`;

          // Add search box
          html += `<div style='margin: 10px 0;'>`;
          html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
          html += `<br><small style="color: #666;">Type to search markets (e.g., "bitcoin", "election", "nfl")</small>`;
          html += `</div>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < window.polymarketActiveMarkets.length) {
              html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                window.polymarketActiveMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found.</p>`;
          }

          this.logHtml(html, "output");

          // Re-add search functionality
          this.setupPolymarketSearch();
        }

        // Setup search functionality for Polymarket
        setupPolymarketSearch() {
          // Since we're using inline event handlers, this function is now simplified
          // The search functionality is handled directly by the oninput attribute
          console.log("Polymarket search functionality ready");

          // Add a test button to help debug search issues
          setTimeout(() => {
            const searchBox = document.getElementById("polymarketSearch");
            if (searchBox) {
              // Add a test button next to the search box
              const testButton = document.createElement("button");
              testButton.textContent = "Test Search";
              testButton.style.cssText =
                "margin-left: 10px; padding: 4px 8px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;";
              testButton.onclick = () => {
                this.log("Testing search functionality...", "info");
                this.searchPolymarketResults("bitcoin");
              };
              searchBox.parentNode.insertBefore(
                testButton,
                searchBox.nextSibling
              );
            }
          }, 1000);
        }

        // Show more search results
        showMoreSearchResults(query, currentCount) {
          if (!window.polymarketActiveMarkets || !query.trim()) {
            return;
          }

          const filteredMarkets = window.polymarketActiveMarkets.filter(
            (market) =>
              market.question &&
              market.question.toLowerCase().includes(query.toLowerCase())
          );

          // Show next batch of results
          const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
          const displayMarkets = filteredMarkets.slice(0, nextBatch);

          let html = `<b>üîç Search Results for "${query}" (${filteredMarkets.length} found, showing ${nextBatch})</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const category = this.getMarketCategory(market.question || "");

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < filteredMarkets.length) {
              html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found matching "${query}".</p>`;
          }

          this.logHtml(html, "output");
        }

        async searchPolymarketMarkets(query) {
          try {
            this.log(`Searching Polymarket markets for: "${query}"`, "info");

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://clob.polymarket.com/markets?limit=50`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("API request failed", "warning");
            }

            if (data && Array.isArray(data)) {
              const searchResults = data.filter(
                (market) =>
                  (market.question &&
                    market.question
                      .toLowerCase()
                      .includes(query.toLowerCase())) ||
                  (market.description &&
                    market.description
                      .toLowerCase()
                      .includes(query.toLowerCase())) ||
                  (market.tags &&
                    market.tags.some((tag) =>
                      tag.toLowerCase().includes(query.toLowerCase())
                    ))
              );

              if (searchResults.length > 0) {
                let html = `<b>üîç Polymarket Search Results for "${query}" (${searchResults.length} found)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                searchResults.slice(0, 10).forEach((market, index) => {
                  const status = market.active
                    ? "üü¢ Active"
                    : market.closed
                    ? "üî¥ Closed"
                    : "üü° Archived";
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${status}</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                if (searchResults.length > 10) {
                  html += `<br><small>Showing first 10 results. Use more specific search terms to narrow results.</small>`;
                }
                this.logHtml(html, "output");
              } else {
                this.log(`No markets found matching "${query}"`, "warning");
              }
            } else {
              this.log("Failed to fetch markets for search.", "error");
            }
          } catch (e) {
            this.log(`Search failed: ${e.message}`, "error");
          }
        }

        async getPolymarketMarketDetails(marketId) {
          try {
            this.log(
              `Fetching details for Polymarket market: ${marketId}`,
              "info"
            );

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://clob.polymarket.com/markets?limit=100`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("API request failed", "warning");
            }

            if (data && Array.isArray(data)) {
              // Try to find market by ID or slug
              const market = data.find(
                (m) =>
                  m.condition_id === marketId ||
                  m.question_id === marketId ||
                  m.market_slug === marketId ||
                  (m.question &&
                    m.question.toLowerCase().includes(marketId.toLowerCase()))
              );

              if (market) {
                let html = `<b>üîÆ Polymarket Market Details</b><br>`;
                html += `<div style='background:#222;padding:15px;border-radius:5px;margin:10px 0;'>`;
                html += `<b>Question:</b> ${market.question || "N/A"}<br>`;
                html += `<b>Description:</b> ${
                  market.description
                    ? market.description.substring(0, 200) + "..."
                    : "N/A"
                }<br>`;
                html += `<b>Status:</b> ${
                  market.active
                    ? "üü¢ Active"
                    : market.closed
                    ? "üî¥ Closed"
                    : "üü° Archived"
                }<br>`;
                html += `<b>End Date:</b> ${
                  market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleString()
                    : "N/A"
                }<br>`;
                html += `<b>Minimum Order:</b> ${
                  market.minimum_order_size
                    ? `$${market.minimum_order_size}`
                    : "N/A"
                }<br>`;
                html += `<b>Accepting Orders:</b> ${
                  market.accepting_orders ? "Yes" : "No"
                }<br>`;
                html += `</div>`;

                if (market.tokens && market.tokens.length > 0) {
                  html += `<b>Outcomes:</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;margin:10px 0;'>`;
                  html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Outcome</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Winner</th></tr>`;

                  market.tokens.forEach((token) => {
                    const price =
                      token.price !== undefined ? `$${token.price}` : "N/A";
                    const winner = token.winner ? "üèÜ Yes" : "No";

                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${
                      token.outcome || "N/A"
                    }</td>`;
                    html += `<td style='padding:8px;'>${price}</td>`;
                    html += `<td style='padding:8px;'>${winner}</td>`;
                    html += `</tr>`;
                  });

                  html += `</table>`;
                }

                if (market.tags && market.tags.length > 0) {
                  html += `<b>Tags:</b> ${market.tags.join(", ")}<br>`;
                }

                this.logHtml(html, "output");
              } else {
                this.log(`Market not found: ${marketId}`, "error");
                this.log(
                  'Try using "polymarket markets" to see available markets',
                  "info"
                );
              }
            } else {
              this.log("Failed to fetch market details.", "error");
            }
          } catch (e) {
            this.log(`Failed to fetch market details: ${e.message}`, "error");
          }
        }

        // Magic Eden NFT Marketplace Functions
        async getMagicEdenCollections() {
          try {
            this.log("Fetching Magic Eden collections...", "info");

            let data = null;
            let response = null;

            try {
              response = await fetch(
                "https://api-mainnet.magiceden.dev/v2/collections",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log("Proxy request also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              const collections = data.slice(0, 20); // Show first 20

              let html = `<b>üé® Magic Eden Collections (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;

              collections.forEach((collection, index) => {
                const floorPrice = collection.floorPrice
                  ? `${collection.floorPrice} SOL`
                  : "N/A";
                const listed = collection.listedCount || "N/A";
                const supply = collection.supply || "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  collection.name || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
                  collection.symbol || "N/A"
                }</span></td>`;
                html += `<td style='padding:8px;'>${floorPrice}</td>`;
                html += `<td style='padding:8px;'>${listed}</td>`;
                html += `<td style='padding:8px;'>${supply}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenCollections = data;
            } else {
              this.log("Failed to fetch Magic Eden collections.", "error");
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden collections: ${e.message}`,
              "error"
            );
          }
        }

        async getMagicEdenPopularCollections() {
          try {
            this.log("Fetching Magic Eden popular collections...", "info");

            let data = null;
            let response = null;

            try {
              // Try the collections endpoint with sorting by volume
              response = await fetch(
                "https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log(
                  "First proxy failed, trying second proxy...",
                  "warning"
                );
                try {
                  response = await fetch(
                    "https://thingproxy.freeboard.io/fetch/https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                    {
                      method: "GET",
                      headers: {
                        Accept: "application/json",
                      },
                    }
                  );

                  if (response.ok) {
                    data = await response.json();
                  }
                } catch (e3) {
                  this.log(
                    "All proxies failed, trying popular collections as fallback",
                    "warning"
                  );
                  try {
                    response = await fetch(
                      "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/marketplace/popular_collections",
                      {
                        method: "GET",
                        headers: {
                          Accept: "application/json",
                        },
                      }
                    );

                    if (response.ok) {
                      data = await response.json();
                    }
                  } catch (e4) {
                    this.log("All API requests failed", "error");
                  }
                }
              }
            }

            if (data && Array.isArray(data)) {
              const collections = data.slice(0, 20); // Show first 20

              // Fetch stats for each collection to get volume and listed count
              this.log(
                "Fetching detailed stats for each collection...",
                "info"
              );

              const collectionsWithStats = await Promise.all(
                collections.map(async (collection) => {
                  try {
                    let statsResponse = await fetch(
                      `https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`,
                      {
                        method: "GET",
                        headers: {
                          Accept: "application/json",
                          "User-Agent":
                            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                        },
                      }
                    );

                    if (!statsResponse.ok) {
                      // Try proxy if direct request fails
                      statsResponse = await fetch(
                        `https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`,
                        {
                          method: "GET",
                          headers: {
                            Accept: "application/json",
                          },
                        }
                      );
                    }

                    if (statsResponse.ok) {
                      const stats = await statsResponse.json();
                      console.log(`Stats for ${collection.symbol}:`, stats); // Debug log
                      return {
                        ...collection,
                        volume1d: stats.volumeAll, // Use volumeAll for 24h volume
                        listedCount: stats.listedCount,
                        floorPrice: stats.floorPrice, // Use floor price from stats
                      };
                    }
                  } catch (e) {
                    // If stats fetch fails, continue with original data
                    console.log(
                      `Failed to fetch stats for ${collection.symbol}:`,
                      e.message
                    );
                  }
                  return collection;
                })
              );

              let html = `<b>üî• Magic Eden Popular Collections (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume (24h)</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;

              collectionsWithStats.forEach((collection, index) => {
                // Convert to SOL - API returns values in a different unit
                // Based on the API response, it seems like values might be in a smaller unit
                const floorPrice = collection.floorPrice
                  ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL`
                  : "N/A";

                // Use stats data for volume and listed count
                const volume = collection.volume1d
                  ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL`
                  : "N/A";
                const listed = collection.listedCount || "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  collection.name || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
                  collection.symbol || "N/A"
                }</span></td>`;
                html += `<td style='padding:8px;'>${floorPrice}</td>`;
                html += `<td style='padding:8px;'>${volume}</td>`;
                html += `<td style='padding:8px;'>${listed}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenPopularCollections = collectionsWithStats;
            } else {
              this.log(
                "Failed to fetch Magic Eden popular collections.",
                "error"
              );
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden popular collections: ${e.message}`,
              "error"
            );
          }
        }

        async getMagicEdenCollectionActivities(symbol) {
          try {
            this.log(
              `Fetching Magic Eden activities for collection: ${symbol}`,
              "info"
            );

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  `https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`,
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log("Proxy request also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              const activities = data.slice(0, 20); // Show first 20

              let html = `<b>üìä Magic Eden Activities for ${symbol} (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;

              activities.forEach((activity, index) => {
                const type = activity.type || "N/A";
                const price = activity.price ? `${activity.price} SOL` : "N/A";
                const token = activity.tokenMint
                  ? activity.tokenMint.substring(0, 8) + "..."
                  : "N/A";
                const time = activity.blockTime
                  ? new Date(activity.blockTime * 1000).toLocaleString()
                  : "N/A";
                const buyer = activity.buyer
                  ? activity.buyer.substring(0, 8) + "..."
                  : "N/A";
                const seller = activity.seller
                  ? activity.seller.substring(0, 8) + "..."
                  : "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
                html += `<td style='padding:8px;'>${price}</td>`;
                html += `<td style='padding:8px;'>${token}</td>`;
                html += `<td style='padding:8px;'>${time}</td>`;
                html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenActivities = data;
            } else {
              this.log(
                `Failed to fetch activities for collection: ${symbol}`,
                "error"
              );
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden activities: ${e.message}`,
              "error"
            );
          }
        }

        // Helper functions for "Show More" buttons
        showMoreMagicEdenCollections(currentCount) {
          if (!window.magicEdenCollections) {
            this.log("No collections available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenCollections.length
          );
          const collections = window.magicEdenCollections.slice(0, nextBatch);

          let html = `<b>üé® Magic Eden Collections (${window.magicEdenCollections.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;

          collections.forEach((collection, index) => {
            const floorPrice = collection.floorPrice
              ? `${collection.floorPrice} SOL`
              : "N/A";
            const listed = collection.listedCount || "N/A";
            const supply = collection.supply || "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'>${collection.name || "N/A"}</td>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
              collection.symbol || "N/A"
            }</span></td>`;
            html += `<td style='padding:8px;'>${floorPrice}</td>`;
            html += `<td style='padding:8px;'>${listed}</td>`;
            html += `<td style='padding:8px;'>${supply}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenCollections.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenCollections.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        showMoreMagicEdenPopularCollections(currentCount) {
          if (!window.magicEdenPopularCollections) {
            this.log("No popular collections available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenPopularCollections.length
          );
          const collections = window.magicEdenPopularCollections.slice(
            0,
            nextBatch
          );

          let html = `<b>üî• Magic Eden Popular Collections (${window.magicEdenPopularCollections.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;

          collections.forEach((collection, index) => {
            // Convert lamports to SOL (1 SOL = 1,000,000,000 lamports)
            const floorPrice = collection.floorPrice
              ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL`
              : "N/A";

            // Use stats data for volume and listed count
            const volume = collection.volume1d
              ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL`
              : "N/A";
            const listed = collection.listedCount || "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'>${collection.name || "N/A"}</td>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
              collection.symbol || "N/A"
            }</span></td>`;
            html += `<td style='padding:8px;'>${floorPrice}</td>`;
            html += `<td style='padding:8px;'>${volume}</td>`;
            html += `<td style='padding:8px;'>${listed}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenPopularCollections.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenPopularCollections.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        showMoreMagicEdenActivities(symbol, currentCount) {
          if (!window.magicEdenActivities) {
            this.log("No activities available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenActivities.length
          );
          const activities = window.magicEdenActivities.slice(0, nextBatch);

          let html = `<b>üìä Magic Eden Activities for ${symbol} (${window.magicEdenActivities.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;

          activities.forEach((activity, index) => {
            const type = activity.type || "N/A";
            const price = activity.price ? `${activity.price} SOL` : "N/A";
            const token = activity.tokenMint
              ? activity.tokenMint.substring(0, 8) + "..."
              : "N/A";
            const time = activity.blockTime
              ? new Date(activity.blockTime * 1000).toLocaleString()
              : "N/A";
            const buyer = activity.buyer
              ? activity.buyer.substring(0, 8) + "..."
              : "N/A";
            const seller = activity.seller
              ? activity.seller.substring(0, 8) + "..."
              : "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
            html += `<td style='padding:8px;'>${price}</td>`;
            html += `<td style='padding:8px;'>${token}</td>`;
            html += `<td style='padding:8px;'>${time}</td>`;
            html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenActivities.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenActivities.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        async handleRomeCommand(args) {
          if (!args || args.length < 2) {
            this.log("üèõÔ∏è ROME NETWORK COMMANDS", "info");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
            this.log("", "info");
            this.log("üìã AVAILABLE COMMANDS:", "info");
            this.log("  rome connect     Connect to Rome Network", "output");
            this.log("  rome balance     Check Rome Network balance", "output");
            this.log("  rome status      Show Rome Network status", "output");
            this.log(
              "  rome info        Display Rome Network information",
              "output"
            );
            this.log("  rome gen-wallet  Generate a new Rome wallet", "output");
            this.log(
              "  rome token create Create a new token on Rome",
              "output"
            );
            this.log(
              "  rome ens         ENS commands (register/resolve)",
              "output"
            );
            this.log(
              "  rome send        Send tokens via ENS or address",
              "output"
            );
            this.log(
              "  rome nft mint    Mint NFT on Rome Network with UI",
              "output"
            );
            this.log("  rome help        Show this help message", "output");
            this.log("", "info");
            this.log("üéØ EXAMPLES:", "info");
            this.log("  rome connect     # Connect to Rome Network", "info");
            this.log("  rome balance     # Check your Rome balance", "info");
            this.log("  rome gen-wallet  # Generate new Rome wallet", "info");
            this.log("  rome token create # Create Rome token", "info");
            this.log(
              "  rome ens register myname  # Register myname.rome",
              "info"
            );
            this.log(
              "  rome ens resolve myname   # Look up myname.rome",
              "info"
            );
            this.log(
              "  rome send 1 rSOL roman.rome  # Send 1 rSOL to roman.rome",
              "info"
            );
            this.log(
              "  rome send 100 TOKEN 0x123...  # Send 100 TOKEN to address",
              "info"
            );
            this.log("  rome nft mint    # Open NFT minting UI", "info");
            this.log("", "info");
            this.log(
              "üí° Rome Network is a Layer 2 scaling solution!",
              "success"
            );
            return;
          }

          const subcommand = args[1].toLowerCase();

          switch (subcommand) {
            case "connect":
              this.connectToRomeNetwork();
              break;

            case "balance":
              this.checkRomeBalance();
              break;

            case "status":
              this.log("üìä Rome Network Status", "info");
              this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
              this.log("üåê Network: Rome Layer 2", "info");
              this.log("‚õèÔ∏è Block Height: 2,847,392", "info");
              this.log("‚è±Ô∏è Block Time: 2.1s", "info");
              this.log("üí® Gas Price: 0.001 ROME", "info");
              this.log("üîó Validators: 127 active", "info");
              this.log("‚úÖ Network Status: Healthy", "success");
              break;

            case "info":
              this.log("üèõÔ∏è Rome Network Information", "info");
              this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
              this.log("üìù Description: Layer 2 scaling solution", "info");
              this.log("‚ö° Features:", "info");
              this.log("  ‚Ä¢ Fast transaction processing", "info");
              this.log("  ‚Ä¢ Low transaction fees", "info");
              this.log("  ‚Ä¢ High throughput", "info");
              this.log("  ‚Ä¢ EVM compatibility", "info");
              this.log("  ‚Ä¢ Decentralized consensus", "info");
              this.log("üåê Website: https://rome.network", "info");
              this.log("üìö Docs: https://docs.rome.network", "info");
              break;

            case "gen-wallet":
              this.log("üèõÔ∏è Generating new Rome Network wallet...", "info");
              this.log(
                "üîê Creating secure wallet with Rome Layer 2 compatibility",
                "info"
              );

              // Generate a new wallet (using ethers.js if available)
              if (typeof ethers !== "undefined") {
                const wallet = ethers.Wallet.createRandom();
                this.log("‚úÖ Rome wallet generated successfully!", "success");
                this.log("", "info");
                this.log("üìã WALLET DETAILS:", "info");
                this.log(`üèõÔ∏è Address: ${wallet.address}`, "output");
                this.log(`üîë Private Key: ${wallet.privateKey}`, "output");
                this.log(`üìß Mnemonic: ${wallet.mnemonic.phrase}`, "output");
                this.log("", "info");
                this.log(
                  "‚ö†Ô∏è  SECURITY WARNING: Save these details securely!",
                  "error"
                );
                this.log(
                  "üí° This wallet is compatible with Rome Network Layer 2",
                  "info"
                );
              } else {
                this.log(
                  "‚ùå Error: Ethers.js not available for wallet generation",
                  "error"
                );
                this.log(
                  "üí° Rome wallet generation requires Web3 library",
                  "info"
                );
              }
              break;

            case "token":
              if (args.length < 3) {
                this.log("üèõÔ∏è ROME TOKEN COMMANDS", "info");
                this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
                this.log("", "info");
                this.log("üìã AVAILABLE TOKEN COMMANDS:", "info");
                this.log(
                  "  rome token create <name> <symbol> <supply>  Create new Rome token",
                  "output"
                );
                this.log("", "info");
                this.log("üéØ EXAMPLES:", "info");
                this.log("  rome token create RomeCoin ROME 1000000", "info");
                this.log("  rome token create MyToken MTK 500000", "info");
                return;
              }

              if (args[2] === "create") {
                if (args.length < 6) {
                  this.log(
                    "‚ùå Usage: rome token create <name> <symbol> <supply> [decimals]",
                    "error"
                  );
                  this.log(
                    "üéØ Example: rome token create RomeCoin ROME 1000000 18",
                    "info"
                  );
                  return;
                }

                const tokenName = args[3];
                const tokenSymbol = args[4];
                const tokenSupply = parseInt(args[5]);
                const decimals = args[6] ? parseInt(args[6]) : 18;

                if (isNaN(tokenSupply) || tokenSupply <= 0) {
                  this.log(
                    "‚ùå Invalid token supply. Must be a positive number.",
                    "error"
                  );
                  return;
                }

                if (isNaN(decimals) || decimals < 0 || decimals > 18) {
                  this.log(
                    "‚ùå Invalid decimals. Must be between 0 and 18.",
                    "error"
                  );
                  return;
                }

                this.log(
                  "üèõÔ∏è Creating Rome Network token via Factory...",
                  "info"
                );
                this.log(`üìù Token Name: ${tokenName}`, "info");
                this.log(`üè∑Ô∏è Symbol: ${tokenSymbol}`, "info");
                this.log(`üí∞ Supply: ${tokenSupply.toLocaleString()}`, "info");
                this.log(`üî¢ Decimals: ${decimals}`, "info");
                this.log("", "info");
                this.log("‚ö° Calling Rome Token Factory...", "info");

                // Call the factory to create the token
                this.createRomeTokenViaFactory(
                  tokenName,
                  tokenSymbol,
                  tokenSupply,
                  decimals
                );
              } else {
                this.log(`Unknown token command: ${args[2]}`, "error");
                this.log(
                  'Type "rome token" for available token commands',
                  "info"
                );
              }
              break;

            case "ens":
              if (args.length < 3) {
                this.log("üèõÔ∏è ROME ENS COMMANDS", "info");
                this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
                this.log("", "info");
                this.log("üìã AVAILABLE ENS COMMANDS:", "info");
                this.log(
                  "  rome ens register <username>  Register .rome username",
                  "output"
                );
                this.log(
                  "  rome ens resolve <username>   Resolve .rome username",
                  "output"
                );
                this.log("", "info");
                this.log("üéØ EXAMPLES:", "info");
                this.log(
                  "  rome ens register terminal   # Register terminal.rome",
                  "info"
                );
                this.log(
                  "  rome ens resolve terminal    # Look up terminal.rome",
                  "info"
                );
                this.log("", "info");
                this.log("üìã VALID CHARACTERS:", "info");
                this.log("  ‚Ä¢ Letters (a-z, A-Z)", "info");
                this.log("  ‚Ä¢ Numbers (0-9)", "info");
                this.log("  ‚Ä¢ Hyphens (-) and Underscores (_)", "info");
                this.log("  ‚Ä¢ Max length: 32 characters", "info");
                return;
              }

              const ensAction = args[2].toLowerCase();

              if (ensAction === "register") {
                if (args.length < 4) {
                  this.log("‚ùå Usage: rome ens register <username>", "error");
                  this.log("üéØ Example: rome ens register terminal", "info");
                  return;
                }
                const ensName = args[3];
                await this.registerRomeUsername(ensName);
              } else if (ensAction === "resolve") {
                if (args.length < 4) {
                  this.log("‚ùå Usage: rome ens resolve <username>", "error");
                  this.log("üéØ Example: rome ens resolve terminal", "info");
                  return;
                }
                const ensName = args[3];
                await this.resolveRomeUsername(ensName);
              } else {
                // Backwards compatibility - treat as register command
                const ensName = args[2];
                await this.registerRomeUsername(ensName);
              }
              break;

            case "send":
              if (args.length < 4) {
                this.log("üèõÔ∏è ROME SEND COMMANDS", "info");
                this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
                this.log("", "info");
                this.log("üìã USAGE:", "info");
                this.log("  rome send <amount> <token> <recipient>", "output");
                this.log("", "info");
                this.log("üéØ EXAMPLES:", "info");
                this.log(
                  "  rome send 1 rSOL roman.rome        # Send 1 rSOL to roman.rome",
                  "info"
                );
                this.log(
                  "  rome send 100 TOKEN 0x123...       # Send 100 TOKEN to address",
                  "info"
                );
                this.log(
                  "  rome send 0.5 rSOL alice.rome      # Send 0.5 rSOL to alice.rome",
                  "info"
                );
                this.log("", "info");
                this.log(
                  "üí° Recipients can be ENS names (.rome) or wallet addresses",
                  "info"
                );
                this.log(
                  "üí° Token can be rSOL (native) or any ERC-20 token symbol",
                  "info"
                );
                return;
              }

              const amount = args[2];
              const token = args[3];
              const recipient = args[4];

              await this.sendRomeTokens(amount, token, recipient);
              break;

            case "nft":
              if (args.length < 3) {
                this.log("üèõÔ∏è ROME NFT COMMANDS", "info");
                this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
                this.log("", "info");
                this.log("üìã AVAILABLE NFT COMMANDS:", "info");
                this.log(
                  "  rome nft mint    Mint NFT on Rome Network with UI",
                  "output"
                );
                this.log("", "info");
                this.log("üéØ EXAMPLES:", "info");
                this.log("  rome nft mint    # Open NFT minting UI", "info");
                this.log("", "info");
                this.log(
                  "üí° Upload image, add metadata, and mint on Rome Network!",
                  "info"
                );
                return;
              }

              if (args[2] === "mint") {
                // Open Rome NFT minting UI
                this.openRomeNFTMintUI();
              } else {
                this.log(`Unknown NFT command: ${args[2]}`, "error");
                this.log('Type "rome nft" for available NFT commands', "info");
              }
              break;

            case "help":
              this.handleRomeCommand(["rome"]);
              break;

            default:
              this.log(`Unknown Rome command: ${subcommand}`, "error");
              this.log('Type "rome help" for available commands', "info");
          }
        }

        async connectToRomeNetwork() {
          if (!window.ethereum) {
            this.log(
              "‚ùå MetaMask not detected. Please install MetaMask.",
              "error"
            );
            return;
          }

          try {
            this.log("üèõÔ∏è Connecting to Rome Network...", "info");

            // Rome Network configuration
            const ROME_CONFIG = {
              chainId: "0x1d97c", // 121212 in hex
              chainName: "Rome Devnet Esquiline",
              nativeCurrency: {
                name: "RSOL",
                symbol: "RSOL",
                decimals: 18,
              },
              rpcUrls: ["https://esquiline-i.devnet.romeprotocol.xyz"],
              blockExplorerUrls: [
                "https://romescout-esquiline-i.devnet.romeprotocol.xyz",
              ],
            };

            // Try to switch to Rome network first
            try {
              await window.ethereum.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: ROME_CONFIG.chainId }],
              });
              this.log("‚úÖ Switched to Rome Devnet Esquiline", "success");
            } catch (switchError) {
              // Network not added, add it
              if (switchError.code === 4902) {
                this.log("üì° Adding Rome Network to MetaMask...", "info");
                await window.ethereum.request({
                  method: "wallet_addEthereumChain",
                  params: [ROME_CONFIG],
                });
                this.log("‚úÖ Rome Network added to MetaMask", "success");
              } else {
                throw switchError;
              }
            }

            // Get account info
            const accounts = await window.ethereum.request({
              method: "eth_accounts",
            });

            if (accounts.length === 0) {
              this.log("üîê Please connect your wallet in MetaMask", "info");
              await window.ethereum.request({
                method: "eth_requestAccounts",
              });
            }

            // Get current network info
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId === ROME_CONFIG.chainId) {
              this.log("üèõÔ∏è Successfully connected to Rome Network!", "success");
              this.log("", "info");
              this.log("üìã Network Details:", "info");
              this.log(`üèõÔ∏è Network: ${ROME_CONFIG.chainName}`, "info");
              this.log(`üîó Chain ID: 121212 (0x1d97c)`, "info");
              this.log(
                `üí∞ Currency: ${ROME_CONFIG.nativeCurrency.symbol}`,
                "info"
              );
              this.log(`üåê RPC: ${ROME_CONFIG.rpcUrls[0]}`, "info");
              this.log(
                `üîç Explorer: ${ROME_CONFIG.blockExplorerUrls[0]}`,
                "info"
              );
              this.log("", "info");
              this.log(
                "üí° You can now mint NFTs, create tokens, and interact with Rome Network!",
                "success"
              );
            } else {
              this.log("‚ùå Failed to switch to Rome Network", "error");
              this.log(
                "üí° Please try again or manually add the network",
                "info"
              );
            }
          } catch (error) {
            this.log(
              `‚ùå Error connecting to Rome Network: ${error.message}`,
              "error"
            );
            console.error("Rome Network connection error:", error);

            if (error.code === 4001) {
              this.log("üí° Connection rejected by user", "info");
            } else if (error.code === -32602) {
              this.log("üí° Invalid network parameters", "info");
            }
          }
        }

        async checkRomeBalance() {
          if (!window.ethereum || !window.ethereum.selectedAddress) {
            this.log(
              "‚ùå Please connect your wallet first using: rome connect",
              "error"
            );
            return;
          }

          try {
            this.log("üí∞ Checking Rome Network balance...", "info");

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "‚ùå Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Get balance
            const address = window.ethereum.selectedAddress;
            const balance = await window.ethereum.request({
              method: "eth_getBalance",
              params: [address, "latest"],
            });

            // Convert from wei to RSOL
            const balanceInWei = parseInt(balance, 16);
            const balanceInRSOL = balanceInWei / Math.pow(10, 18);

            this.log("üèõÔ∏è Rome Network Balance", "success");
            this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
            this.log(`üë§ Address: ${address}`, "info");
            this.log(
              `üí∞ RSOL Balance: ${balanceInRSOL.toFixed(6)} RSOL`,
              "success"
            );
            this.log(`üîó Network: Rome Devnet Esquiline`, "info");
            this.log(
              `üîç View on Explorer: https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${address}`,
              "output"
            );
          } catch (error) {
            this.log(`‚ùå Error checking balance: ${error.message}`, "error");
            console.error("Rome balance check error:", error);
          }
        }

        async createRomeTokenViaFactory(name, symbol, supply, decimals) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "‚ùå Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "‚ùå Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Rome Token Factory Contract Address (Deployed on Rome Devnet Esquiline)
            const FACTORY_ADDRESS =
              "0x3df3bcce71bf0acc266ea22e8017b50d40d7cfa4";
            const FACTORY_ABI = [
              {
                inputs: [],
                stateMutability: "nonpayable",
                type: "constructor",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "tokenAddress",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "creator",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "name",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "totalSupply",
                    type: "uint256",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "network",
                    type: "string",
                  },
                ],
                name: "TokenCreated",
                type: "event",
              },
              {
                inputs: [
                  { internalType: "string", name: "name", type: "string" },
                  { internalType: "string", name: "symbol", type: "string" },
                  {
                    internalType: "uint256",
                    name: "totalSupply",
                    type: "uint256",
                  },
                  { internalType: "uint8", name: "decimals", type: "uint8" },
                ],
                name: "createToken",
                outputs: [
                  {
                    internalType: "address",
                    name: "tokenAddress",
                    type: "address",
                  },
                ],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [],
                name: "creationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalTokens",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "creator", type: "address" },
                ],
                name: "getTokensByCreator",
                outputs: [
                  { internalType: "address[]", name: "", type: "address[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("üîó Connecting to Rome Token Factory...", "info");

            // Create contract instance using ethers.js
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const factory = new ethers.Contract(
              FACTORY_ADDRESS,
              FACTORY_ABI,
              signer
            );

            // Get creation fee
            const creationFee = await factory.creationFee();
            this.log(
              `üí∏ Creation fee: ${ethers.utils.formatEther(creationFee)} RSOL`,
              "info"
            );

            this.log("‚ö° Sending create token transaction...", "info");

            // Convert supply to proper format with decimals
            // Example: 1000 tokens with 18 decimals = 1000 * 10^18
            const supplyWithDecimals = ethers.BigNumber.from(supply).mul(
              ethers.BigNumber.from(10).pow(decimals)
            );

            this.log(
              `üìä Adjusted Supply: ${supply} tokens (${supplyWithDecimals.toString()} base units)`,
              "info"
            );

            // Call createToken function with fee
            const tx = await factory.createToken(
              name,
              symbol,
              supplyWithDecimals,
              decimals,
              {
                value: creationFee,
              }
            );

            this.log(`üîó Transaction Hash: ${tx.hash}`, "info");
            this.log("‚è≥ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            // Get the token address from the TokenCreated event
            let tokenAddress = null;
            if (receipt.logs && receipt.logs.length > 0) {
              for (let log of receipt.logs) {
                try {
                  const parsedLog = factory.interface.parseLog(log);
                  if (parsedLog && parsedLog.name === "TokenCreated") {
                    tokenAddress = parsedLog.args.tokenAddress;
                    break;
                  }
                } catch (e) {
                  // Continue to next log
                }
              }
            }

            this.log("‚úÖ Token created successfully!", "success");
            this.log("", "info");
            this.log("üìã TOKEN DETAILS:", "info");
            this.log(`üèõÔ∏è Network: Rome Devnet Esquiline`, "info");
            this.log(`üìù Name: ${name}`, "info");
            this.log(`üè∑Ô∏è Symbol: ${symbol}`, "info");
            this.log(`üí∞ Total Supply: ${supply.toLocaleString()}`, "info");
            this.log(`üî¢ Decimals: ${decimals}`, "info");
            this.log(`üîó Token Contract: ${tokenAddress || "Unknown"}`, "info");
            this.log(`üìä Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");

            if (tokenAddress) {
              this.log("üåê VIEW ON EXPLORER:", "info");
              this.logHtml(
                `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${tokenAddress}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${tokenAddress}</a>`,
                "output"
              );
            }
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("‚ùå Insufficient funds for token creation fee", "error");
              this.log("üí° You need RSOL to pay the creation fee", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("‚ùå Transaction rejected by user", "error");
            } else {
              this.log(`‚ùå Error creating token: ${error.message}`, "error");
              console.error("Rome token creation error:", error);
            }
          }
        }

        async registerRomeUsername(username) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "‚ùå Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "‚ùå Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate username locally first
            if (username.length === 0 || username.length > 32) {
              this.log(
                "‚ùå Username must be between 1 and 32 characters",
                "error"
              );
              return;
            }

            const validUsernameRegex = /^[a-zA-Z0-9_-]+$/;
            if (!validUsernameRegex.test(username)) {
              this.log(
                "‚ùå Username can only contain letters, numbers, hyphens, and underscores",
                "error"
              );
              return;
            }

            // Rome Username Registry Contract Address (Deployed on Rome Devnet Esquiline)
            const REGISTRY_ADDRESS =
              "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
            const REGISTRY_ABI = [
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "registerUsername",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "renewUsername",
                outputs: [],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                  { internalType: "address", name: "to", type: "address" },
                ],
                name: "transferUsername",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                inputs: [],
                name: "registrationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "isUsernameAvailable",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "getUsernameInfo",
                outputs: [
                  {
                    internalType: "address",
                    name: "usernameOwner",
                    type: "address",
                  },
                  {
                    internalType: "uint256",
                    name: "registrationTime",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "expirationTime",
                    type: "uint256",
                  },
                  { internalType: "bool", name: "isActive", type: "bool" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "resolveUsername",
                outputs: [
                  { internalType: "address", name: "", type: "address" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "addr", type: "address" },
                ],
                name: "getUsernamesByAddress",
                outputs: [
                  { internalType: "string[]", name: "", type: "string[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalRegistrations",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("üîó Connecting to Rome Username Registry...", "info");

            // Create contract instance
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const registry = new ethers.Contract(
              REGISTRY_ADDRESS,
              REGISTRY_ABI,
              signer
            );

            // Check if username is available
            this.log(`üîç Checking if ${username}.rome is available...`, "info");
            const isAvailable = await registry.isUsernameAvailable(username);

            if (!isAvailable) {
              this.log(
                `‚ùå Username ${username}.rome is already taken`,
                "error"
              );
              this.log("üí° Try a different username", "info");
              return;
            }

            // Get registration fee
            const registrationFee = await registry.registrationFee();
            this.log(
              `üí∏ Registration fee: ${ethers.utils.formatEther(
                registrationFee
              )} RSOL (1 year)`,
              "info"
            );

            this.log("‚ö° Sending registration transaction...", "info");

            // Register username
            const tx = await registry.registerUsername(username, {
              value: registrationFee,
            });

            this.log(`üîó Transaction Hash: ${tx.hash}`, "info");
            this.log("‚è≥ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            const userAddress = await signer.getAddress();
            const expirationDate = new Date(
              Date.now() + 365 * 24 * 60 * 60 * 1000
            ); // 1 year from now

            this.log("‚úÖ Username registered successfully!", "success");
            this.log("", "info");
            this.log("üìã USERNAME DETAILS:", "info");
            this.log(`üèõÔ∏è Network: Rome Devnet Esquiline`, "info");
            this.log(`üìù Username: ${username}.rome`, "success");
            this.log(`üë§ Owner: ${userAddress}`, "info");
            this.log(
              `üìÖ Registered: ${new Date().toLocaleDateString()}`,
              "info"
            );
            this.log(
              `‚è∞ Expires: ${expirationDate.toLocaleDateString()}`,
              "info"
            );
            this.log(`üìä Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");
            this.log("üåê VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}</a>`,
              "output"
            );
            this.log("", "info");
            this.log("üí° Your username will be valid for 1 year", "info");
            this.log(
              'üí° Use "rome ens renew <username>" to extend registration',
              "info"
            );
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("‚ùå Insufficient funds for registration fee", "error");
              this.log("üí° You need RSOL to pay the registration fee", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("‚ùå Transaction rejected by user", "error");
            } else {
              this.log(
                `‚ùå Error registering username: ${error.message}`,
                "error"
              );
              console.error("Rome username registration error:", error);
            }
          }
        }

        async resolveRomeUsername(username) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "‚ùå Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "‚ùå Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate username locally first
            if (username.length === 0 || username.length > 32) {
              this.log(
                "‚ùå Username must be between 1 and 32 characters",
                "error"
              );
              return;
            }

            const validUsernameRegex = /^[a-zA-Z0-9_-]+$/;
            if (!validUsernameRegex.test(username)) {
              this.log(
                "‚ùå Username can only contain letters, numbers, hyphens, and underscores",
                "error"
              );
              return;
            }

            // Rome Username Registry Contract Address (Deployed on Rome Devnet Esquiline)
            const REGISTRY_ADDRESS =
              "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
            const REGISTRY_ABI = [
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "registerUsername",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "renewUsername",
                outputs: [],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                  { internalType: "address", name: "to", type: "address" },
                ],
                name: "transferUsername",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                inputs: [],
                name: "registrationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "isUsernameAvailable",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "getUsernameInfo",
                outputs: [
                  {
                    internalType: "address",
                    name: "usernameOwner",
                    type: "address",
                  },
                  {
                    internalType: "uint256",
                    name: "registrationTime",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "expirationTime",
                    type: "uint256",
                  },
                  { internalType: "bool", name: "isActive", type: "bool" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "resolveUsername",
                outputs: [
                  { internalType: "address", name: "", type: "address" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "addr", type: "address" },
                ],
                name: "getUsernamesByAddress",
                outputs: [
                  { internalType: "string[]", name: "", type: "string[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalRegistrations",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("üîç Resolving Rome username...", "info");

            // Connect to the registry contract
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const registry = new ethers.Contract(
              REGISTRY_ADDRESS,
              REGISTRY_ABI,
              provider
            );

            // Check if username is available (if available, it means no one owns it)
            const isAvailable = await registry.isUsernameAvailable(username);

            if (isAvailable) {
              this.log(
                `‚ùå Username "${username}.rome" is not registered`,
                "error"
              );
              this.log(
                "üí° This username is available for registration",
                "info"
              );
              this.log(
                'üí° Use "rome ens register <username>" to claim it',
                "info"
              );
              return;
            }

            // Get detailed username info
            const usernameInfo = await registry.getUsernameInfo(username);
            const owner = usernameInfo.usernameOwner;
            const registrationTime = usernameInfo.registrationTime;
            const expirationTime = usernameInfo.expirationTime;
            const isActive = usernameInfo.isActive;

            // Convert timestamps to readable dates
            const registrationDate = new Date(
              registrationTime.toNumber() * 1000
            );
            const expirationDate = new Date(expirationTime.toNumber() * 1000);
            const now = new Date();

            // Check if username is expired
            const isExpired = now > expirationDate;

            this.log("‚úÖ Username found!", "success");
            this.log("", "info");
            this.log("üìã USERNAME DETAILS:", "info");
            this.log(`üèõÔ∏è Network: Rome Devnet Esquiline`, "info");
            this.log(`üìù Username: ${username}.rome`, "success");
            this.log(`üë§ Owner: ${owner}`, "info");
            this.log(
              `üìÖ Registered: ${registrationDate.toLocaleDateString()}`,
              "info"
            );
            this.log(
              `‚è∞ Expires: ${expirationDate.toLocaleDateString()}`,
              "info"
            );

            if (isExpired) {
              this.log(
                `‚ö†Ô∏è Status: EXPIRED (expired ${Math.floor(
                  (now - expirationDate) / (1000 * 60 * 60 * 24)
                )} days ago)`,
                "error"
              );
              this.log(
                "üí° This username may become available for registration soon",
                "info"
              );
            } else {
              const daysLeft = Math.floor(
                (expirationDate - now) / (1000 * 60 * 60 * 24)
              );
              this.log(
                `‚úÖ Status: ACTIVE (${daysLeft} days remaining)`,
                "success"
              );
            }

            this.log("", "info");
            this.log("üåê VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}</a>`,
              "output"
            );
          } catch (error) {
            this.log(`‚ùå Error resolving username: ${error.message}`, "error");
            console.error("Rome username resolution error:", error);
          }
        }

        async sendRomeTokens(amount, token, recipient) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "‚ùå Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "‚ùå Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate amount
            const amountNum = parseFloat(amount);
            if (isNaN(amountNum) || amountNum <= 0) {
              this.log(
                "‚ùå Invalid amount. Please provide a positive number",
                "error"
              );
              return;
            }

            // Resolve recipient address (ENS or direct address)
            let recipientAddress;

            if (recipient.endsWith(".rome")) {
              // Resolve ENS name
              this.log(`üîç Resolving ENS name: ${recipient}`, "info");

              const username = recipient.replace(".rome", "");
              const REGISTRY_ADDRESS =
                "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
              const REGISTRY_ABI = [
                {
                  inputs: [
                    {
                      internalType: "string",
                      name: "username",
                      type: "string",
                    },
                  ],
                  name: "resolveUsername",
                  outputs: [
                    { internalType: "address", name: "", type: "address" },
                  ],
                  stateMutability: "view",
                  type: "function",
                },
              ];

              const provider = new ethers.providers.Web3Provider(
                window.ethereum
              );
              const registry = new ethers.Contract(
                REGISTRY_ADDRESS,
                REGISTRY_ABI,
                provider
              );

              recipientAddress = await registry.resolveUsername(username);

              if (
                recipientAddress ===
                "0x0000000000000000000000000000000000000000"
              ) {
                this.log(
                  `‚ùå ENS name "${recipient}" not found or expired`,
                  "error"
                );
                this.log(
                  'üí° Use "rome ens resolve <username>" to check availability',
                  "info"
                );
                return;
              }

              this.log(
                `‚úÖ Resolved ${recipient} to: ${recipientAddress}`,
                "success"
              );
            } else {
              // Direct address
              if (!ethers.utils.isAddress(recipient)) {
                this.log("‚ùå Invalid recipient address or ENS name", "error");
                this.log(
                  "üí° Use a valid Ethereum address or ENS name ending in .rome",
                  "info"
                );
                return;
              }
              recipientAddress = recipient;
            }

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const userAddress = await signer.getAddress();

            // Handle different token types
            if (token.toLowerCase() === "rsol") {
              // Send native rSOL
              this.log(
                `üí∏ Sending ${amount} rSOL to ${recipientAddress}`,
                "info"
              );

              const tx = await signer.sendTransaction({
                to: recipientAddress,
                value: ethers.utils.parseEther(amount.toString()),
              });

              this.log(`‚è≥ Transaction submitted: ${tx.hash}`, "info");
              this.log("‚è≥ Waiting for confirmation...", "info");

              const receipt = await tx.wait();

              this.log("‚úÖ Transaction confirmed!", "success");
              this.log("", "info");
              this.log("üìã TRANSACTION DETAILS:", "info");
              this.log(`üèõÔ∏è Network: Rome Devnet Esquiline`, "info");
              this.log(`üí∞ Amount: ${amount} rSOL`, "success");
              this.log(`üë§ From: ${userAddress}`, "info");
              this.log(`üë§ To: ${recipientAddress}`, "info");
              this.log(`üìä Gas Used: ${receipt.gasUsed.toString()}`, "info");
              this.log(
                `‚õΩ Gas Price: ${ethers.utils.formatUnits(
                  receipt.effectiveGasPrice,
                  "gwei"
                )} gwei`,
                "info"
              );
            } else {
              // Send ERC-20 token
              this.log(
                `üí∏ Sending ${amount} ${token} to ${recipientAddress}`,
                "info"
              );
              this.log(
                "‚ö†Ô∏è Note: ERC-20 token sending requires token contract address",
                "warning"
              );
              this.log(
                "üí° For now, this is a placeholder - full ERC-20 support coming soon",
                "info"
              );

              // TODO: Implement ERC-20 token sending
              // This would require:
              // 1. Token contract address lookup
              // 2. ERC-20 ABI
              // 3. transfer() function call
              // 4. Approval handling if needed

              this.log(
                "üöß ERC-20 token sending not yet implemented",
                "warning"
              );
              this.log(
                "üí° Currently only rSOL (native token) sending is supported",
                "info"
              );
              return;
            }

            this.log("", "info");
            this.log("üåê VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/tx/${receipt.transactionHash}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/tx/${receipt.transactionHash}</a>`,
              "output"
            );
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("‚ùå Insufficient funds for transaction", "error");
              this.log(
                "üí° Check your rSOL balance using: rome balance",
                "info"
              );
            } else if (error.code === "USER_REJECTED") {
              this.log("‚ùå Transaction rejected by user", "error");
            } else {
              this.log(`‚ùå Error sending tokens: ${error.message}`, "error");
              console.error("Rome token send error:", error);
            }
          }
        }

        openRomeNFTMintUI() {
          const existing = document.getElementById("rome-nft-mint");
          if (existing) existing.remove();

          const html = `
                    <div id="rome-nft-mint" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90vw;
                        max-width: 500px;
                        background: linear-gradient(135deg, rgba(18, 18, 18, 0.98), rgba(28, 28, 30, 0.95));
                        backdrop-filter: blur(40px);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 20px;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                        z-index: 20000;
                        color: white;
                        font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
                        padding: 30px;
                        max-height: 90vh;
                        overflow-y: auto;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                            <div style="font-size: 1.6em; font-weight: 800;">üèõÔ∏è Mint Rome NFT</div>
                            <button onclick="closeRomeNFTMintUI()" style="
                                background: rgba(255, 59, 48, 0.2);
                                color: #FF3B30;
                                border: none;
                                padding: 8px 12px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 1.2em;
                            ">‚úï</button>
                        </div>
                        
                        <div id="rome-upload-zone" style="
                            border: 2px dashed rgba(255, 255, 255, 0.3);
                            border-radius: 16px;
                            padding: 40px;
                            text-align: center;
                            margin-bottom: 20px;
                            background: rgba(0, 0, 0, 0.2);
                            cursor: pointer;
                        " onclick="document.getElementById('rome-file-input').click()">
                            <div style="font-size: 3em; margin-bottom: 12px;">üñºÔ∏è</div>
                            <div style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px;">Upload Image</div>
                            <div style="font-size: 0.9em; opacity: 0.7;">Click to browse or paste (Ctrl+V)</div>
                        </div>
                        
                        <input type="file" id="rome-file-input" accept="image/*" style="display: none;" onchange="handleRomeFileUpload(event)">
                        
                        <div id="rome-image-preview" style="display: none; margin-bottom: 20px; text-align: center;">
                            <img id="rome-preview-img" style="max-width: 100%; max-height: 200px; border-radius: 12px; display: block; margin: 0 auto;">
                            <button onclick="clearRomeImage()" style="
                                background: rgba(255, 59, 48, 0.2);
                                color: #FF3B30;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                margin-top: 10px;
                                font-size: 0.9em;
                            ">Remove Image</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">NFT Name</label>
                            <input type="text" id="rome-nft-name" placeholder="Enter NFT name" style="
                                width: 100%;
                                padding: 12px;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                background: rgba(0, 0, 0, 0.3);
                                color: white;
                                font-size: 1em;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Description <span style="color: #888; font-weight: 400;">(Optional)</span></label>
                            <textarea id="rome-nft-description" placeholder="Describe your NFT (optional)" style="
                                width: 100%;
                                padding: 12px;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                background: rgba(0, 0, 0, 0.3);
                                color: white;
                                font-size: 1em;
                                min-height: 80px;
                                resize: vertical;
                            "></textarea>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label style="font-weight: 600;">Traits / Attributes</label>
                                <button onclick="toggleRomeTraits()" style="
                                    background: rgba(0, 122, 255, 0.2);
                                    color: #007AFF;
                                    border: none;
                                    padding: 6px 12px;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.8em;
                                " id="rome-traits-toggle">Add Traits</button>
                            </div>
                            <div id="rome-traits-container" style="display: none;">
                                <div id="rome-traits-list"></div>
                                <button onclick="addRomeTrait()" style="
                                    background: rgba(52, 199, 89, 0.2);
                                    color: #34C759;
                                    border: none;
                                    padding: 8px 16px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 0.9em;
                                    margin-top: 10px;
                                ">+ Add Trait</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Network Info</label>
                            <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; font-size: 0.9em;">
                                <div>üèõÔ∏è Network: Rome Devnet Esquiline</div>
                                <div>üîó Contract: 0xc88a32d1977c11b7874400052d3750856c90120f</div>
                                <div>üí∞ Currency: RSOL</div>
                            </div>
                        </div>
                        
                        <button onclick="mintRomeNFTOnChain()" style="
                            width: 100%;
                            padding: 16px;
                            background: linear-gradient(135deg, #007AFF, #0051D5);
                            color: white;
                            border: none;
                            border-radius: 12px;
                            font-size: 1.1em;
                            font-weight: 600;
                            cursor: pointer;
                            margin-bottom: 10px;
                        ">üèõÔ∏è Mint on Rome Network</button>
                        
                        <div style="text-align: center; font-size: 0.8em; opacity: 0.7;">
                            Powered by Rome Network Layer 2
                        </div>
                    </div>
                `;

          document.body.insertAdjacentHTML("beforeend", html);

          // Add paste functionality
          window.handleRomePaste = this.handleRomePaste.bind(this);

          // Add global functions
          window.closeRomeNFTMintUI = this.closeRomeNFTMintUI.bind(this);
          window.handleRomeFileUpload = this.handleRomeFileUpload.bind(this);
          window.clearRomeImage = this.clearRomeImage.bind(this);
          window.mintRomeNFTOnChain = this.mintRomeNFTOnChain.bind(this);
          window.toggleRomeTraits = this.toggleRomeTraits.bind(this);
          window.addRomeTrait = this.addRomeTrait.bind(this);
          window.removeRomeTrait = this.removeRomeTrait.bind(this);
        }

        closeRomeNFTMintUI() {
          const modal = document.getElementById("rome-nft-mint");
          if (modal) modal.remove();
          document.removeEventListener("paste", window.handleRomePaste);
        }

        handleRomePaste(event) {
          const modal = document.getElementById("rome-nft-mint");
          if (!modal) return;

          const items = event.clipboardData?.items;
          if (!items) return;

          for (let item of items) {
            if (item.type.startsWith("image/")) {
              const file = item.getAsFile();
              if (file) {
                this.showRomeImage(file);
                break;
              }
            }
          }
        }

        handleRomeFileUpload(event) {
          const file = event.target.files[0];
          if (file) {
            this.showRomeImage(file);
          }
        }

        showRomeImage(file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const preview = document.getElementById("rome-image-preview");
            const img = document.getElementById("rome-preview-img");
            const uploadZone = document.getElementById("rome-upload-zone");

            img.src = e.target.result;
            preview.style.display = "block";
            uploadZone.style.display = "none";

            // Store file for later use
            window.romeSelectedFile = file;
          };
          reader.readAsDataURL(file);
        }

        clearRomeImage() {
          const preview = document.getElementById("rome-image-preview");
          const uploadZone = document.getElementById("rome-upload-zone");

          preview.style.display = "none";
          uploadZone.style.display = "block";

          window.romeSelectedFile = null;
          document.getElementById("rome-file-input").value = "";
        }

        toggleRomeTraits() {
          const container = document.getElementById("rome-traits-container");
          const toggle = document.getElementById("rome-traits-toggle");

          if (container.style.display === "none") {
            container.style.display = "block";
            toggle.textContent = "Hide Traits";
          } else {
            container.style.display = "none";
            toggle.textContent = "Add Traits";
          }
        }

        addRomeTrait() {
          const traitsList = document.getElementById("rome-traits-list");
          const traitId = Date.now();

          const traitHtml = `
                    <div id="rome-trait-${traitId}" style="
                        display: flex;
                        gap: 10px;
                        margin-bottom: 10px;
                        align-items: center;
                    ">
                        <input type="text" placeholder="Trait Type" style="
                            flex: 1;
                            padding: 8px;
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            background: rgba(0, 0, 0, 0.3);
                            color: white;
                            font-size: 0.9em;
                        ">
                        <input type="text" placeholder="Value" style="
                            flex: 1;
                            padding: 8px;
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            background: rgba(0, 0, 0, 0.3);
                            color: white;
                            font-size: 0.9em;
                        ">
                        <button onclick="removeRomeTrait(${traitId})" style="
                            background: rgba(255, 59, 48, 0.2);
                            color: #FF3B30;
                            border: none;
                            padding: 8px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.9em;
                        ">‚úï</button>
                    </div>
                `;

          traitsList.insertAdjacentHTML("beforeend", traitHtml);
        }

        removeRomeTrait(traitId) {
          const traitElement = document.getElementById(`rome-trait-${traitId}`);
          if (traitElement) {
            traitElement.remove();
          }
        }

        getRomeTraits() {
          const traits = [];
          const traitElements = document.querySelectorAll(
            '[id^="rome-trait-"]'
          );

          traitElements.forEach((element) => {
            const inputs = element.querySelectorAll("input");
            const traitType = inputs[0]?.value?.trim();
            const traitValue = inputs[1]?.value?.trim();

            if (traitType && traitValue) {
              traits.push({
                trait_type: traitType,
                value: traitValue,
              });
            }
          });

          return traits;
        }

        async mintRomeNFTOnChain() {
          const name = document.getElementById("rome-nft-name").value.trim();
          const description = document
            .getElementById("rome-nft-description")
            .value.trim();
          const file = window.romeSelectedFile;
          const traits = this.getRomeTraits();

          if (!file) {
            this.log("‚ùå Please upload an image first", "error");
            return;
          }

          if (!name) {
            this.log("‚ùå Please enter an NFT name", "error");
            return;
          }

          if (!window.ethereum || !window.ethereum.selectedAddress) {
            this.log("‚ùå Please connect your wallet first", "error");
            return;
          }

          try {
            this.log("üèõÔ∏è Starting Rome NFT minting process...", "info");

            // Step 1: Upload image to Pinata
            this.log("üì§ Uploading image to IPFS...", "info");
            const imageUrl = await this.uploadRomeImageToPinata(file);

            // Step 2: Create metadata JSON
            const metadata = {
              name: name,
              description: description || `Rome NFT: ${name}`,
              image: imageUrl,
              external_url: "https://rome.network",
              attributes: traits,
            };

            if (traits.length > 0) {
              this.log(
                `üìä Adding ${traits.length} trait(s) to metadata...`,
                "info"
              );
            }

            this.log("üìù Creating metadata...", "info");
            const metadataUrl = await this.uploadRomeMetadataToPinata(metadata);

            // Step 3: Mint NFT on Rome Network
            this.log("‚ö° Minting NFT on Rome Network...", "info");
            await this.mintRomeNFT(metadataUrl);

            // Close UI on success
            this.closeRomeNFTMintUI();
          } catch (error) {
            this.log(`‚ùå Error: ${error.message}`, "error");
            console.error("Rome NFT minting error:", error);
          }
        }

        async uploadRomeImageToPinata(file) {
          const formData = new FormData();
          formData.append("file", file);

          const response = await fetch(
            "https://api.pinata.cloud/pinning/pinFileToIPFS",
            {
              method: "POST",
              headers: {
                pinata_api_key: "c717314daa6072cf4111",
                pinata_secret_api_key:
                  "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
              },
              body: formData,
            }
          );

          if (!response.ok) {
            throw new Error("Failed to upload image to IPFS");
          }

          const result = await response.json();
          return `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`;
        }

        async uploadRomeMetadataToPinata(metadata) {
          const response = await fetch(
            "https://api.pinata.cloud/pinning/pinJSONToIPFS",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                pinata_api_key: "c717314daa6072cf4111",
                pinata_secret_api_key:
                  "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
              },
              body: JSON.stringify({
                pinataContent: metadata,
                pinataMetadata: {
                  name: "rome-nft-metadata.json",
                },
              }),
            }
          );

          if (!response.ok) {
            throw new Error("Failed to upload metadata to IPFS");
          }

          const result = await response.json();
          return `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`;
        }

        async mintRomeNFT(tokenURI) {
          try {
            // Rome Network configuration
            const ROME_CONFIG = {
              chainId: "0x1d97c", // 121212 in hex
              chainName: "Rome Devnet Esquiline",
              nativeCurrency: {
                name: "RSOL",
                symbol: "RSOL",
                decimals: 18,
              },
              rpcUrls: ["https://esquiline-i.devnet.romeprotocol.xyz"],
              blockExplorerUrls: [
                "https://romescout-esquiline-i.devnet.romeprotocol.xyz",
              ],
            };

            // Check if Rome network is added
            try {
              await window.ethereum.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: ROME_CONFIG.chainId }],
              });
            } catch (switchError) {
              if (switchError.code === 4902) {
                // Network not added, add it
                await window.ethereum.request({
                  method: "wallet_addEthereumChain",
                  params: [ROME_CONFIG],
                });
              } else {
                throw switchError;
              }
            }

            this.log("‚úÖ Connected to Rome Devnet Esquiline", "success");

            // Contract ABI for the mint function
            const contractABI = [
              {
                inputs: [
                  {
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    internalType: "string",
                    name: "tokenURI",
                    type: "string",
                  },
                ],
                name: "mint",
                outputs: [
                  {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                  },
                ],
                stateMutability: "nonpayable",
                type: "function",
              },
            ];

            const contractAddress =
              "0xc88a32d1977c11b7874400052d3750856c90120f";

            // Get provider and signer
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const userAddress = await signer.getAddress();

            this.log(`üë§ Minting to address: ${userAddress}`, "info");

            // Create contract instance
            const contract = new ethers.Contract(
              contractAddress,
              contractABI,
              signer
            );

            this.log("‚ö° Sending mint transaction...", "info");

            // Call mint function
            const tx = await contract.mint(userAddress, tokenURI);

            this.log(`üîó Transaction Hash: ${tx.hash}`, "info");
            this.log("‚è≥ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            // Get the token ID from the Transfer event
            let tokenId = "Unknown";

            // Try to get token ID from Transfer event first
            if (receipt.events && receipt.events.length > 0) {
              const transferEvent = receipt.events.find(
                (e) => e.event === "Transfer"
              );
              if (
                transferEvent &&
                transferEvent.args &&
                transferEvent.args.tokenId
              ) {
                tokenId = transferEvent.args.tokenId.toString();
              }
            }

            // If still unknown, try to parse from logs
            if (
              tokenId === "Unknown" &&
              receipt.logs &&
              receipt.logs.length > 0
            ) {
              try {
                for (let log of receipt.logs) {
                  if (
                    log.topics[0] ===
                    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
                  ) {
                    // Transfer event signature
                    tokenId = parseInt(log.topics[3], 16).toString();
                    break;
                  }
                }
              } catch (e) {
                console.log("Could not extract token ID from logs:", e);
              }
            }

            this.log("‚úÖ NFT minted successfully!", "success");
            this.log("", "info");
            this.log("üìã NFT DETAILS:", "info");
            this.log(`üèõÔ∏è Network: Rome Devnet Esquiline`, "info");
            this.log(`üîó Contract: ${contractAddress}`, "info");
            this.log(`üÜî Token ID: #${tokenId}`, "info");
            this.log(`üë§ Owner: ${userAddress}`, "info");
            this.log(`üîó Token URI: ${tokenURI}`, "info");
            this.log(`üìä Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");
            this.log("üåê VIEW ON EXPLORER:", "info");

            // Create clickable explorer URL (remove /instance/Unknown if token ID is unknown)
            let explorerUrl = `https://romescout-esquiline-i.devnet.romeprotocol.xyz/token/${contractAddress}`;
            if (tokenId !== "Unknown") {
              explorerUrl += `/instance/${tokenId}`;
            }

            // Create clickable link
            this.logHtml(
              `<a href="${explorerUrl}" target="_blank" style="color: #007AFF; text-decoration: underline;">${explorerUrl}</a>`,
              "output"
            );
          } catch (error) {
            this.log(`‚ùå Error minting NFT: ${error.message}`, "error");
            console.error("Rome NFT minting error:", error);

            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("üí° Insufficient RSOL for gas fees", "info");
              this.log("üèõÔ∏è Get RSOL from Rome faucet or bridge", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("üí° Transaction rejected by user", "info");
            } else if (error.message.includes("network")) {
              this.log("üí° Network connection issue", "info");
              this.log("üîó Make sure you're connected to Rome Devnet", "info");
            }
          }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KALSHI PREDICTION MARKETS INTEGRATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        async handleKalshiCommand(args) {
          if (!args || args.length < 2) {
            this.showKalshiHelp();
            return;
          }

          const subcommand = args[1];

          switch (subcommand) {
            case "help":
              this.showKalshiHelp();
              break;
            case "set-api-key":
              if (args.length < 3) {
                this.log("Usage: kalshi set-api-key <api-key-id>", "error");
                return;
              }
              await this.setKalshiApiKey(args[2]);
              break;
            case "set-key":
              if (args.length < 3) {
                this.log("Usage: kalshi set-key <rsa-private-key>", "error");
                this.log(
                  "üí° This stores your RSA private key for Kalshi authentication",
                  "info"
                );
                return;
              }
              // Join all arguments after 'set-key' to handle multi-line private keys
              const fullPrivateKey = args.slice(2).join(" ");
              await this.setKalshiPrivateKey(fullPrivateKey);
              break;
            case "set-private-key":
              await this.setKalshiPrivateKeyInteractive();
              break;
            case "test":
              this.testKalshiSetup();
              break;
            case "markets":
              await this.getKalshiMarkets(args.slice(2));
              break;
            case "events":
              await this.getKalshiEvents(args.slice(2));
              break;
            case "balance":
              await this.getKalshiBalance();
              break;
            case "search":
              await this.searchKalshiMarkets(args.slice(2).join(" "));
              break;
            case "market":
              await this.getKalshiMarketDetails(args[2]);
              break;
            default:
              this.log(`Unknown Kalshi command: ${subcommand}`, "error");
              this.showKalshiHelp();
          }
        }

        showKalshiHelp() {
          this.log("üìä KALSHI PREDICTION MARKETS", "info");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
          this.log("", "info");
          this.log("üìã AVAILABLE COMMANDS:", "info");
          this.log(
            "  kalshi help                    Show this help message",
            "output"
          );
          this.log(
            "  kalshi set-api-key <key-id>    Set your Kalshi API Key ID",
            "output"
          );
          this.log(
            "  kalshi set-key <private-key>   Set your RSA private key",
            "output"
          );
          this.log(
            "  kalshi set-private-key         Interactive private key setup",
            "output"
          );
          this.log(
            "  kalshi test                    Test your Kalshi setup",
            "output"
          );
          this.log(
            "  kalshi markets                 List available markets",
            "output"
          );
          this.log(
            "  kalshi events                  List available events",
            "output"
          );
          this.log(
            "  kalshi balance                 Show your account balance",
            "output"
          );
          this.log(
            "  kalshi search <query>          Search for markets",
            "output"
          );
          this.log(
            "  kalshi market <ticker>         Get market details",
            "output"
          );
          this.log("", "info");
          this.log("üîß SETUP (Required):", "info");
          this.log("  1. Get API key ID from Kalshi dashboard", "output");
          this.log("  2. Set key ID: kalshi set-api-key YOUR_KEY_ID", "output");
          this.log(
            "  3. Set private key: kalshi set-private-key (interactive)",
            "output"
          );
          this.log("", "info");
          this.log("üéØ EXAMPLES:", "info");
          this.log(
            "  kalshi set-api-key ed60297a-477f-4857-8dd2-3ebeb4601c51",
            "info"
          );
          this.log("  kalshi markets --status open --limit 10", "info");
          this.log("  kalshi events --status open", "info");
          this.log("  kalshi search election", "info");
          this.log("  kalshi market KXELEC-24", "info");
          this.log("", "info");
          this.log(
            "üí° Get your API key from: https://kalshi.com/developers",
            "info"
          );
        }

        async setKalshiApiKey(key) {
          if (!key) {
            this.log("‚ùå Please provide an API key", "error");
            this.log("Usage: kalshi set-api-key <your-api-key>", "info");
            this.log("", "info");
            this.log(
              'üí° Tip: Use "profile apikeys set kalshi <key>" to manage all API keys in one place',
              "info"
            );
            return;
          }

          // Store in both locations for compatibility
          localStorage.setItem("kalshi_api_key", key);

          // Also store in unified profile API keys system
          const keys = this.getAllApiKeys();
          keys["kalshi"] = key;
          this.saveAllApiKeys(keys);

          this.log("‚úÖ Kalshi API Key set successfully", "success");
          this.log("üí° Your API key is stored locally and securely", "info");
          this.log("", "info");
          this.log(
            'üéØ TIP: Use "profile apikeys list" to manage all your API keys',
            "info"
          );
        }

        async setKalshiPrivateKey(privateKey) {
          if (!privateKey) {
            this.log("‚ùå Please provide your RSA private key", "error");
            return;
          }

          // Validate private key format and length
          if (privateKey.length < 100) {
            this.log("‚ùå Invalid RSA private key (too short)", "error");
            this.log(
              "üí° A valid RSA private key should be 1600+ characters long",
              "info"
            );
            return;
          }

          // Validate PEM format
          if (
            !privateKey.includes("-----BEGIN RSA PRIVATE KEY-----") ||
            !privateKey.includes("-----END RSA PRIVATE KEY-----")
          ) {
            this.log("‚ùå Invalid RSA private key format", "error");
            this.log(
              'üí° Key should start with "-----BEGIN RSA PRIVATE KEY-----" and end with "-----END RSA PRIVATE KEY-----"',
              "info"
            );
            return;
          }

          // Store the RSA private key securely
          localStorage.setItem("kalshi_private_key", privateKey);

          this.log(
            `‚úÖ Kalshi RSA Private Key set successfully (${privateKey.length} characters)`,
            "success"
          );
          this.log(
            "üîê Your private key is stored locally and securely",
            "info"
          );
          this.log(
            "üí° You can now use Kalshi commands for authenticated requests",
            "info"
          );
        }

        async setKalshiPrivateKeyInteractive() {
          this.log("üîê Kalshi RSA Private Key Setup", "info");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
          this.log("", "info");
          this.log("üìã Instructions:", "info");
          this.log(
            "1. Copy your complete RSA private key from Kalshi",
            "output"
          );
          this.log(
            "2. Paste it in the input below (include BEGIN and END lines)",
            "output"
          );
          this.log("3. Press Ctrl+Enter when done", "output");
          this.log("", "info");
          this.log("üí° Your private key should look like:", "info");
          this.log("-----BEGIN RSA PRIVATE KEY-----", "output");
          this.log("MIIEpAIBAAKCAQEA...", "output");
          this.log("...", "output");
          this.log("-----END RSA PRIVATE KEY-----", "output");
          this.log("", "info");
          this.log("üîë Paste your private key and press Enter twice:", "info");

          // Create a simple input mechanism
          const input = document.createElement("textarea");
          input.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 80%;
                    height: 300px;
                    background: #1a1a1a;
                    color: #ffffff;
                    border: 2px solid #007AFF;
                    border-radius: 8px;
                    padding: 20px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    z-index: 10000;
                    resize: vertical;
                `;
          input.placeholder =
            "Paste your complete RSA private key here (including BEGIN and END lines)";

          document.body.appendChild(input);
          input.focus();

          // Create submit button
          const submitBtn = document.createElement("button");
          submitBtn.textContent = "Submit Private Key";
          submitBtn.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, 200px);
                    padding: 10px 20px;
                    background: #007AFF;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    font-size: 14px;
                    cursor: pointer;
                    z-index: 10002;
                `;

          // Handle submission via button or Ctrl+Enter
          const submitKey = async () => {
            const privateKey = input.value.trim();
            document.body.removeChild(input);
            document.body.removeChild(submitBtn);
            if (document.body.contains(overlay)) {
              document.body.removeChild(overlay);
            }

            if (privateKey) {
              await this.setKalshiPrivateKey(privateKey);
            } else {
              this.log("‚ùå No private key provided", "error");
            }
          };

          submitBtn.addEventListener("click", submitKey);
          document.body.appendChild(submitBtn);

          input.addEventListener("keydown", async (e) => {
            if (e.key === "Enter" && e.ctrlKey) {
              e.preventDefault();
              await submitKey();
            }
          });

          // Add instructions overlay
          const overlay = document.createElement("div");
          overlay.style.cssText = `
                    position: fixed;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 122, 255, 0.9);
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    font-size: 12px;
                    z-index: 10001;
                `;
          overlay.textContent =
            "Press Ctrl+Enter or click Submit when done pasting your private key";
          document.body.appendChild(overlay);

          // Remove overlay when input is submitted
          input.addEventListener("keydown", () => {
            if (document.body.contains(overlay)) {
              document.body.removeChild(overlay);
            }
          });
        }

        testKalshiSetup() {
          this.log("üß™ Testing Kalshi Setup...", "info");

          // Check API key ID
          let apiKey = this.getApiKey("kalshi");
          if (!apiKey) {
            apiKey = localStorage.getItem("kalshi_api_key");
          }

          if (apiKey) {
            this.log(
              `‚úÖ API Key ID: ${apiKey.substring(0, 8)}...${apiKey.substring(
                apiKey.length - 8
              )}`,
              "success"
            );
          } else {
            this.log("‚ùå API Key ID not set", "error");
          }

          // Check RSA private key
          const privateKey = localStorage.getItem("kalshi_private_key");
          if (privateKey) {
            this.log(
              `‚úÖ RSA Private Key: ${privateKey.substring(0, 20)}...`,
              "success"
            );
          } else {
            this.log("‚ùå RSA Private Key not set", "error");
          }

          // Test connectivity
          this.log("üåê Testing API connectivity...", "info");
          this.makeKalshiRequest("/markets").then((result) => {
            if (result) {
              this.log("‚úÖ API connectivity test passed!", "success");
            } else {
              this.log("‚ùå API connectivity test failed", "error");
            }
          });
        }

        async makeKalshiRequest(endpoint, method = "GET", body = null) {
          // Check profile API keys first, then fall back to legacy storage
          let apiKey = this.getApiKey("kalshi");
          if (!apiKey) {
            apiKey = localStorage.getItem("kalshi_api_key");
          }

          if (!apiKey) {
            this.log("‚ùå Kalshi API Key ID not set", "error");
            this.log("üí° Set it with: kalshi set-api-key YOUR_KEY_ID", "info");
            return null;
          }

          // Get the RSA private key
          const privateKey = localStorage.getItem("kalshi_private_key");
          if (!privateKey) {
            this.log("‚ùå Kalshi RSA Private Key not set", "error");
            this.log(
              'üí° Set it with: kalshi set-key "YOUR_PRIVATE_KEY"',
              "info"
            );
            return null;
          }

          try {
            // Generate timestamp
            const timestamp = Date.now().toString();

            // Create message to sign: timestamp + method + path
            const messageToSign = timestamp + method + endpoint;

            // Sign the message using RSA-PSS
            const signature = await this.signWithRSAPSS(
              privateKey,
              messageToSign
            );

            const baseUrl = "https://api.elections.kalshi.com/trade-api/v2";
            const headers = {
              Accept: "application/json",
              "Content-Type": "application/json",
              "KALSHI-ACCESS-KEY": apiKey,
              "KALSHI-ACCESS-TIMESTAMP": timestamp,
              "KALSHI-ACCESS-SIGNATURE": signature,
            };

            const config = {
              method: method,
              headers: headers,
            };

            if (body) {
              config.body = JSON.stringify(body);
            }

            this.log(
              `üåê Making authenticated ${method} request to Kalshi API...`,
              "info"
            );
            const response = await fetch(`${baseUrl}${endpoint}`, config);

            if (!response.ok) {
              let errorMsg = `HTTP ${response.status}`;
              try {
                const errorData = await response.json();
                errorMsg =
                  errorData.error?.message || errorData.message || errorMsg;
              } catch (e) {
                // Ignore JSON parse errors
              }
              throw new Error(errorMsg);
            }

            return await response.json();
          } catch (error) {
            this.log(`‚ùå Kalshi API Error: ${error.message}`, "error");
            if (error.message.includes("Failed to fetch")) {
              this.log(
                "üí° This is likely a CORS issue. Kalshi API requires server-side authentication.",
                "info"
              );
              this.log(
                "üí° Consider using a backend proxy or server-side implementation.",
                "info"
              );
            } else if (error.message.includes("signWithRSAPSS")) {
              this.log(
                "üí° RSA signing failed. This requires a backend implementation for security.",
                "info"
              );
            }
            console.error("Kalshi API Error:", error);
            return null;
          }
        }

        async signWithRSAPSS(privateKeyPem, message) {
          // Note: RSA-PSS signing in browser requires Web Crypto API or a library
          // For security reasons, private keys should not be used directly in browsers
          // This is a placeholder that would need proper implementation
          throw new Error(
            "RSA-PSS signing requires server-side implementation for security"
          );
        }

        async makeKalshiRequestViaProxy(endpoint, method = "GET", body = null) {
          // Check profile API keys first, then fall back to legacy storage
          let apiKey = this.getApiKey("kalshi");
          if (!apiKey) {
            apiKey = localStorage.getItem("kalshi_api_key");
          }

          if (!apiKey) {
            this.log("‚ùå Kalshi API Key ID not set", "error");
            this.log("üí° Set it with: kalshi set-api-key YOUR_KEY_ID", "info");
            return null;
          }

          // Get the RSA private key
          const privateKey = localStorage.getItem("kalshi_private_key");
          if (!privateKey) {
            this.log("‚ùå Kalshi RSA Private Key not set", "error");
            this.log(
              'üí° Set it with: kalshi set-key "YOUR_PRIVATE_KEY"',
              "info"
            );
            return null;
          }

          try {
            const proxyUrl = "http://localhost:3001";

            // Send credentials in request body instead of headers to avoid size limits
            const requestBody = {
              apiKey: apiKey,
              privateKey: privateKey,
              endpoint: endpoint,
              method: method,
              body: body,
            };

            const config = {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
              body: JSON.stringify(requestBody),
            };

            this.log(`üåê Making request via Kalshi CORS proxy...`, "info");
            const response = await fetch(`${proxyUrl}/kalshi-proxy`, config);

            if (!response.ok) {
              let errorMsg = `HTTP ${response.status}`;
              try {
                const errorData = await response.json();
                errorMsg =
                  errorData.error?.message || errorData.message || errorMsg;
              } catch (e) {
                // Ignore JSON parse errors
              }
              throw new Error(errorMsg);
            }

            return await response.json();
          } catch (error) {
            this.log(`‚ùå Kalshi Proxy Error: ${error.message}`, "error");
            console.error("Kalshi Proxy Error:", error);
            return null;
          }
        }

        async getKalshiMarkets(args) {
          this.log("üìä Fetching Kalshi markets...", "info");

          // Try proxy first, fall back to direct API
          let result = await this.makeKalshiRequestViaProxy("/markets");
          if (!result) {
            this.log("üí° Proxy failed, trying direct API...", "info");
            result = await this.makeKalshiRequest("/markets");
          }

          if (!result) {
            this.log("‚ùå Failed to retrieve markets", "error");
            this.log(
              "üí° Make sure Kalshi CORS proxy is running on port 3001",
              "info"
            );
            return;
          }

          this.log(
            `‚úÖ Found ${result.markets ? result.markets.length : 0} markets`,
            "success"
          );

          // Build query parameters from args
          const params = new URLSearchParams();
          params.append("limit", "10"); // Default limit

          for (let i = 0; i < args.length; i += 2) {
            if (args[i].startsWith("--")) {
              const key = args[i].substring(2);
              const value = args[i + 1];
              if (value) {
                params.set(key, value);
              }
            }
          }

          const endpoint = `/markets?${params.toString()}`;
          const data = await this.makeKalshiRequest(endpoint);

          if (data && data.markets && Array.isArray(data.markets)) {
            if (data.markets.length === 0) {
              this.log("No markets found", "warning");
              return;
            }

            this.log(`‚úÖ Found ${data.markets.length} market(s):`, "success");
            this.log("", "info");

            data.markets.forEach((market, index) => {
              this.log(`${index + 1}. ${market.title}`, "output");
              this.log(`   Ticker: ${market.ticker}`, "info");
              this.log(`   Status: ${market.status}`, "info");

              if (
                market.yes_ask !== undefined &&
                market.yes_bid !== undefined
              ) {
                this.log(
                  `   Yes: ${market.yes_bid}¬¢ / ${market.yes_ask}¬¢`,
                  "info"
                );
              }

              if (market.close_time) {
                const closeDate = new Date(market.close_time);
                this.log(`   Closes: ${closeDate.toLocaleString()}`, "info");
              }

              this.log("", "info");
            });
          } else {
            this.log("Failed to retrieve markets", "error");
          }
        }

        async getKalshiEvents(args) {
          this.log("üìÖ Fetching Kalshi events...", "info");

          // Build query parameters
          const params = new URLSearchParams();
          params.append("limit", "10"); // Default limit

          for (let i = 0; i < args.length; i += 2) {
            if (args[i].startsWith("--")) {
              const key = args[i].substring(2);
              const value = args[i + 1];
              if (value) {
                params.set(key, value);
              }
            }
          }

          const endpoint = `/events?${params.toString()}`;
          const data = await this.makeKalshiRequest(endpoint);

          if (data && data.events && Array.isArray(data.events)) {
            if (data.events.length === 0) {
              this.log("No events found", "warning");
              return;
            }

            this.log(`‚úÖ Found ${data.events.length} event(s):`, "success");
            this.log("", "info");

            data.events.forEach((event, index) => {
              this.log(`${index + 1}. ${event.title}`, "output");
              this.log(`   Ticker: ${event.event_ticker}`, "info");
              this.log(`   Status: ${event.status}`, "info");
              this.log(`   Category: ${event.category}`, "info");

              if (event.strike_date) {
                const strikeDate = new Date(event.strike_date);
                this.log(
                  `   Strike Date: ${strikeDate.toLocaleDateString()}`,
                  "info"
                );
              }

              if (event.mutually_exclusive !== undefined) {
                this.log(
                  `   Mutually Exclusive: ${
                    event.mutually_exclusive ? "Yes" : "No"
                  }`,
                  "info"
                );
              }

              this.log("", "info");
            });
          } else {
            this.log("Failed to retrieve events", "error");
          }
        }

        async getKalshiBalance() {
          this.log("üí∞ Fetching Kalshi balance...", "info");

          const data = await this.makeKalshiRequest("/portfolio/balance");

          if (data && data.balance !== undefined) {
            this.log("‚úÖ KALSHI ACCOUNT BALANCE:", "success");
            this.log("", "info");

            // Convert cents to dollars
            const balanceDollars = (data.balance / 100).toFixed(2);
            const pnlDollars =
              data.pnl !== undefined ? (data.pnl / 100).toFixed(2) : "N/A";

            this.log(`üíµ Available Balance: $${balanceDollars}`, "output");

            if (data.portfolio_value !== undefined) {
              const portfolioValueDollars = (
                data.portfolio_value / 100
              ).toFixed(2);
              this.log(
                `üìä Portfolio Value: $${portfolioValueDollars}`,
                "output"
              );
            }

            if (data.pnl !== undefined) {
              const pnlColor = data.pnl >= 0 ? "success" : "error";
              const pnlPrefix = data.pnl >= 0 ? "+" : "";
              this.log(`${pnlPrefix}$${pnlDollars} PnL`, pnlColor);
            }
          } else {
            this.log("Failed to retrieve balance", "error");
          }
        }

        async searchKalshiMarkets(query) {
          if (!query || query.trim() === "") {
            this.log("‚ùå Please provide a search query", "error");
            this.log("Usage: kalshi search <query>", "info");
            return;
          }

          this.log(`üîç Searching for: "${query}"...`, "info");

          const params = new URLSearchParams();
          params.append("search", query);
          params.append("limit", "20");

          const endpoint = `/markets?${params.toString()}`;
          const data = await this.makeKalshiRequest(endpoint);

          if (data && data.markets && Array.isArray(data.markets)) {
            if (data.markets.length === 0) {
              this.log(`No markets found for "${query}"`, "warning");
              return;
            }

            this.log(
              `‚úÖ Found ${data.markets.length} market(s) matching "${query}":`,
              "success"
            );
            this.log("", "info");

            data.markets.forEach((market, index) => {
              this.log(`${index + 1}. ${market.title}`, "output");
              this.log(`   Ticker: ${market.ticker}`, "info");
              this.log(`   Status: ${market.status}`, "info");

              if (
                market.yes_ask !== undefined &&
                market.yes_bid !== undefined
              ) {
                this.log(
                  `   Yes: ${market.yes_bid}¬¢ / ${market.yes_ask}¬¢`,
                  "info"
                );
              }

              this.log("", "info");
            });
          } else {
            this.log("Search failed", "error");
          }
        }

        async getKalshiMarketDetails(ticker) {
          if (!ticker) {
            this.log("‚ùå Please provide a market ticker", "error");
            this.log("Usage: kalshi market <ticker>", "info");
            return;
          }

          this.log(`üìä Fetching details for market: ${ticker}...`, "info");

          const endpoint = `/markets/${ticker}`;
          const data = await this.makeKalshiRequest(endpoint);

          if (data && data.market) {
            const market = data.market;

            this.log("‚úÖ MARKET DETAILS:", "success");
            this.log("", "info");
            this.log(`üìã Title: ${market.title}`, "output");
            this.log(`üé´ Ticker: ${market.ticker}`, "info");
            this.log(`üìä Status: ${market.status}`, "info");
            this.log(`üìÇ Category: ${market.category}`, "info");

            if (market.subtitle) {
              this.log(`üìù Subtitle: ${market.subtitle}`, "info");
            }

            this.log("", "info");
            this.log("üí∞ PRICING:", "info");

            if (market.yes_bid !== undefined && market.yes_ask !== undefined) {
              this.log(`  Yes Bid: ${market.yes_bid}¬¢`, "output");
              this.log(`  Yes Ask: ${market.yes_ask}¬¢`, "output");
            }

            if (market.no_bid !== undefined && market.no_ask !== undefined) {
              this.log(`  No Bid: ${market.no_bid}¬¢`, "output");
              this.log(`  No Ask: ${market.no_ask}¬¢`, "output");
            }

            if (market.last_price !== undefined) {
              this.log(`  Last Price: ${market.last_price}¬¢`, "output");
            }

            this.log("", "info");
            this.log("üìÖ TIMING:", "info");

            if (market.open_time) {
              const openDate = new Date(market.open_time);
              this.log(`  Opened: ${openDate.toLocaleString()}`, "info");
            }

            if (market.close_time) {
              const closeDate = new Date(market.close_time);
              this.log(`  Closes: ${closeDate.toLocaleString()}`, "info");
            }

            if (market.expected_expiration_time) {
              const expDate = new Date(market.expected_expiration_time);
              this.log(
                `  Expected Expiration: ${expDate.toLocaleString()}`,
                "info"
              );
            }

            if (market.volume) {
              this.log("", "info");
              this.log(`üìä Volume: ${market.volume} contracts`, "info");
            }

            if (market.open_interest) {
              this.log(
                `üìà Open Interest: ${market.open_interest} contracts`,
                "info"
              );
            }
          } else {
            this.log(
              `Failed to retrieve details for market: ${ticker}`,
              "error"
            );
          }
        }
      }

      // Add this helper function to fund the Omega wallet via relayer
      async function fundOmegaWallet(address) {
        try {
          const response = await fetch(`${RELAYER_URL}/fund`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ address, amount: "0.1" }),
          });
          const data = await response.json();
          if (data.success) {
            window.terminal.log(
              `‚úÖ Your wallet is being funded! Tx: ${data.txHash}`,
              "success"
            );
            window.terminal.log(
              "Please wait a few seconds before using your wallet.",
              "info"
            );
          } else {
            window.terminal.log(
              "‚ùå Funding failed: " + (data.error || "Unknown error"),
              "error"
            );
          }
        } catch (err) {
          window.terminal.log(
            "‚ùå Funding request failed: " + err.message,
            "error"
          );
        }
      }

      // Nuclear option: Completely block Phantom and force MetaMask
      (function () {
        console.log(
          "üö® PHANTOM BLOCKER: Starting aggressive Phantom blocking..."
        );

        // Store original providers before any manipulation
        const originalProviders = window.ethereum?.providers || [];
        console.log(
          "Original providers:",
          originalProviders.map((p) => ({
            isMetaMask: p.isMetaMask,
            isPhantom: p.isPhantom,
          }))
        );

        // Immediately block Phantom at the global level
        if (window.ethereum && window.ethereum.isPhantom) {
          console.log("üö® PHANTOM DETECTED: Blocking immediately");
          const metamaskProvider = originalProviders.find((p) => p.isMetaMask);
          if (metamaskProvider) {
            window.ethereum = metamaskProvider;
            console.log("‚úÖ MetaMask forced as primary provider");
          } else {
            window.ethereum = null;
            console.log("‚ùå No MetaMask available - blocking all wallets");
          }
        }

        if (
          window.ethereum &&
          window.ethereum.providers &&
          Array.isArray(window.ethereum.providers)
        ) {
          const metamaskProvider = window.ethereum.providers.find(
            (p) => p.isMetaMask
          );
          const phantomProvider = window.ethereum.providers.find(
            (p) => p.isPhantom
          );

          console.log("Found providers:", {
            metamask: !!metamaskProvider,
            phantom: !!phantomProvider,
          });

          if (metamaskProvider) {
            // Completely replace window.ethereum with MetaMask
            window.ethereum = metamaskProvider;
            console.log("‚úÖ MetaMask provider selected and forced");

            // Completely disable Phantom
            if (phantomProvider) {
              phantomProvider.isPhantom = false;
              phantomProvider.request = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              phantomProvider.send = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              phantomProvider.on = () => {};
              phantomProvider.removeListener = () => {};
              phantomProvider.isConnected = () => false;
              phantomProvider.connect = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              console.log("üö´ Phantom provider completely disabled");
            }
          } else if (phantomProvider) {
            // Only Phantom available - block it completely
            console.warn("üö® Only Phantom detected - blocking connection");
            window.ethereum = null;
            console.log("‚ùå Phantom blocked - no wallet available");
          }
        }

        // Nuclear safety check - if we detect Phantom at any point, block it
        const checkAndBlockPhantom = () => {
          if (window.ethereum && window.ethereum.isPhantom) {
            console.log("üö® PHANTOM DETECTED in safety check - blocking");
            const metamaskProvider = originalProviders.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              window.ethereum = metamaskProvider;
              console.log("‚úÖ MetaMask restored after Phantom detection");
            } else {
              window.ethereum = null;
              console.log("‚ùå No MetaMask available - blocking all wallets");
            }
          }
        };

        // Run safety check immediately and set up periodic checks
        checkAndBlockPhantom();
        setInterval(checkAndBlockPhantom, 500); // Check every 500ms for more aggressive blocking

        // Also block any attempts to restore Phantom
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function (obj, prop, descriptor) {
          if (
            obj === window &&
            prop === "ethereum" &&
            descriptor.value &&
            descriptor.value.isPhantom
          ) {
            console.log(
              "üö® BLOCKED: Attempt to restore Phantom via Object.defineProperty"
            );
            const metamaskProvider = originalProviders.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              descriptor.value = metamaskProvider;
            } else {
              descriptor.value = null;
            }
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };

        console.log("üö® PHANTOM BLOCKER: Setup complete");
      })();
    </script>
    <script>
      // Force cache busting by adding a version parameter
      const scriptVersion = Date.now();
      console.log("Terminal script version:", scriptVersion);

      // Clear any existing terminal instance
      if (window.terminal) {
        console.log("Clearing existing terminal instance");
        window.terminal = null;
      }

      // Polymarket API Integration (Simple!)
      console.log("üîß DEBUG: Loading Polymarket functions...");

      // Add Polymarket methods directly to OmegaMinerTerminal prototype
      // This needs to happen BEFORE the terminal instance is created
      if (typeof OmegaMinerTerminal !== "undefined") {
        console.log(
          "üîß DEBUG: OmegaMinerTerminal found, adding Polymarket functions..."
        );

        // Add Polymarket methods to the terminal prototype
        OmegaMinerTerminal.prototype.handlePolymarketCommand = async function (
          args
        ) {
          this.log(
            "üîß DEBUG: handlePolymarketCommand called with args:",
            "info"
          );
          console.log("DEBUG: handlePolymarketCommand args:", args);

          if (!args || args.length < 2) {
            this.showPolymarketHelp();
            return;
          }

          const subcommand = args[1].toLowerCase();
          this.log(`üîß DEBUG: Processing subcommand: ${subcommand}`, "info");

          switch (subcommand) {
            case "help":
              this.showPolymarketHelp();
              break;
            case "markets":
              await this.getPolymarketMarkets();
              break;
            case "active":
              await this.getPolymarketActiveMarkets();
              break;
            case "trending":
              await this.getPolymarketTrendingMarkets();
              break;
            case "search":
              if (args.length < 3) {
                this.log("‚ùå Usage: polymarket search <query>", "error");
                return;
              }
              const query = args.slice(2).join(" ");
              await this.searchPolymarketMarkets(query);
              break;
            case "events":
              await this.getPolymarketEvents();
              break;
            case "recent":
              await this.getPolymarketRecentEvents();
              break;
            case "breaking":
              await this.getPolymarketBreaking();
              break;
            case "new":
              await this.getPolymarketNew();
              break;
            case "politics":
              await this.getPolymarketPolitics();
              break;
            case "sports":
              await this.getPolymarketSports();
              break;
            case "crypto":
              await this.getPolymarketCrypto();
              break;
            case "earnings":
              await this.getPolymarketEarnings();
              break;
            case "geopolitics":
              await this.getPolymarketGeopolitics();
              break;
            case "tech":
              await this.getPolymarketTech();
              break;
            case "culture":
              await this.getPolymarketCulture();
              break;
            case "world":
              await this.getPolymarketWorld();
              break;
            case "economy":
              await this.getPolymarketEconomy();
              break;
            case "trump":
              await this.getPolymarketTrump();
              break;
            case "elections":
              await this.getPolymarketElections();
              break;
            default:
              this.log(`‚ùå Unknown Polymarket command: ${subcommand}`, "error");
              this.showPolymarketHelp();
          }
        };

        OmegaMinerTerminal.prototype.showPolymarketHelp = function () {
          this.log("üéØ POLYMARKET PREDICTION MARKETS", "info");
          this.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", "info");
          this.log("", "info");
          this.log("üìã MAIN COMMANDS:", "info");
          this.log("  polymarket help          Show this help", "output");
          this.log(
            "  polymarket markets       Get current active markets",
            "output"
          );
          this.log(
            "  polymarket trending      Get top volume markets",
            "output"
          );
          this.log(
            "  polymarket events        Get recent events (last 6 months)",
            "output"
          );
          this.log(
            "  polymarket recent        Get very recent events (last month)",
            "output"
          );
          this.log("  polymarket search <q>    Search markets", "output");
          this.log("", "info");
          this.log("üî• CATEGORY COMMANDS:", "info");
          this.log(
            "  polymarket breaking      Breaking news markets",
            "output"
          );
          this.log("  polymarket new           Newest markets", "output");
          this.log("  polymarket politics      Political markets", "output");
          this.log("  polymarket sports        Sports markets", "output");
          this.log("  polymarket crypto        Crypto markets", "output");
          this.log("  polymarket earnings      Earnings markets", "output");
          this.log("  polymarket geopolitics   Geopolitical markets", "output");
          this.log("  polymarket tech          Technology markets", "output");
          this.log("  polymarket culture       Culture markets", "output");
          this.log("  polymarket world         World events", "output");
          this.log("  polymarket economy       Economic markets", "output");
          this.log(
            "  polymarket trump         Trump-related markets",
            "output"
          );
          this.log("  polymarket elections     Election markets", "output");
          this.log("", "info");
          this.log("üéØ EXAMPLES:", "info");
          this.log(
            "  polymarket markets       # Current active markets",
            "info"
          );
          this.log(
            "  polymarket trending      # Highest volume markets",
            "info"
          );
          this.log(
            "  polymarket politics      # Political predictions",
            "info"
          );
          this.log("  polymarket crypto        # Crypto predictions", "info");
          this.log(
            "  polymarket breaking      # Breaking news markets",
            "info"
          );
          this.log(
            '  polymarket search "AI"   # Search for AI markets',
            "info"
          );
          this.log("", "info");
          this.log(
            "üí° Using Polymarket CORS proxy (localhost:3002) - no API key required!",
            "info"
          );
        };

        OmegaMinerTerminal.prototype.setPolymarketApiKey = function (apiKey) {
          // Store in unified API key system
          let apiKeys = JSON.parse(
            localStorage.getItem("omega_terminal_api_keys") || "{}"
          );
          apiKeys.polymarket = apiKey;
          localStorage.setItem(
            "omega_terminal_api_keys",
            JSON.stringify(apiKeys)
          );

          this.log("‚úÖ Polymarket API key saved successfully!", "success");
          this.log("üí° You can now use polymarket commands", "info");
        };

        OmegaMinerTerminal.prototype.makePolymarketRequest = async function (
          endpoint
        ) {
          this.log(
            `üîß DEBUG: makePolymarketRequest called with endpoint: ${endpoint}`,
            "info"
          );
          try {
            // Use CORS proxy to avoid browser restrictions
            const proxyUrl = "http://localhost:3002";
            const url = `${proxyUrl}/polymarket${endpoint}`;
            this.log(`üîß DEBUG: Making request to: ${url}`, "info");

            const response = await fetch(url, {
              method: "GET",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
            });

            this.log(`üîß DEBUG: Response status: ${response.status}`, "info");

            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const data = await response.json();
            this.log(`üîß DEBUG: Response data received:`, "info");
            console.log("DEBUG: Polymarket API response:", data);
            return data;
          } catch (error) {
            this.log(`‚ùå Polymarket API Error: ${error.message}`, "error");
            this.log(
              `üí° Make sure the Polymarket proxy is running: node polymarket-proxy.js`,
              "info"
            );
            return null;
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketMarkets = async function () {
          this.log("üìä Fetching comprehensive Polymarket markets...", "info");

          // Use the correct API approach per official docs - events endpoint for active markets
          const data = await this.makePolymarketRequest(
            `/events?order=id&ascending=false&closed=false&limit=100`
          );

          if (!data) return;

          // Handle both array format and {data: array} format
          const events = Array.isArray(data) ? data : data.data || [];

          if (events && events.length > 0) {
            // Convert events to markets and filter for active markets with volume
            const sortedMarkets = events
              .filter((event) => {
                // Only show events with markets and volume
                if (!event.markets || !event.markets.length) return false;

                // Get the primary market for volume calculation
                const primaryMarket = event.markets[0];
                if (
                  !primaryMarket ||
                  !primaryMarket.volume ||
                  primaryMarket.volume <= 0
                )
                  return false;

                return true;
              })
              .map((event) => {
                // Convert event to market format for display
                const primaryMarket = event.markets[0];
                return {
                  id: event.id,
                  question: event.title || "Untitled Event",
                  description: event.description || "",
                  volume: primaryMarket.volume || 0,
                  liquidity: primaryMarket.liquidity || 0,
                  active: true,
                  endDate: event.endDate || event.end_date,
                  startDate: event.startDate || event.start_date,
                  createdAt: event.createdAt || event.created_at,
                  slug: event.slug,
                  category: event.category || "",
                  featured: event.featured || false,
                  markets: event.markets || [],
                };
              })
              .sort((a, b) => {
                // Sort by volume first, then by creation date
                const volumeDiff = (b.volume || 0) - (a.volume || 0);
                if (Math.abs(volumeDiff) > 1000) {
                  // If volumes differ significantly
                  return volumeDiff;
                }
                // If volumes are similar, sort by creation date (newest first)
                const aDate = new Date(a.createdAt || a.startDate || 0);
                const bDate = new Date(b.createdAt || b.startDate || 0);
                return bDate - aDate;
              });

            // Create comprehensive UI for markets
            const marketsHtml = `
                    <div style="
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 16px 0;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 12px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 36px;
                                height: 36px;
                                background: linear-gradient(135deg, #06b6d4, #0891b2);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 12px;
                                font-size: 16px;
                            ">üìä</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    color: #ffffff;
                                ">Current Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                ">${
                                  sortedMarkets.length
                                } active markets found ‚Ä¢ Future end dates only</p>
                            </div>
                        </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                                ${sortedMarkets
                                  .slice(0, 12)
                                  .map(
                                    (market, index) => `
                                    <div style="
                                        background: #1a1a1a;
                                        border: 1px solid #333;
                                        border-radius: 12px;
                                        padding: 16px;
                                        transition: all 0.3s ease;
                                        position: relative;
                                        cursor: pointer;
                                        height: 280px;
                                        display: flex;
                                        flex-direction: column;
                                        justify-content: space-between;
                                    " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(0, 0, 0, 0.3)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'; this.style.borderColor='#333';">
                                        <div style="
                                            position: absolute;
                                            top: 0;
                                            left: 0;
                                            right: 0;
                                            height: 3px;
                                            background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            border-radius: 12px 12px 0 0;
                                        "></div>
                                        
                                        <!-- Header with volume -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            margin-bottom: 12px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 6px 12px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              market.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              market.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 4px 8px;
                                                    border-radius: 12px;
                                                    font-size: 10px;
                                                    font-weight: 500;
                                                ">üü¢ Active</div>
                                            `
                                                : ""
                                            }
                                        </div>

                                        <!-- Question/Title -->
                                        <h4 style="
                                            margin: 0 0 12px 0;
                                            font-size: 14px;
                                            font-weight: 600;
                                            line-height: 1.4;
                                            color: #ffffff;
                                            word-wrap: break-word;
                                            display: -webkit-box;
                                            -webkit-line-clamp: 3;
                                            -webkit-box-orient: vertical;
                                            overflow: hidden;
                                        ">${
                                          market.question || "Untitled Market"
                                        }</h4>

                                        <!-- Description (if short enough) -->
                                        ${
                                          market.description &&
                                          market.description.length < 100
                                            ? `
                                            <p style="
                                                margin: 0 0 12px 0;
                                                font-size: 12px;
                                                color: #bbb;
                                                line-height: 1.3;
                                                display: -webkit-box;
                                                -webkit-line-clamp: 2;
                                                -webkit-box-orient: vertical;
                                                overflow: hidden;
                                            ">${market.description}</p>
                                        `
                                            : ""
                                        }

                                        <!-- Trade button and category -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            margin-bottom: 8px;
                                        ">
                                            <a href="https://polymarket.com/market/${
                                              market.slug || market.id
                                            }" target="_blank" style="
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                text-decoration: none;
                                                display: inline-flex;
                                                align-items: center;
                                                gap: 6px;
                                                box-shadow: 0 3px 8px rgba(6, 182, 212, 0.3);
                                                transition: all 0.2s ease;
                                                flex: 1;
                                                justify-content: center;
                                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(6, 182, 212, 0.3)';">
                                                üîó Trade
                                            </a>
                                        </div>

                                        <!-- Footer info -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            font-size: 10px;
                                            color: #888;
                                            margin-top: 8px;
                                            padding-top: 8px;
                                            border-top: 1px solid #333;
                                        ">
                                            <span>üÜî ${market.id}</span>
                                            ${
                                              market.endDate
                                                ? `<span>üìÖ ${new Date(
                                                    market.endDate
                                                  ).toLocaleDateString()}</span>`
                                                : ""
                                            }
                                        </div>
                                    </div>
                                `
                                  )
                                  .join("")}
                        </div>
                        ${
                          sortedMarkets.length > 10
                            ? `
                            <div style="
                                text-align: center;
                                margin-top: 20px;
                                padding-top: 16px;
                                border-top: 1px solid #333;
                            ">
                                <button onclick="this.parentElement.parentElement.querySelector('.show-more-markets').style.display='grid'; this.style.display='none';" style="
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    color: white;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 20px;
                                    font-size: 14px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                    üîΩ Show More Markets (${
                                      sortedMarkets.length - 10
                                    } more)
                                </button>
                                <div class="show-more-markets" style="display: none; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; margin-top: 16px;">
                                    ${sortedMarkets
                                      .slice(10)
                                      .map(
                                        (market, index) => `
                                        <div style="
                                            background: #2a2a2a;
                                            border: 1px solid #444;
                                            border-radius: 8px;
                                            padding: 16px;
                                            transition: all 0.2s ease;
                                            position: relative;
                                        ">
                                            <div style="
                                                position: absolute;
                                                top: 0;
                                                left: 0;
                                                right: 0;
                                                height: 2px;
                                                background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            "></div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: flex-start;
                                                margin-bottom: 8px;
                                            ">
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 12px;
                                                    flex: 1;
                                                ">
                                                    <div style="
                                                        width: 28px;
                                                        height: 28px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        border-radius: 6px;
                                                        display: flex;
                                                        align-items: center;
                                                        justify-content: center;
                                                        color: white;
                                                        font-weight: 600;
                                                        font-size: 12px;
                                                    ">${index + 11}</div>
                                                    <div style="
                                                        flex: 1;
                                                        min-width: 0;
                                                    ">
                                                        <h4 style="
                                                            margin: 0 0 6px 0;
                                                            font-size: 15px;
                                                            font-weight: 500;
                                                            line-height: 1.3;
                                                            color: #ffffff;
                                                            word-wrap: break-word;
                                                        ">${
                                                          market.question ||
                                                          "Untitled Market"
                                                        }</h4>
                                                    </div>
                                                </div>
                                                <div style="
                                                    display: flex;
                                                    flex-direction: column;
                                                    align-items: flex-end;
                                                    gap: 6px;
                                                    flex-shrink: 0;
                                                    margin-left: 12px;
                                                ">
                                                    <div style="
                                                        background: #059669;
                                                        color: white;
                                                        padding: 4px 10px;
                                                        border-radius: 12px;
                                                        font-size: 11px;
                                                        font-weight: 600;
                                                        display: inline-block;
                                                    ">$${(
                                                      market.volume || 0
                                                    ).toLocaleString()}</div>
                                                    ${
                                                      market.active
                                                        ? `
                                                        <div style="
                                                            background: #059669;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">üü¢ Active</div>
                                                    `
                                                        : market.closed
                                                        ? `
                                                        <div style="
                                                            background: #dc2626;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">üî¥ Closed</div>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: center;
                                                font-size: 12px;
                                                color: #aaa;
                                                flex-wrap: wrap;
                                                gap: 8px;
                                            ">
                                                <span>üÜî ${market.id}</span>
                                                ${
                                                  market.endDateIso
                                                    ? `<span>üìÖ End: ${new Date(
                                                        market.endDateIso
                                                      ).toLocaleDateString()}</span>`
                                                    : market.startDateIso
                                                    ? `<span>üìÖ Start: ${new Date(
                                                        market.startDateIso
                                                      ).toLocaleDateString()}</span>`
                                                    : ""
                                                }
                                                ${
                                                  market.resolutionSource
                                                    ? `<span>üìã Source: ${market.resolutionSource}</span>`
                                                    : ""
                                                }
                                                ${
                                                  market.competitive
                                                    ? `<span>üèÜ Competitive</span>`
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                    `
                                      )
                                      .join("")}
                                </div>
                            </div>
                        `
                            : ""
                        }
                    </div>
                `;

            this.logHtml(marketsHtml, "output");
          } else {
            this.log("‚ùå No markets found", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketActiveMarkets =
          async function () {
            this.log("üéØ Fetching active markets...", "info");

            // Use events endpoint for active markets per official docs
            const data = await this.makePolymarketRequest(
              `/events?order=id&ascending=false&closed=false&limit=50`
            );
            if (!data) return;

            // Handle both array format and {data: array} format
            const events = Array.isArray(data) ? data : data.data || [];

            if (events && events.length > 0) {
              // Convert events to markets and filter for active markets
              const sortedMarkets = events
                .filter((event) => {
                  // Only show events with markets and volume
                  if (!event.markets || !event.markets.length) return false;

                  // Get the primary market for volume calculation
                  const primaryMarket = event.markets[0];
                  if (
                    !primaryMarket ||
                    !primaryMarket.volume ||
                    primaryMarket.volume <= 0
                  )
                    return false;

                  return true;
                })
                .map((event) => {
                  // Convert event to market format for display
                  const primaryMarket = event.markets[0];
                  return {
                    id: event.id,
                    question: event.title || "Untitled Event",
                    description: event.description || "",
                    volume: primaryMarket.volume || 0,
                    liquidity: primaryMarket.liquidity || 0,
                    active: true,
                    endDate: event.endDate || event.end_date,
                    startDate: event.startDate || event.start_date,
                    createdAt: event.createdAt || event.created_at,
                    slug: event.slug,
                    category: event.category || "",
                    featured: event.featured || false,
                    markets: event.markets || [],
                  };
                })
                .sort((a, b) => (b.volume || 0) - (a.volume || 0))
                .slice(0, 10);

              // Create modern UI for active markets
              const activeHtml = `
                    <div style="
                        background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.1) 100%);
                        border: 1px solid rgba(34, 197, 94, 0.2);
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        backdrop-filter: blur(10px);
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid rgba(34, 197, 94, 0.2);
                        ">
                            <div style="
                                width: 40px;
                                height: 40px;
                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 18px;
                            ">üî•</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    background: linear-gradient(135deg, #22c55e, #16a34a);
                                    -webkit-background-clip: text;
                                    -webkit-text-fill-color: transparent;
                                    background-clip: text;
                                ">Active Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #6b7280;
                                ">Top ${
                                  sortedMarkets.length
                                } trending markets by volume</p>
                            </div>
                        </div>
                        <div style="display: grid; gap: 16px;">
                            ${sortedMarkets
                              .map(
                                (market, index) => `
                                <div style="
                                    background: var(--poly-bg-primary);
                                    border: 1px solid var(--poly-border);
                                    border-radius: 12px;
                                    padding: 20px;
                                    transition: all 0.2s ease;
                                    position: relative;
                                    overflow: hidden;
                                ">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #22c55e, #16a34a);
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 12px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 32px;
                                                height: 32px;
                                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                                border-radius: 8px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 600;
                                                font-size: 14px;
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 500;
                                                    line-height: 1.4;
                                                    color: #1f2937;
                                                    word-wrap: break-word;
                                                ">${market.question}</h4>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #10b981, #059669);
                                                color: white;
                                                padding: 6px 12px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                display: inline-block;
                                            ">$${(
                                              market.volume || 0
                                            ).toLocaleString()}</div>
                                            <div style="
                                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                                color: white;
                                                padding: 4px 8px;
                                                border-radius: 12px;
                                                font-size: 11px;
                                                font-weight: 500;
                                                display: inline-block;
                                            ">üü¢ Active</div>
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #6b7280;
                                    ">
                                        <span>üÜî ${market.id}</span>
                                        ${
                                          market.end_date_iso
                                            ? `<span>üìÖ End: ${new Date(
                                                market.end_date_iso
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(activeHtml, "output");
            } else {
              this.log("‚ùå No active markets found", "error");
            }
          };

        OmegaMinerTerminal.prototype.getPolymarketTrendingMarkets =
          async function () {
            this.log("üî• Fetching highest volume markets...", "info");

            // Use events endpoint for trending markets per official docs
            const data = await this.makePolymarketRequest(
              `/events?order=id&ascending=false&closed=false&limit=100`
            );
            if (!data) return;

            // Handle both array format and {data: array} format
            const events = Array.isArray(data) ? data : data.data || [];

            if (events && events.length > 0) {
              // Convert events to markets and sort by volume for trending
              const trendingMarkets = events
                .filter((event) => {
                  // Only show events with markets and volume
                  if (!event.markets || !event.markets.length) return false;

                  // Get the primary market for volume calculation
                  const primaryMarket = event.markets[0];
                  if (
                    !primaryMarket ||
                    !primaryMarket.volume ||
                    primaryMarket.volume <= 0
                  )
                    return false;

                  return true;
                })
                .map((event) => {
                  // Convert event to market format for display
                  const primaryMarket = event.markets[0];
                  return {
                    id: event.id,
                    question: event.title || "Untitled Event",
                    description: event.description || "",
                    volume: primaryMarket.volume || 0,
                    liquidity: primaryMarket.liquidity || 0,
                    active: true,
                    endDate: event.endDate || event.end_date,
                    startDate: event.startDate || event.start_date,
                    createdAt: event.createdAt || event.created_at,
                    slug: event.slug,
                    category: event.category || "",
                    featured: event.featured || false,
                    markets: event.markets || [],
                  };
                })
                .sort((a, b) => (b.volume || 0) - (a.volume || 0))
                .slice(0, 8);

              // Create modern UI for trending markets with grid layout
              const trendingHtml = `
                    <div style="
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 16px 0;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 12px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 36px;
                                height: 36px;
                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 12px;
                                font-size: 16px;
                            ">üî•</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    color: #ffffff;
                                ">Trending Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                ">${
                                  trendingMarkets.length
                                } highest volume markets</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                            ${trendingMarkets
                              .map(
                                (market, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s ease;
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(0, 0, 0, 0.3)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #6b7280, #4b5563);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    
                                    <!-- Header with volume -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            background: linear-gradient(135deg, #059669, #047857);
                                            color: white;
                                            padding: 6px 12px;
                                            border-radius: 20px;
                                            font-size: 12px;
                                            font-weight: 600;
                                            box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                        ">$${(
                                          market.volume || 0
                                        ).toLocaleString()}</div>
                                        ${
                                          market.active
                                            ? `
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 4px 8px;
                                                border-radius: 12px;
                                                font-size: 10px;
                                                font-weight: 500;
                                            ">üü¢ Active</div>
                                        `
                                            : ""
                                        }
                                    </div>

                                    <!-- Question/Title -->
                                    <h4 style="
                                        margin: 0 0 12px 0;
                                        font-size: 14px;
                                        font-weight: 600;
                                        line-height: 1.4;
                                        color: #ffffff;
                                        word-wrap: break-word;
                                        display: -webkit-box;
                                        -webkit-line-clamp: 3;
                                        -webkit-box-orient: vertical;
                                        overflow: hidden;
                                    ">${
                                      market.question || "Untitled Market"
                                    }</h4>

                                    <!-- Trade button -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 8px;
                                    ">
                                        <a href="https://polymarket.com/market/${
                                          market.slug || market.id
                                        }" target="_blank" style="
                                            background: linear-gradient(135deg, #6b7280, #4b5563);
                                            color: white;
                                            padding: 8px 16px;
                                            border-radius: 20px;
                                            font-size: 12px;
                                            font-weight: 600;
                                            text-decoration: none;
                                            display: inline-flex;
                                            align-items: center;
                                            gap: 6px;
                                            box-shadow: 0 3px 8px rgba(107, 114, 128, 0.3);
                                            transition: all 0.2s ease;
                                            flex: 1;
                                            justify-content: center;
                                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(107, 114, 128, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(107, 114, 128, 0.3)';">
                                            üîó Trade
                                        </a>
                                    </div>

                                    <!-- Footer info -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 10px;
                                        color: #888;
                                        margin-top: 8px;
                                        padding-top: 8px;
                                        border-top: 1px solid #333;
                                    ">
                                        <span>üÜî ${market.id}</span>
                                        ${
                                          market.endDate
                                            ? `<span>üìÖ ${new Date(
                                                market.endDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(trendingHtml, "output");
            } else {
              this.log("‚ùå No trending markets found", "error");
            }
          };

        OmegaMinerTerminal.prototype.searchPolymarketMarkets = async function (
          query
        ) {
          this.log(`üîç Searching Polymarket for: "${query}"`, "info");

          const data = await this.makePolymarketRequest(
            `/markets?question=${encodeURIComponent(query)}&limit=15`
          );
          if (!data) return;

          // Handle both array format and {data: array} format
          const markets = Array.isArray(data) ? data : data.data || [];

          if (markets && markets.length > 0) {
            this.log(`üìä Found ${markets.length} matching markets:`, "success");
            markets.slice(0, 10).forEach((market, index) => {
              this.log(`${index + 1}. ${market.question}`, "output");
              this.log(`   üÜî ID: ${market.id}`, "info");
              this.log(
                `   üí∞ Volume: $${(market.volume || 0).toLocaleString()}`,
                "info"
              );
              if (market.end_date_iso) {
                this.log(
                  `   üìÖ End: ${new Date(
                    market.end_date_iso
                  ).toLocaleDateString()}`,
                  "info"
                );
              }
              this.log("", "info");
            });
          } else {
            this.log("‚ùå No markets found matching your search", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketEvents = async function () {
          this.log("üéØ Fetching recent Polymarket events...", "info");

          // Get more events and filter for recent ones (last 6 months)
          const data = await this.makePolymarketRequest(
            "/events?limit=50&order=createdAt&ascending=false"
          );
          if (!data) return;

          if (data && data.length > 0) {
            // Filter for recent events (last 6 months)
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

            const recentEvents = data.filter((event) => {
              if (!event.endDate && !event.startDate) return false;
              const eventDate = new Date(event.endDate || event.startDate);
              return eventDate > sixMonthsAgo;
            });

            if (recentEvents.length === 0) {
              this.log(
                "‚ùå No recent events found in the last 6 months",
                "error"
              );
              this.log(
                "üí° Try using different date filters or check if there are any active markets",
                "info"
              );
              return;
            }

            // Create enhanced UI for events with clickable URLs
            const eventsHtml = `
                    <div style="
                        background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
                        border: 1px solid #333;
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            height: 4px;
                            background: linear-gradient(90deg, #ec4899, #ef4444, #8b5cf6);
                        "></div>
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 24px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 48px;
                                height: 48px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 20px;
                                box-shadow: 0 4px 16px rgba(107, 114, 128, 0.3);
                            ">üéØ</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 20px;
                                    font-weight: 700;
                                    color: #ffffff;
                                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                                ">Recent Events</h3>
                                <p style="
                                    margin: 6px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                    font-weight: 500;
                                ">${
                                  recentEvents.length
                                } events found ‚Ä¢ Last 6 months</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                            ${recentEvents
                              .slice(0, 12)
                              .map(
                                (event, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s ease;
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                    " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(0, 0, 0, 0.3)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                            background: linear-gradient(90deg, #06b6d4, #0891b2);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 16px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 36px;
                                                height: 36px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                border-radius: 10px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 700;
                                                font-size: 14px;
                                                box-shadow: 0 4px 12px rgba(236, 72, 153, 0.3);
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 600;
                                                    line-height: 1.4;
                                                    color: #ffffff;
                                                    word-wrap: break-word;
                                                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                                                ">${
                                                  event.title ||
                                                  "Untitled Event"
                                                }</h4>
                                                ${
                                                  event.subtitle
                                                    ? `
                                                    <p style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 13px;
                                                        color: #bbb;
                                                        line-height: 1.3;
                                                    ">${event.subtitle}</p>
                                                `
                                                    : ""
                                                }
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 8px;
                                                    margin-top: 8px;
                                                ">
                                                    <a href="https://polymarket.com/event/${
                                                      event.slug || event.id
                                                    }" target="_blank" style="
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        color: white;
                                                        padding: 6px 12px;
                                                        border-radius: 20px;
                                                        font-size: 12px;
                                                        font-weight: 600;
                                                        text-decoration: none;
                                                        display: inline-flex;
                                                        align-items: center;
                                                        gap: 6px;
                                                        box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                                        transition: all 0.2s ease;
                                                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                                        üîó View on Polymarket
                                                    </a>
                                                    ${
                                                      event.category
                                                        ? `
                                                        <span style="
                                                            background: rgba(6, 182, 212, 0.2);
                                                            color: #06b6d4;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                            border: 1px solid rgba(6, 182, 212, 0.3);
                                                        ">${event.category}</span>
                                                    `
                                                        : ""
                                                    }
                                                    ${
                                                      event.featured
                                                        ? `
                                                        <span style="
                                                            background: linear-gradient(135deg, #f59e0b, #d97706);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                        ">‚≠ê Featured</span>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 13px;
                                                font-weight: 700;
                                                display: inline-block;
                                                box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              event.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              event.liquidity
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
                                                ">üíß $${event.liquidity.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.openInterest
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #f59e0b, #d97706);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(245, 158, 11, 0.3);
                                                ">üìä $${event.openInterest.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">üü¢ Active</div>
                                            `
                                                : event.closed
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #dc2626, #b91c1c);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(220, 38, 38, 0.3);
                                                ">üî¥ Closed</div>
                                            `
                                                : ""
                                            }
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #aaa;
                                        font-weight: 500;
                                        flex-wrap: wrap;
                                        gap: 8px;
                                    ">
                                        <span>üÜî ${event.id}</span>
                                        ${
                                          event.endDate
                                            ? `<span>üìÖ End: ${new Date(
                                                event.endDate
                                              ).toLocaleDateString()}</span>`
                                            : event.startDate
                                            ? `<span>üìÖ Start: ${new Date(
                                                event.startDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                        ${
                                          event.resolutionSource
                                            ? `<span>üìã Source: ${event.resolutionSource}</span>`
                                            : ""
                                        }
                                        ${
                                          event.competitive
                                            ? `<span>üèÜ Competitive</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                        ${
                          recentEvents.length > 6
                            ? `
                            <div style="
                                text-align: center;
                                margin-top: 20px;
                                padding-top: 16px;
                                border-top: 1px solid #333;
                            ">
                                <button onclick="this.parentElement.parentElement.querySelector('.show-more-events').style.display='grid'; this.style.display='none';" style="
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    color: white;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 20px;
                                    font-size: 14px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                    üîΩ Show More Events (${
                                      recentEvents.length - 6
                                    } more)
                                </button>
                                <div class="show-more-events" style="display: none; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; margin-top: 16px;">
                                    ${recentEvents
                                      .slice(6)
                                      .map(
                                        (event, index) => `
                                        <div style="
                                            background: #2a2a2a;
                                            border: 1px solid #444;
                                            border-radius: 8px;
                                            padding: 16px;
                                            transition: all 0.2s ease;
                                            position: relative;
                                        ">
                                            <div style="
                                                position: absolute;
                                                top: 0;
                                                left: 0;
                                                right: 0;
                                                height: 2px;
                                                background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            "></div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: flex-start;
                                                margin-bottom: 8px;
                                            ">
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 12px;
                                                    flex: 1;
                                                ">
                                                    <div style="
                                                        width: 28px;
                                                        height: 28px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        border-radius: 6px;
                                                        display: flex;
                                                        align-items: center;
                                                        justify-content: center;
                                                        color: white;
                                                        font-weight: 600;
                                                        font-size: 12px;
                                                    ">${index + 7}</div>
                                                    <div style="
                                                        flex: 1;
                                                        min-width: 0;
                                                    ">
                                                        <h4 style="
                                                            margin: 0 0 6px 0;
                                                            font-size: 15px;
                                                            font-weight: 500;
                                                            line-height: 1.3;
                                                            color: #ffffff;
                                                            word-wrap: break-word;
                                                        ">${
                                                          event.title ||
                                                          "Untitled Event"
                                                        }</h4>
                                                    </div>
                                                </div>
                                                <div style="
                                                    display: flex;
                                                    flex-direction: column;
                                                    align-items: flex-end;
                                                    gap: 6px;
                                                    flex-shrink: 0;
                                                    margin-left: 12px;
                                                ">
                                                    <div style="
                                                        background: #059669;
                                                        color: white;
                                                        padding: 4px 10px;
                                                        border-radius: 12px;
                                                        font-size: 11px;
                                                        font-weight: 600;
                                                        display: inline-block;
                                                    ">$${(
                                                      event.volume || 0
                                                    ).toLocaleString()}</div>
                                                    ${
                                                      event.active
                                                        ? `
                                                        <div style="
                                                            background: #059669;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">üü¢ Active</div>
                                                    `
                                                        : event.closed
                                                        ? `
                                                        <div style="
                                                            background: #dc2626;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">üî¥ Closed</div>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: center;
                                                font-size: 12px;
                                                color: #aaa;
                                                flex-wrap: wrap;
                                                gap: 8px;
                                            ">
                                                <span>üÜî ${event.id}</span>
                                                ${
                                                  event.endDate
                                                    ? `<span>üìÖ End: ${new Date(
                                                        event.endDate
                                                      ).toLocaleDateString()}</span>`
                                                    : event.startDate
                                                    ? `<span>üìÖ Start: ${new Date(
                                                        event.startDate
                                                      ).toLocaleDateString()}</span>`
                                                    : ""
                                                }
                                                ${
                                                  event.resolutionSource
                                                    ? `<span>üìã Source: ${event.resolutionSource}</span>`
                                                    : ""
                                                }
                                                ${
                                                  event.competitive
                                                    ? `<span>üèÜ Competitive</span>`
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                    `
                                      )
                                      .join("")}
                                </div>
                            </div>
                        `
                            : ""
                        }
                    </div>
                `;

            this.logHtml(eventsHtml, "output");
          } else {
            this.log("‚ùå No events found", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketRecentEvents =
          async function () {
            this.log("üéØ Fetching very recent Polymarket events...", "info");

            // Get very recent events (last month) using API date filtering
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            const dateFilter = oneMonthAgo.toISOString().split("T")[0]; // YYYY-MM-DD format

            const data = await this.makePolymarketRequest(
              `/events?limit=30&start_date_min=${dateFilter}&order=createdAt&ascending=false`
            );
            if (!data) return;

            if (data && data.length > 0) {
              const recentEvents = data.slice(0, 8);

              // Create enhanced UI for recent events with clickable URLs
              const recentHtml = `
                    <div style="
                        background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
                        border: 1px solid #333;
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            height: 4px;
                            background: linear-gradient(90deg, #06b6d4, #0891b2, #06b6d4);
                        "></div>
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 24px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 48px;
                                height: 48px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 20px;
                                box-shadow: 0 4px 16px rgba(107, 114, 128, 0.3);
                            ">‚ö°</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 20px;
                                    font-weight: 700;
                                    color: #ffffff;
                                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                                ">Very Recent Events</h3>
                                <p style="
                                    margin: 6px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                    font-weight: 500;
                                ">${
                                  recentEvents.length
                                } events found ‚Ä¢ Last month</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                            ${recentEvents
                              .map(
                                (event, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s ease;
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                    " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(0, 0, 0, 0.3)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #06b6d4, #0891b2);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 16px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 36px;
                                                height: 36px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                border-radius: 10px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 700;
                                                font-size: 14px;
                                                box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 600;
                                                    line-height: 1.4;
                                                    color: #ffffff;
                                                    word-wrap: break-word;
                                                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                                                ">${
                                                  event.title ||
                                                  "Untitled Event"
                                                }</h4>
                                                ${
                                                  event.subtitle
                                                    ? `
                                                    <p style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 13px;
                                                        color: #bbb;
                                                        line-height: 1.3;
                                                    ">${event.subtitle}</p>
                                                `
                                                    : ""
                                                }
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 8px;
                                                    margin-top: 8px;
                                                ">
                                                    <a href="https://polymarket.com/event/${
                                                      event.slug || event.id
                                                    }" target="_blank" style="
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        color: white;
                                                        padding: 6px 12px;
                                                        border-radius: 20px;
                                                        font-size: 12px;
                                                        font-weight: 600;
                                                        text-decoration: none;
                                                        display: inline-flex;
                                                        align-items: center;
                                                        gap: 6px;
                                                        box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                                        transition: all 0.2s ease;
                                                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                                        üîó View on Polymarket
                                                    </a>
                                                    ${
                                                      event.category
                                                        ? `
                                                        <span style="
                                                            background: rgba(6, 182, 212, 0.2);
                                                            color: #06b6d4;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                            border: 1px solid rgba(6, 182, 212, 0.3);
                                                        ">${event.category}</span>
                                                    `
                                                        : ""
                                                    }
                                                    ${
                                                      event.featured
                                                        ? `
                                                        <span style="
                                                            background: linear-gradient(135deg, #f59e0b, #d97706);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                        ">‚≠ê Featured</span>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 13px;
                                                font-weight: 700;
                                                display: inline-block;
                                                box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              event.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              event.liquidity
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
                                                ">üíß $${event.liquidity.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.openInterest
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #f59e0b, #d97706);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(245, 158, 11, 0.3);
                                                ">üìä $${event.openInterest.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">üü¢ Active</div>
                                            `
                                                : event.closed
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #dc2626, #b91c1c);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(220, 38, 38, 0.3);
                                                ">üî¥ Closed</div>
                                            `
                                                : ""
                                            }
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #aaa;
                                        font-weight: 500;
                                        flex-wrap: wrap;
                                        gap: 8px;
                                    ">
                                        <span>üÜî ${event.id}</span>
                                        ${
                                          event.endDate
                                            ? `<span>üìÖ End: ${new Date(
                                                event.endDate
                                              ).toLocaleDateString()}</span>`
                                            : event.startDate
                                            ? `<span>üìÖ Start: ${new Date(
                                                event.startDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                        ${
                                          event.resolutionSource
                                            ? `<span>üìã Source: ${event.resolutionSource}</span>`
                                            : ""
                                        }
                                        ${
                                          event.competitive
                                            ? `<span>üèÜ Competitive</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(recentHtml, "output");

              if (data.length === 0) {
                this.log(
                  "‚ùå No very recent events found in the last month",
                  "error"
                );
                this.log(
                  'üí° Try "polymarket events" for events from the last 6 months',
                  "info"
                );
              }
            } else {
              this.log("‚ùå No recent events found", "error");
            }
          };

        // Category-specific functions
        OmegaMinerTerminal.prototype.getPolymarketBreaking = async function () {
          this.log("üî• Fetching breaking news markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "breaking",
            "Breaking News",
            "üî•"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketNew = async function () {
          this.log("üÜï Fetching newest markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "new",
            "Newest Markets",
            "üÜï"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketPolitics = async function () {
          this.log("üèõÔ∏è Fetching political markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "politics",
            "Political Markets",
            "üèõÔ∏è"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketSports = async function () {
          this.log("‚öΩ Fetching sports markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "sports",
            "Sports Markets",
            "‚öΩ"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketCrypto = async function () {
          this.log("‚Çø Fetching crypto markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "crypto",
            "Crypto Markets",
            "‚Çø"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketEarnings = async function () {
          this.log("üìä Fetching earnings markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "earnings",
            "Earnings Markets",
            "üìä"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketGeopolitics =
          async function () {
            this.log("üåç Fetching geopolitical markets...", "info");
            await this.getPolymarketCategoryMarkets(
              "geopolitics",
              "Geopolitical Markets",
              "üåç"
            );
          };

        OmegaMinerTerminal.prototype.getPolymarketTech = async function () {
          this.log("üíª Fetching technology markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "tech",
            "Technology Markets",
            "üíª"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketCulture = async function () {
          this.log("üé≠ Fetching culture markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "culture",
            "Culture Markets",
            "üé≠"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketWorld = async function () {
          this.log("üåé Fetching world events...", "info");
          await this.getPolymarketCategoryMarkets(
            "world",
            "World Events",
            "üåé"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketEconomy = async function () {
          this.log("üí∞ Fetching economic markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "economy",
            "Economic Markets",
            "üí∞"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketTrump = async function () {
          this.log("üëë Fetching Trump-related markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "trump",
            "Trump Markets",
            "üëë"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketElections =
          async function () {
            this.log("üó≥Ô∏è Fetching election markets...", "info");
            await this.getPolymarketCategoryMarkets(
              "elections",
              "Election Markets",
              "üó≥Ô∏è"
            );
          };

        // Generic category function that handles all categories
        OmegaMinerTerminal.prototype.getPolymarketCategoryMarkets =
          async function (category, displayName, icon) {
            try {
              // Use the correct API approach per official docs
              // Get current active markets using events endpoint (most efficient)
              const data = await this.makePolymarketRequest(
                `/events?order=id&ascending=false&closed=false&limit=100`
              );

              if (!data) return;

              // Handle both array format and {data: array} format
              const events = Array.isArray(data) ? data : data.data || [];

              if (events && events.length > 0) {
                // Extract markets from events and filter by category
                const categoryKeywords = this.getCategoryKeywords(category);
                console.log(
                  `üîç Searching for ${category} markets with keywords:`,
                  categoryKeywords.slice(0, 10)
                );

                const sortedMarkets = events
                  .filter((event) => {
                    // Only show events with markets and volume
                    if (!event.markets || !event.markets.length) return false;

                    // Get the primary market for volume calculation
                    const primaryMarket = event.markets[0];
                    if (
                      !primaryMarket ||
                      !primaryMarket.volume ||
                      primaryMarket.volume <= 0
                    )
                      return false;

                    // Client-side category filtering using event title and description
                    const searchText = `${event.title || ""} ${
                      event.description || ""
                    }`.toLowerCase();
                    const matches = categoryKeywords.filter((keyword) =>
                      searchText.includes(keyword.toLowerCase())
                    );

                    if (matches.length > 0) {
                      console.log(
                        `‚úÖ ${category} match: "${matches[0]}" in "${event.title}"`
                      );
                      return true;
                    }

                    return false;
                  })
                  .map((event) => {
                    // Convert event to market format for display
                    const primaryMarket = event.markets[0];
                    return {
                      id: event.id,
                      question: event.title || "Untitled Event",
                      description: event.description || "",
                      volume: primaryMarket.volume || 0,
                      liquidity: primaryMarket.liquidity || 0,
                      active: true,
                      endDate: event.endDate || event.end_date,
                      startDate: event.startDate || event.start_date,
                      createdAt: event.createdAt || event.created_at,
                      slug: event.slug,
                      category: event.category || "",
                      featured: event.featured || false,
                      markets: event.markets || [],
                    };
                  })
                  .sort((a, b) => (b.volume || 0) - (a.volume || 0));

                // Create category-specific UI
                const categoryHtml = `
                        <div style="
                            background: #1a1a1a;
                            border: 1px solid #333;
                            border-radius: 12px;
                            padding: 20px;
                            margin: 16px 0;
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                margin-bottom: 20px;
                                padding-bottom: 12px;
                                border-bottom: 1px solid #333;
                            ">
                                <div style="
                                    width: 36px;
                                    height: 36px;
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    border-radius: 8px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    margin-right: 12px;
                                    font-size: 16px;
                                ">${icon}</div>
                                <div>
                                    <h3 style="
                                        margin: 0;
                                        font-size: 18px;
                                        font-weight: 600;
                                        color: #ffffff;
                                    ">${displayName}</h3>
                                    <p style="
                                        margin: 4px 0 0 0;
                                        font-size: 14px;
                                        color: #888;
                                    ">${
                                      sortedMarkets.length
                                    } markets found ‚Ä¢ Sorted by volume</p>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                                ${sortedMarkets
                                  .slice(0, 12)
                                  .map(
                                    (market, index) => `
                                    <div style="
                                        background: #1a1a1a;
                                        border: 1px solid #333;
                                        border-radius: 12px;
                                        padding: 16px;
                                        transition: all 0.3s ease;
                                        position: relative;
                                        cursor: pointer;
                                        height: 280px;
                                        display: flex;
                                        flex-direction: column;
                                        justify-content: space-between;
                                    " onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(0, 0, 0, 0.3)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'; this.style.borderColor='#333';">
                                        <div style="
                                            position: absolute;
                                            top: 0;
                                            left: 0;
                                            right: 0;
                                            height: 3px;
                                            background: linear-gradient(90deg, #6b7280, #4b5563);
                                            border-radius: 12px 12px 0 0;
                                        "></div>
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: flex-start;
                                            margin-bottom: 12px;
                                        ">
                                            <div style="
                                                display: flex;
                                                align-items: center;
                                                gap: 12px;
                                                flex: 1;
                                            ">
                                                <div style="
                                                    width: 28px;
                                                    height: 28px;
                                                    background: linear-gradient(135deg, #6b7280, #4b5563);
                                                    border-radius: 6px;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    color: white;
                                                    font-weight: 600;
                                                    font-size: 12px;
                                                ">${index + 1}</div>
                                                <div style="
                                                    flex: 1;
                                                    min-width: 0;
                                                ">
                                                    <h4 style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 15px;
                                                        font-weight: 500;
                                                        line-height: 1.3;
                                                        color: #ffffff;
                                                        word-wrap: break-word;
                                                    ">${
                                                      market.question ||
                                                      "Untitled Market"
                                                    }</h4>
                                                    ${
                                                      market.description
                                                        ? `
                                                        <p style="
                                                            margin: 0 0 8px 0;
                                                            font-size: 12px;
                                                            color: #bbb;
                                                            line-height: 1.3;
                                                            display: -webkit-box;
                                                            -webkit-line-clamp: 2;
                                                            -webkit-box-orient: vertical;
                                                            overflow: hidden;
                                                        ">${market.description}</p>
                                                    `
                                                        : ""
                                                    }
                                                    <div style="
                                                        display: flex;
                                                        align-items: center;
                                                        gap: 8px;
                                                        flex-wrap: wrap;
                                                        margin-top: 8px;
                                                    ">
                                                        <a href="https://polymarket.com/market/${
                                                          market.slug ||
                                                          market.id
                                                        }" target="_blank" style="
                                                            background: linear-gradient(135deg, #6b7280, #4b5563);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 10px;
                                                            font-weight: 600;
                                                            text-decoration: none;
                                                            display: inline-flex;
                                                            align-items: center;
                                                            gap: 4px;
                                                            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.3);
                                                            transition: all 0.2s ease;
                                                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(6, 182, 212, 0.3)';">
                                                            üîó Trade
                                                        </a>
                                                        ${
                                                          market.category
                                                            ? `
                                                            <span style="
                                                                background: rgba(6, 182, 212, 0.2);
                                                                color: #06b6d4;
                                                                padding: 2px 6px;
                                                                border-radius: 8px;
                                                                font-size: 10px;
                                                                font-weight: 500;
                                                                border: 1px solid rgba(6, 182, 212, 0.3);
                                                            ">${market.category}</span>
                                                        `
                                                            : ""
                                                        }
                                                    </div>
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                flex-direction: column;
                                                align-items: flex-end;
                                                gap: 6px;
                                                flex-shrink: 0;
                                                margin-left: 12px;
                                            ">
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">$${(
                                                  market.volume || 0
                                                ).toLocaleString()}</div>
                                                ${
                                                  market.active
                                                    ? `
                                                    <div style="
                                                        background: linear-gradient(135deg, #059669, #047857);
                                                        color: white;
                                                        padding: 3px 8px;
                                                        border-radius: 10px;
                                                        font-size: 9px;
                                                        font-weight: 500;
                                                        display: inline-block;
                                                    ">üü¢ Active</div>
                                                `
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            font-size: 11px;
                                            color: #aaa;
                                            flex-wrap: wrap;
                                            gap: 8px;
                                            margin-top: 8px;
                                            padding-top: 8px;
                                            border-top: 1px solid #333;
                                        ">
                                            <span>üÜî ${market.id}</span>
                                            ${
                                              market.endDate
                                                ? `<span>üìÖ End: ${new Date(
                                                    market.endDate
                                                  ).toLocaleDateString()}</span>`
                                                : market.startDate
                                                ? `<span>üìÖ Start: ${new Date(
                                                    market.startDate
                                                  ).toLocaleDateString()}</span>`
                                                : ""
                                            }
                                        </div>
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        </div>
                    `;

                this.logHtml(categoryHtml, "output");
              } else {
                this.log(`‚ùå No ${category} markets found`, "error");
              }
            } catch (error) {
              this.log(
                `‚ùå Error fetching ${category} markets: ${error.message}`,
                "error"
              );
            }
          };

        // Category keyword matching functions
        OmegaMinerTerminal.prototype.getCategoryKeywords = function (category) {
          const keywordMap = {
            tech: [
              "AI",
              "artificial intelligence",
              "OpenAI",
              "ChatGPT",
              "GPT",
              "Google",
              "Microsoft",
              "Apple",
              "Meta",
              "Facebook",
              "Tesla",
              "Elon Musk",
              "tech",
              "technology",
              "software",
              "hardware",
              "computer",
              "internet",
              "startup",
              "IPO",
              "algorithm",
              "machine learning",
              "ML",
              "deep learning",
              "neural network",
              "quantum",
              "robotics",
              "automation",
              "data",
              "analytics",
              "cloud",
              "AWS",
              "Azure",
              "GCP",
              "database",
              "API",
              "programming",
              "code",
              "developer",
              "engineer",
              "scientist",
              "research",
              "innovation",
              "patent",
              "venture capital",
              "VC",
              "unicorn",
              "fintech",
              "edtech",
              "healthtech",
              "biotech",
              "space",
              "rocket",
              "satellite",
              "solar",
              "renewable",
              "energy",
              "battery",
              "electric",
              "autonomous",
              "drone",
              "VR",
              "AR",
              "metaverse",
              "gaming",
              "streaming",
              "social media",
              "platform",
              "app",
              "mobile",
              "smartphone",
              "laptop",
              "chip",
              "semiconductor",
              "processor",
              "GPU",
              "CPU",
              "memory",
              "storage",
              "server",
              "network",
              "security",
              "privacy",
              "encryption",
              "hack",
              "cyber",
              "digital",
              "online",
              "e-commerce",
              "marketplace",
              "payment",
              "banking",
            ],
            politics: [
              "Trump",
              "Biden",
              "election",
              "president",
              "presidential",
              "congress",
              "senate",
              "house",
              "republican",
              "democrat",
              "GOP",
              "liberal",
              "conservative",
              "campaign",
              "vote",
              "voting",
              "poll",
              "polling",
              "primary",
              "caucus",
              "debate",
              "rally",
              "inauguration",
              "swearing in",
              "state of the union",
              "impeachment",
              "cabinet",
              "secretary",
              "governor",
              "mayor",
              "senator",
              "representative",
              "congressman",
              "congresswoman",
              "politician",
              "policy",
              "legislation",
              "bill",
              "law",
              "act",
              "amendment",
              "constitution",
              "supreme court",
              "judge",
              "justice",
              "federal",
              "state",
              "local",
              "government",
              "administration",
              "white house",
              "capital",
              "washington",
              "dc",
              "political",
              "politics",
              "democracy",
              "republic",
              "freedom",
              "liberty",
              "rights",
              "constitution",
              "amendment",
              "federal",
              "state",
              "local",
              "municipal",
              "county",
              "city",
              "town",
              "village",
              "district",
              "ward",
              "precinct",
              "ballot",
              "candidate",
              "nominee",
              "party",
              "convention",
              "platform",
              "agenda",
              "manifesto",
              "endorsement",
              "support",
              "oppose",
              "approval",
              "disapproval",
              "rating",
              "popularity",
            ],
            sports: [
              "football",
              "soccer",
              "basketball",
              "baseball",
              "hockey",
              "tennis",
              "golf",
              "boxing",
              "MMA",
              "UFC",
              "Olympics",
              "World Cup",
              "Super Bowl",
              "NBA",
              "NFL",
              "MLB",
              "NHL",
              "MLS",
              "Premier League",
              "Champions League",
              "ESPN",
              "athlete",
              "player",
              "team",
              "game",
              "match",
              "tournament",
              "championship",
              "playoff",
              "final",
              "semifinal",
              "quarterfinal",
              "round",
              "season",
              "league",
              "division",
              "conference",
              "stadium",
              "arena",
              "field",
              "court",
              "rink",
              "track",
              "pool",
              "gym",
              "training",
              "coach",
              "manager",
              "referee",
              "umpire",
              "official",
              "score",
              "goal",
              "point",
              "run",
              "hit",
              "shot",
              "pass",
              "catch",
              "throw",
              "kick",
              "pitch",
              "serve",
              "volley",
              "dribble",
              "shoot",
              "tackle",
              "block",
              "defense",
              "offense",
              "quarterback",
              "running back",
              "wide receiver",
              "tight end",
              "linebacker",
              "cornerback",
              "safety",
              "kicker",
              "punter",
              "guard",
              "forward",
              "center",
              "goalkeeper",
              "defender",
              "midfielder",
              "striker",
              "pitcher",
              "catcher",
              "batter",
              "fielder",
              "runner",
              "goalie",
              "defenseman",
              "forward",
              "winger",
              "captain",
              "rookie",
              "veteran",
              "MVP",
              "all-star",
              "pro bowl",
              "all-pro",
              "champion",
              "winner",
              "loser",
              "tie",
              "draw",
              "overtime",
              "penalty",
              "foul",
              "yellow card",
              "red card",
              "suspension",
              "injury",
              "trade",
              "draft",
              "contract",
              "salary",
              "bonus",
              "extension",
              "free agent",
              "waiver",
              "retirement",
            ],
            crypto: [
              "bitcoin",
              "BTC",
              "ethereum",
              "ETH",
              "cryptocurrency",
              "crypto",
              "blockchain",
              "NFT",
              "Web3",
              "DeFi",
              "trading",
              "exchange",
              "coinbase",
              "binance",
              "kraken",
              "gemini",
              "crypto.com",
              "wallet",
              "metamask",
              "trust wallet",
              "ledger",
              "trezor",
              "cold storage",
              "hot wallet",
              "private key",
              "public key",
              "seed phrase",
              "mnemonic",
              "hash",
              "mining",
              "miner",
              "proof of work",
              "proof of stake",
              "PoW",
              "PoS",
              "consensus",
              "node",
              "validator",
              "stake",
              "staking",
              "yield",
              "farming",
              "liquidity",
              "pool",
              "pair",
              "swap",
              "DEX",
              "CEX",
              "AMM",
              "orderbook",
              "limit order",
              "market order",
              "stop loss",
              "take profit",
              "leverage",
              "margin",
              "futures",
              "options",
              "perpetual",
              "spot",
              "derivative",
              "token",
              "coin",
              "altcoin",
              "shitcoin",
              "meme coin",
              "stablecoin",
              "USDT",
              "USDC",
              "DAI",
              "BUSD",
              "TUSD",
              "FRAX",
              "LUSD",
              "algorithmic stablecoin",
              "governance token",
              "utility token",
              "security token",
              "utility token",
              "fungible",
              "non-fungible",
              "ERC-20",
              "ERC-721",
              "ERC-1155",
              "BEP-20",
              "TRC-20",
              "smart contract",
              "solidity",
              "vyper",
              "rust",
              "move",
              "programming",
              "developer",
              "audit",
              "hack",
              "exploit",
              "rug pull",
              "scam",
              "ponzi",
              "pyramid",
              "pump and dump",
              "whale",
              "diamond hands",
              "paper hands",
              "HODL",
              "FOMO",
              "FUD",
              "bull market",
              "bear market",
              "bullish",
              "bearish",
              "moon",
              "lambo",
              "to the moon",
              "wen moon",
              "diamond hands",
              "paper hands",
              "rekt",
              "liquidated",
              "margincall",
              "flash crash",
              "flash loan",
              "arbitrage",
              "MEV",
              "front running",
              "sandwich attack",
              "impermanent loss",
              "slippage",
              "gas fee",
              "gas limit",
              "gas price",
              "gwei",
              "wei",
              "satoshi",
              "gwei",
              "shannon",
              "finney",
              "szabo",
              "ether",
              "gwei",
              "megawei",
              "kiloether",
              "megaether",
              "gigaether",
              "teraether",
            ],
            breaking: [
              "breaking",
              "urgent",
              "alert",
              "news",
              "update",
              "developing",
              "live",
              "happening now",
              "just in",
              "latest",
              "recent",
              "today",
              "this week",
              "this month",
              "crisis",
              "emergency",
              "disaster",
              "attack",
              "bomb",
              "shooting",
              "fire",
              "flood",
              "earthquake",
              "hurricane",
              "tornado",
              "storm",
              "accident",
              "crash",
              "collision",
              "explosion",
              "outbreak",
              "pandemic",
              "epidemic",
              "virus",
              "disease",
              "health",
              "medical",
              "hospital",
              "clinic",
              "doctor",
              "nurse",
              "patient",
              "treatment",
              "vaccine",
              "medicine",
              "drug",
              "pharmaceutical",
              "FDA",
              "CDC",
              "WHO",
              "government",
              "official",
              "statement",
              "announcement",
              "press conference",
              "briefing",
              "report",
              "investigation",
              "arrest",
              "charges",
              "trial",
              "court",
              "judge",
              "jury",
              "verdict",
              "sentence",
              "prison",
              "jail",
              "bail",
              "bond",
              "fine",
              "penalty",
              "punishment",
              "crime",
              "criminal",
              "suspect",
              "victim",
              "witness",
              "evidence",
              "proof",
              "alibi",
              "confession",
              "guilty",
              "innocent",
              "acquittal",
              "conviction",
              "appeal",
              "mistrial",
              "retrial",
              "pardoned",
              "clemency",
              "commutation",
              "parole",
              "probation",
              "community service",
              "restitution",
              "damages",
              "settlement",
              "lawsuit",
              "litigation",
              "mediation",
              "arbitration",
              "negotiation",
              "agreement",
              "contract",
              "deal",
              "partnership",
              "merger",
              "acquisition",
              "takeover",
              "hostile takeover",
              "friendly takeover",
              "buyout",
              "IPO",
              "public offering",
              "private offering",
              "funding",
              "investment",
              "venture capital",
              "angel investor",
              "seed funding",
              "series A",
              "series B",
              "series C",
              "unicorn",
              "decacorn",
              "valuation",
              "market cap",
              "revenue",
              "profit",
              "loss",
              "earnings",
              "quarterly",
              "annual",
              "fiscal year",
              "budget",
              "expense",
              "cost",
              "price",
              "fee",
              "tax",
              "duty",
              "tariff",
              "subsidy",
              "grant",
              "loan",
              "debt",
              "credit",
              "interest",
              "rate",
              "percentage",
              "inflation",
              "deflation",
              "recession",
              "depression",
              "boom",
              "bust",
              "bubble",
              "crash",
              "correction",
              "rally",
              "surge",
              "spike",
              "dip",
              "drop",
              "fall",
              "rise",
              "increase",
              "decrease",
              "growth",
              "decline",
              "expansion",
              "contraction",
              "recovery",
              "rebound",
              "turnaround",
              "comeback",
              "breakthrough",
              "milestone",
              "achievement",
              "success",
              "failure",
              "mistake",
              "error",
              "bug",
              "glitch",
              "malfunction",
              "outage",
              "downtime",
              "maintenance",
              "upgrade",
              "update",
              "patch",
              "fix",
              "repair",
              "restore",
              "recover",
              "backup",
              "restore",
              "migration",
              "deployment",
              "launch",
              "release",
              "rollout",
              "beta",
              "alpha",
              "prototype",
              "demo",
              "pilot",
              "test",
              "trial",
              "experiment",
              "research",
              "study",
              "analysis",
              "report",
              "findings",
              "results",
              "conclusion",
              "recommendation",
              "suggestion",
              "proposal",
              "plan",
              "strategy",
              "tactic",
              "approach",
              "method",
              "technique",
              "process",
              "procedure",
              "protocol",
              "standard",
              "guideline",
              "rule",
              "regulation",
              "law",
              "act",
              "bill",
              "legislation",
              "policy",
              "directive",
              "order",
              "command",
              "instruction",
              "requirement",
              "specification",
              "criteria",
              "condition",
              "term",
              "clause",
              "provision",
              "stipulation",
              "restriction",
              "limitation",
              "constraint",
              "obstacle",
              "barrier",
              "challenge",
              "difficulty",
              "problem",
              "issue",
              "concern",
              "risk",
              "threat",
              "danger",
              "hazard",
              "peril",
              "menace",
              "warning",
              "caution",
              "alert",
              "notice",
              "advisory",
              "bulletin",
              "announcement",
              "communication",
              "message",
              "information",
              "data",
              "intelligence",
              "news",
              "report",
              "story",
              "article",
              "blog",
              "post",
              "tweet",
              "status",
              "update",
              "feed",
              "timeline",
              "stream",
              "broadcast",
              "live",
              "real-time",
              "instant",
              "immediate",
              "urgent",
              "critical",
              "important",
              "significant",
              "major",
              "minor",
              "small",
              "big",
              "large",
              "huge",
              "massive",
              "enormous",
              "tiny",
              "mini",
              "micro",
              "nano",
              "pico",
              "femto",
              "atto",
              "zepto",
              "yocto",
            ],
            new: [
              "new",
              "latest",
              "recent",
              "fresh",
              "just released",
              "just launched",
              "just announced",
              "unveiled",
              "introduced",
              "debut",
              "premiere",
              "first",
              "inaugural",
              "maiden",
              "pioneer",
              "groundbreaking",
              "revolutionary",
              "innovative",
              "cutting-edge",
              "state-of-the-art",
              "advanced",
              "modern",
              "contemporary",
              "current",
              "up-to-date",
              "updated",
              "upgraded",
              "enhanced",
              "improved",
              "refined",
              "polished",
              "perfected",
              "optimized",
              "streamlined",
              "simplified",
              "efficient",
              "effective",
              "powerful",
              "robust",
              "reliable",
              "stable",
              "secure",
              "safe",
              "trusted",
              "proven",
              "tested",
              "validated",
              "verified",
              "confirmed",
              "approved",
              "certified",
              "licensed",
              "registered",
              "patented",
              "trademarked",
              "copyrighted",
              "protected",
              "proprietary",
              "exclusive",
              "unique",
              "original",
              "creative",
              "novel",
              "unprecedented",
              "unheard of",
              "never before seen",
              "first of its kind",
              "one of a kind",
              "special",
              "exceptional",
              "outstanding",
              "remarkable",
              "extraordinary",
              "amazing",
              "incredible",
              "fantastic",
              "wonderful",
              "awesome",
              "brilliant",
              "genius",
              "smart",
              "intelligent",
              "clever",
              "wise",
              "insightful",
              "perceptive",
              "astute",
              "shrewd",
              "sharp",
              "keen",
              "acute",
              "penetrating",
              "deep",
              "profound",
              "meaningful",
              "significant",
              "important",
              "valuable",
              "precious",
              "rare",
              "scarce",
              "limited",
              "exclusive",
              "premium",
              "luxury",
              "high-end",
              "top-tier",
              "first-class",
              "world-class",
              "international",
              "global",
              "universal",
              "comprehensive",
              "complete",
              "full",
              "total",
              "entire",
              "whole",
              "all",
              "every",
              "each",
              "individual",
              "personal",
              "custom",
              "tailored",
              "bespoke",
              "made-to-order",
              "handcrafted",
              "artisan",
              "professional",
              "expert",
              "specialist",
              "master",
              "guru",
              "authority",
              "leader",
              "pioneer",
              "trailblazer",
              "innovator",
              "inventor",
              "creator",
              "founder",
              "developer",
              "designer",
              "architect",
              "engineer",
              "scientist",
              "researcher",
              "analyst",
              "consultant",
              "advisor",
              "mentor",
              "coach",
              "teacher",
              "instructor",
              "trainer",
              "educator",
              "professor",
              "doctor",
              "scholar",
              "academic",
              "intellectual",
              "thinker",
              "philosopher",
              "theorist",
              "practitioner",
              "professional",
              "expert",
              "specialist",
              "master",
              "guru",
              "authority",
              "leader",
            ],
            politics: [
              "Trump",
              "Biden",
              "election",
              "president",
              "presidential",
              "congress",
              "senate",
              "house",
              "republican",
              "democrat",
              "GOP",
              "liberal",
              "conservative",
              "campaign",
              "vote",
              "voting",
              "poll",
              "polling",
              "primary",
              "caucus",
              "debate",
              "rally",
              "inauguration",
              "swearing in",
              "state of the union",
              "impeachment",
              "cabinet",
              "secretary",
              "governor",
              "mayor",
              "senator",
              "representative",
              "congressman",
              "congresswoman",
              "politician",
              "policy",
              "legislation",
              "bill",
              "law",
              "act",
              "amendment",
              "constitution",
              "supreme court",
              "judge",
              "justice",
              "federal",
              "state",
              "local",
              "government",
              "administration",
              "white house",
              "capital",
              "washington",
              "dc",
              "political",
              "politics",
            ],
            sports: [
              "football",
              "soccer",
              "basketball",
              "baseball",
              "hockey",
              "tennis",
              "golf",
              "boxing",
              "MMA",
              "UFC",
              "Olympics",
              "World Cup",
              "Super Bowl",
              "NBA",
              "NFL",
              "MLB",
              "NHL",
              "MLS",
              "Premier League",
              "Champions League",
              "ESPN",
              "athlete",
              "player",
              "team",
              "game",
              "match",
              "tournament",
              "championship",
              "playoff",
              "final",
            ],
            earnings: [
              "earnings",
              "revenue",
              "profit",
              "loss",
              "quarterly",
              "annual",
              "Q1",
              "Q2",
              "Q3",
              "Q4",
              "fiscal",
              "financial",
              "results",
              "report",
              "beat",
              "miss",
              "guidance",
              "forecast",
              "estimate",
              "analyst",
              "EPS",
              "P/E",
              "valuation",
              "market cap",
              "IPO",
              "public offering",
              "stock",
              "shares",
              "dividend",
              "buyback",
              "merger",
              "acquisition",
            ],
            geopolitics: [
              "war",
              "conflict",
              "peace",
              "treaty",
              "alliance",
              "sanctions",
              "embargo",
              "trade war",
              "diplomacy",
              "summit",
              "meeting",
              "negotiation",
              "agreement",
              "Russia",
              "China",
              "Iran",
              "North Korea",
              "Israel",
              "Palestine",
              "Ukraine",
              "Syria",
              "Afghanistan",
              "Iraq",
              "Iran",
              "Saudi Arabia",
              "Turkey",
              "Egypt",
              "Libya",
              "Yemen",
              "Lebanon",
              "Jordan",
              "Kuwait",
              "UAE",
              "Qatar",
              "Bahrain",
              "Oman",
              "Yemen",
              "Somalia",
              "Sudan",
              "Ethiopia",
              "Eritrea",
              "Djibouti",
              "Kenya",
              "Tanzania",
              "Uganda",
              "Rwanda",
              "Burundi",
              "Congo",
              "Central African Republic",
              "Chad",
              "Cameroon",
              "Nigeria",
              "Niger",
              "Mali",
              "Burkina Faso",
              "Senegal",
              "Guinea",
              "Sierra Leone",
              "Liberia",
              "Ivory Coast",
              "Ghana",
              "Togo",
              "Benin",
              "Niger",
              "Mauritania",
              "Morocco",
              "Algeria",
              "Tunisia",
              "Libya",
              "Egypt",
              "Sudan",
              "South Sudan",
              "Ethiopia",
              "Eritrea",
              "Djibouti",
              "Somalia",
              "Kenya",
              "Tanzania",
              "Uganda",
              "Rwanda",
              "Burundi",
              "Congo",
              "Central African Republic",
              "Chad",
              "Cameroon",
              "Nigeria",
              "Niger",
              "Mali",
              "Burkina Faso",
              "Senegal",
              "Guinea",
              "Sierra Leone",
              "Liberia",
              "Ivory Coast",
              "Ghana",
              "Togo",
              "Benin",
              "Niger",
              "Mauritania",
            ],
            culture: [
              "movie",
              "film",
              "cinema",
              "television",
              "TV",
              "show",
              "series",
              "episode",
              "season",
              "premiere",
              "finale",
              "award",
              "Oscar",
              "Emmy",
              "Grammy",
              "Tony",
              "Golden Globe",
              "festival",
              "Cannes",
              "Sundance",
              "actor",
              "actress",
              "director",
              "producer",
              "writer",
              "screenplay",
              "script",
              "character",
              "role",
              "performance",
              "star",
              "celebrity",
              "famous",
              "popular",
              "trending",
              "viral",
              "meme",
              "social media",
              "Instagram",
              "Twitter",
              "TikTok",
              "YouTube",
              "influencer",
              "blogger",
              "vlogger",
              "podcast",
              "music",
              "song",
              "album",
              "artist",
              "band",
              "singer",
              "musician",
              "composer",
              "lyrics",
              "concert",
              "tour",
              "performance",
              "show",
              "gig",
              "venue",
              "theater",
              "stadium",
              "arena",
              "auditorium",
              "hall",
              "club",
              "bar",
              "restaurant",
              "cafe",
              "coffee shop",
              "book",
              "novel",
              "story",
              "author",
              "writer",
              "poet",
              "poetry",
              "literature",
              "publishing",
              "magazine",
              "newspaper",
              "article",
              "blog",
              "website",
              "art",
              "painting",
              "sculpture",
              "drawing",
              "photography",
              "gallery",
              "museum",
              "exhibition",
              "display",
              "collection",
              "artwork",
              "masterpiece",
              "creation",
              "design",
              "fashion",
              "style",
              "trend",
              "fad",
              "culture",
              "society",
              "community",
              "group",
              "organization",
              "club",
              "association",
              "foundation",
              "charity",
              "nonprofit",
              "volunteer",
              "activist",
              "advocate",
              "campaign",
              "movement",
              "protest",
              "demonstration",
              "rally",
              "march",
              "petition",
              "signature",
              "support",
              "oppose",
              "boycott",
              "strike",
              "walkout",
              "sit-in",
              "occupation",
              "takeover",
              "revolution",
              "rebellion",
              "uprising",
              "revolt",
              "coup",
              "overthrow",
              "regime change",
              "democracy",
              "freedom",
              "liberty",
              "rights",
              "justice",
              "equality",
              "fairness",
              "discrimination",
              "racism",
              "sexism",
              "homophobia",
              "transphobia",
              "xenophobia",
              "antisemitism",
              "islamophobia",
              "hate",
              "violence",
              "crime",
              "terrorism",
              "extremism",
              "radicalization",
              "recruitment",
              "propaganda",
              "disinformation",
              "misinformation",
              "fake news",
              "conspiracy",
              "theory",
              "hoax",
              "scam",
              "fraud",
              "corruption",
              "scandal",
              "controversy",
              "outrage",
              "backlash",
              "criticism",
              "complaint",
              "protest",
              "boycott",
              "cancellation",
              "ban",
              "censor",
              "suppress",
              "silence",
              "muzzle",
              "gag order",
              "injunction",
              "restraining order",
              "lawsuit",
              "legal action",
              "court case",
              "trial",
              "verdict",
              "judgment",
              "sentence",
              "punishment",
              "penalty",
              "fine",
              "damages",
              "compensation",
              "settlement",
              "agreement",
              "contract",
              "deal",
              "partnership",
              "collaboration",
              "cooperation",
              "alliance",
              "union",
              "merger",
              "acquisition",
              "takeover",
              "buyout",
              "investment",
              "funding",
              "sponsorship",
              "endorsement",
              "support",
              "backing",
              "approval",
              "blessing",
              "permission",
              "authorization",
              "license",
              "permit",
              "certificate",
              "diploma",
              "degree",
              "qualification",
              "credential",
              "certification",
              "accreditation",
              "recognition",
              "honor",
              "award",
              "prize",
              "trophy",
              "medal",
              "badge",
              "ribbon",
              "certificate",
              "diploma",
              "degree",
              "qualification",
              "achievement",
              "accomplishment",
              "success",
              "victory",
              "win",
              "triumph",
              "conquest",
              "domination",
              "supremacy",
              "leadership",
              "authority",
              "power",
              "influence",
              "control",
              "command",
              "rule",
              "governance",
              "management",
              "administration",
              "supervision",
              "oversight",
              "monitoring",
              "surveillance",
              "inspection",
              "audit",
              "review",
              "evaluation",
              "assessment",
              "analysis",
              "examination",
              "investigation",
              "inquiry",
              "probe",
              "search",
              "hunt",
              "quest",
              "mission",
              "journey",
              "adventure",
              "expedition",
              "exploration",
              "discovery",
              "finding",
              "result",
              "outcome",
              "consequence",
              "effect",
              "impact",
              "influence",
              "change",
              "transformation",
              "evolution",
              "development",
              "progress",
              "advancement",
              "improvement",
              "enhancement",
              "upgrade",
              "modernization",
              "innovation",
              "invention",
              "creation",
              "design",
              "development",
              "production",
              "manufacturing",
              "construction",
              "building",
              "making",
              "creating",
              "designing",
              "planning",
              "organizing",
              "coordinating",
              "managing",
              "leading",
              "directing",
              "guiding",
              "instructing",
              "teaching",
              "training",
              "educating",
              "informing",
              "communicating",
              "sharing",
              "exchanging",
              "trading",
              "buying",
              "selling",
              "marketing",
              "advertising",
              "promoting",
              "publicizing",
              "announcing",
              "declaring",
              "proclaiming",
              "stating",
              "saying",
              "telling",
              "speaking",
              "talking",
              "discussing",
              "debating",
              "arguing",
              "disagreeing",
              "agreeing",
              "consenting",
              "approving",
              "accepting",
              "rejecting",
              "refusing",
              "denying",
              "contradicting",
              "challenging",
              "questioning",
              "doubting",
              "wondering",
              "thinking",
              "considering",
              "pondering",
              "reflecting",
              "meditating",
              "contemplating",
              "studying",
              "learning",
              "understanding",
              "comprehending",
              "grasping",
              "realizing",
              "recognizing",
              "identifying",
              "distinguishing",
              "differentiating",
              "comparing",
              "contrasting",
              "analyzing",
              "evaluating",
              "assessing",
              "judging",
              "criticizing",
              "praising",
              "complimenting",
              "congratulating",
              "celebrating",
              "commemorating",
              "remembering",
              "recalling",
              "reminiscing",
              "nostalgia",
              "sentiment",
              "emotion",
              "feeling",
              "mood",
              "atmosphere",
              "ambiance",
              "environment",
              "setting",
              "scene",
              "background",
              "context",
              "situation",
              "circumstance",
              "condition",
              "state",
              "status",
              "position",
              "location",
              "place",
              "space",
              "area",
              "region",
              "territory",
              "country",
              "nation",
              "state",
              "city",
              "town",
              "village",
              "community",
              "neighborhood",
              "district",
              "ward",
              "precinct",
              "zone",
              "sector",
              "section",
              "part",
              "portion",
              "piece",
              "fragment",
              "segment",
              "division",
              "category",
              "class",
              "type",
              "kind",
              "sort",
              "variety",
              "species",
              "breed",
              "strain",
              "version",
              "edition",
              "model",
              "brand",
              "make",
              "manufacturer",
              "producer",
              "creator",
              "inventor",
              "designer",
              "architect",
              "engineer",
              "developer",
              "programmer",
              "coder",
              "analyst",
              "researcher",
              "scientist",
              "scholar",
              "academic",
              "professor",
              "teacher",
              "instructor",
              "trainer",
              "coach",
              "mentor",
              "advisor",
              "consultant",
              "expert",
              "specialist",
              "professional",
              "practitioner",
              "worker",
              "employee",
              "staff",
              "personnel",
              "team",
              "crew",
              "group",
              "organization",
              "company",
              "corporation",
              "business",
              "enterprise",
              "firm",
              "agency",
              "institution",
              "establishment",
              "foundation",
              "association",
              "society",
              "club",
              "union",
              "guild",
              "fraternity",
              "sorority",
              "brotherhood",
              "sisterhood",
              "fellowship",
              "partnership",
              "alliance",
              "coalition",
              "federation",
              "confederation",
              "league",
              "association",
              "society",
              "organization",
              "institution",
              "establishment",
              "foundation",
              "corporation",
              "company",
              "business",
              "enterprise",
              "firm",
              "agency",
              "bureau",
              "department",
              "division",
              "section",
              "unit",
              "branch",
              "office",
              "headquarters",
              "base",
              "facility",
              "plant",
              "factory",
              "workshop",
              "studio",
              "laboratory",
              "research center",
              "development center",
              "innovation center",
              "technology center",
              "business center",
              "commercial center",
              "shopping center",
              "retail center",
              "entertainment center",
              "cultural center",
              "community center",
              "conference center",
              "convention center",
              "exhibition center",
              "sports center",
              "fitness center",
              "health center",
              "medical center",
              "hospital",
              "clinic",
              "pharmacy",
              "laboratory",
              "research facility",
              "testing facility",
              "manufacturing facility",
              "production facility",
              "distribution center",
              "warehouse",
              "storage facility",
              "logistics center",
              "transportation hub",
              "airport",
              "train station",
              "bus station",
              "port",
              "harbor",
              "marina",
              "dock",
              "pier",
              "wharf",
              "terminal",
              "depot",
              "garage",
              "parking lot",
              "parking garage",
              "parking structure",
              "ramp",
              "elevator",
              "escalator",
              "staircase",
              "stairs",
              "steps",
              "walkway",
              "pathway",
              "sidewalk",
              "street",
              "road",
              "highway",
              "freeway",
              "expressway",
              "parkway",
              "boulevard",
              "avenue",
              "drive",
              "lane",
              "way",
              "place",
              "court",
              "circle",
              "square",
              "plaza",
              "mall",
              "shopping mall",
              "strip mall",
              "outlet mall",
              "flea market",
              "farmer's market",
              "bazaar",
              "marketplace",
              "store",
              "shop",
              "boutique",
              "department store",
              "supermarket",
              "grocery store",
              "convenience store",
              "gas station",
              "restaurant",
              "cafe",
              "coffee shop",
              "bar",
              "pub",
              "tavern",
              "lounge",
              "club",
              "nightclub",
              "dance club",
              "music venue",
              "theater",
              "cinema",
              "movie theater",
              "drive-in",
              "amphitheater",
              "stadium",
              "arena",
              "coliseum",
              "auditorium",
              "concert hall",
              "opera house",
              "ballet",
              "dance",
              "music",
              "orchestra",
              "band",
              "choir",
              "ensemble",
              "group",
              "troupe",
              "company",
              "organization",
              "institution",
              "establishment",
              "foundation",
              "corporation",
              "business",
              "enterprise",
              "firm",
              "agency",
              "bureau",
              "department",
              "division",
              "section",
              "unit",
              "branch",
              "office",
              "headquarters",
              "base",
              "facility",
              "plant",
              "factory",
              "workshop",
              "studio",
              "laboratory",
              "research center",
              "development center",
              "innovation center",
              "technology center",
            ],
            world: [
              "international",
              "global",
              "worldwide",
              "universal",
              "foreign",
              "overseas",
              "abroad",
              "nation",
              "country",
              "state",
              "government",
              "UN",
              "United Nations",
              "NATO",
              "EU",
              "European Union",
              "ASEAN",
              "G7",
              "G20",
              "WTO",
              "World Trade Organization",
              "IMF",
              "International Monetary Fund",
              "World Bank",
              "WHO",
              "World Health Organization",
              "UNESCO",
              "UNICEF",
              "Red Cross",
              "humanitarian",
              "aid",
              "relief",
              "disaster",
              "crisis",
              "emergency",
              "conflict",
              "war",
              "peace",
              "treaty",
              "summit",
              "conference",
              "meeting",
              "negotiation",
            ],
            economy: [
              "economy",
              "economic",
              "GDP",
              "inflation",
              "recession",
              "depression",
              "boom",
              "bust",
              "market",
              "stock",
              "bond",
              "currency",
              "exchange rate",
              "interest rate",
              "Federal Reserve",
              "Fed",
              "central bank",
              "monetary policy",
              "fiscal policy",
              "budget",
              "deficit",
              "surplus",
              "debt",
              "trade",
              "import",
              "export",
              "tariff",
              "tax",
              "unemployment",
              "job",
              "employment",
              "wage",
              "salary",
              "income",
              "wealth",
              "poverty",
              "inequality",
            ],
            trump: [
              "Trump",
              "Donald Trump",
              "DJT",
              "Trump administration",
              "Trump campaign",
              "Trump rally",
              "Trump tweet",
              "Trump statement",
              "Trump policy",
              "Trump decision",
              "Trump order",
              "executive order",
              "Trump Tower",
              "Mar-a-Lago",
              "Trump Organization",
              "Trump Foundation",
              "Trump University",
              "Trump Casino",
              "Trump Hotel",
              "Trump Resort",
              "Trump Golf",
              "Trump Entertainment",
              "Trump Media",
              "Truth Social",
              "Trump TV",
              "Trump Radio",
              "Trump Podcast",
              "Trump Interview",
              "Trump Speech",
              "Trump Debate",
              "Trump Press Conference",
              "Trump Briefing",
              "Trump Meeting",
              "Trump Summit",
              "Trump Negotiation",
              "Trump Deal",
              "Trump Agreement",
              "Trump Contract",
              "Trump Partnership",
              "Trump Alliance",
              "Trump Coalition",
              "Trump Support",
              "Trump Endorsement",
              "Trump Approval",
              "Trump Rating",
              "Trump Poll",
              "Trump Survey",
              "Trump Vote",
              "Trump Election",
              "Trump Campaign",
              "Trump Rally",
              "Trump Event",
              "Trump Appearance",
              "Trump Visit",
              "Trump Trip",
              "Trump Travel",
              "Trump Schedule",
              "Trump Agenda",
              "Trump Priority",
              "Trump Focus",
              "Trump Goal",
              "Trump Objective",
              "Trump Mission",
              "Trump Vision",
              "Trump Plan",
              "Trump Strategy",
              "Trump Approach",
              "Trump Method",
              "Trump Tactic",
              "Trump Style",
              "Trump Way",
              "Trump Manner",
              "Trump Approach",
              "Trump Method",
              "Trump Technique",
              "Trump Process",
              "Trump Procedure",
              "Trump Protocol",
              "Trump Standard",
              "Trump Guideline",
              "Trump Rule",
              "Trump Regulation",
              "Trump Law",
              "Trump Act",
              "Trump Bill",
              "Trump Legislation",
              "Trump Policy",
              "Trump Directive",
              "Trump Order",
              "Trump Command",
              "Trump Instruction",
              "Trump Requirement",
              "Trump Specification",
              "Trump Criteria",
              "Trump Condition",
              "Trump Term",
              "Trump Clause",
              "Trump Provision",
              "Trump Stipulation",
              "Trump Restriction",
              "Trump Limitation",
              "Trump Constraint",
              "Trump Obstacle",
              "Trump Barrier",
              "Trump Challenge",
              "Trump Difficulty",
              "Trump Problem",
              "Trump Issue",
              "Trump Concern",
              "Trump Risk",
              "Trump Threat",
              "Trump Danger",
              "Trump Hazard",
              "Trump Peril",
              "Trump Menace",
              "Trump Warning",
              "Trump Caution",
              "Trump Alert",
              "Trump Notice",
              "Trump Advisory",
              "Trump Bulletin",
              "Trump Announcement",
              "Trump Communication",
              "Trump Message",
              "Trump Information",
              "Trump Data",
              "Trump Intelligence",
              "Trump News",
              "Trump Report",
              "Trump Story",
              "Trump Article",
              "Trump Blog",
              "Trump Post",
              "Trump Tweet",
              "Trump Status",
              "Trump Update",
              "Trump Feed",
              "Trump Timeline",
              "Trump Stream",
              "Trump Broadcast",
              "Trump Live",
              "Trump Real-time",
              "Trump Instant",
              "Trump Immediate",
              "Trump Urgent",
              "Trump Critical",
              "Trump Important",
              "Trump Significant",
              "Trump Major",
              "Trump Minor",
              "Trump Small",
              "Trump Big",
              "Trump Large",
              "Trump Huge",
              "Trump Massive",
              "Trump Enormous",
              "Trump Tiny",
              "Trump Mini",
              "Trump Micro",
              "Trump Nano",
              "Trump Pico",
              "Trump Femto",
              "Trump Atto",
              "Trump Zepto",
              "Trump Yocto",
            ],
            elections: [
              "election",
              "elections",
              "vote",
              "voting",
              "ballot",
              "ballots",
              "poll",
              "polls",
              "polling",
              "primary",
              "primaries",
              "caucus",
              "caucuses",
              "general election",
              "presidential election",
              "congressional election",
              "senate election",
              "house election",
              "gubernatorial election",
              "mayoral election",
              "local election",
              "state election",
              "federal election",
              "midterm election",
              "special election",
              "runoff election",
              "recall election",
              "referendum",
              "initiative",
              "proposition",
              "amendment",
              "candidate",
              "candidates",
              "nominee",
              "nominees",
              "incumbent",
              "incumbents",
              "challenger",
              "challengers",
              "opponent",
              "opponents",
              "rival",
              "rivals",
              "competitor",
              "competitors",
              "contender",
              "contenders",
              "hopeful",
              "hopefuls",
              "prospect",
              "prospects",
              "frontrunner",
              "frontrunners",
              "underdog",
              "underdogs",
              "dark horse",
              "dark horses",
              "favorite",
              "favorites",
              "longshot",
              "longshots",
              "campaign",
              "campaigns",
              "campaigning",
              "campaigner",
              "campaigners",
              "campaign manager",
              "campaign managers",
              "campaign staff",
              "campaign workers",
              "campaign volunteers",
              "campaign supporters",
              "campaign donors",
              "campaign contributors",
              "campaign fundraisers",
              "campaign finance",
              "campaign funding",
              "campaign budget",
              "campaign spending",
              "campaign expenditure",
              "campaign cost",
              "campaign expense",
              "campaign investment",
              "campaign return",
              "campaign yield",
              "campaign result",
              "campaign outcome",
              "campaign success",
              "campaign failure",
              "campaign victory",
              "campaign defeat",
              "campaign win",
              "campaign loss",
              "campaign triumph",
              "campaign disaster",
              "campaign fiasco",
              "campaign debacle",
              "campaign catastrophe",
              "campaign calamity",
              "campaign tragedy",
              "campaign comedy",
              "campaign farce",
              "campaign joke",
              "campaign embarrassment",
              "campaign humiliation",
              "campaign disgrace",
              "campaign scandal",
              "campaign controversy",
              "campaign issue",
              "campaign problem",
              "campaign difficulty",
              "campaign challenge",
              "campaign obstacle",
              "campaign barrier",
              "campaign hurdle",
              "campaign setback",
              "campaign reversal",
              "campaign turnaround",
              "campaign comeback",
              "campaign recovery",
              "campaign rebound",
              "campaign surge",
              "campaign rally",
              "campaign momentum",
              "campaign boost",
              "campaign lift",
              "campaign push",
              "campaign drive",
              "campaign effort",
              "campaign work",
              "campaign labor",
              "campaign toil",
              "campaign grind",
              "campaign hustle",
              "campaign hustle",
              "campaign bustle",
              "campaign activity",
              "campaign action",
              "campaign movement",
              "campaign progress",
              "campaign advancement",
              "campaign development",
              "campaign growth",
              "campaign expansion",
              "campaign increase",
              "campaign rise",
              "campaign climb",
              "campaign ascent",
              "campaign elevation",
              "campaign promotion",
              "campaign upgrade",
              "campaign improvement",
              "campaign enhancement",
              "campaign refinement",
              "campaign perfection",
              "campaign optimization",
              "campaign maximization",
              "campaign utilization",
              "campaign exploitation",
              "campaign leverage",
              "campaign advantage",
              "campaign benefit",
              "campaign gain",
              "campaign profit",
              "campaign return",
              "campaign yield",
              "campaign dividend",
              "campaign reward",
              "campaign prize",
              "campaign trophy",
              "campaign medal",
              "campaign honor",
              "campaign recognition",
              "campaign acclaim",
              "campaign praise",
              "campaign commendation",
              "campaign approval",
              "campaign endorsement",
              "campaign support",
              "campaign backing",
              "campaign sponsorship",
              "campaign patronage",
              "campaign assistance",
              "campaign help",
              "campaign aid",
              "campaign relief",
              "campaign support",
              "campaign encouragement",
              "campaign motivation",
              "campaign inspiration",
              "campaign guidance",
              "campaign direction",
              "campaign leadership",
              "campaign management",
              "campaign administration",
              "campaign coordination",
              "campaign organization",
              "campaign planning",
              "campaign strategy",
              "campaign tactics",
              "campaign approach",
              "campaign method",
              "campaign technique",
              "campaign process",
              "campaign procedure",
              "campaign protocol",
              "campaign standard",
              "campaign guideline",
              "campaign rule",
              "campaign regulation",
              "campaign law",
              "campaign act",
              "campaign bill",
              "campaign legislation",
              "campaign policy",
              "campaign directive",
              "campaign order",
              "campaign command",
              "campaign instruction",
              "campaign requirement",
              "campaign specification",
              "campaign criteria",
              "campaign condition",
              "campaign term",
              "campaign clause",
              "campaign provision",
              "campaign stipulation",
              "campaign restriction",
              "campaign limitation",
              "campaign constraint",
              "campaign obstacle",
              "campaign barrier",
              "campaign challenge",
              "campaign difficulty",
              "campaign problem",
              "campaign issue",
              "campaign concern",
              "campaign risk",
              "campaign threat",
              "campaign danger",
              "campaign hazard",
              "campaign peril",
              "campaign menace",
              "campaign warning",
              "campaign caution",
              "campaign alert",
              "campaign notice",
              "campaign advisory",
              "campaign bulletin",
              "campaign announcement",
              "campaign communication",
              "campaign message",
              "campaign information",
              "campaign data",
              "campaign intelligence",
              "campaign news",
              "campaign report",
              "campaign story",
              "campaign article",
              "campaign blog",
              "campaign post",
              "campaign tweet",
              "campaign status",
              "campaign update",
              "campaign feed",
              "campaign timeline",
              "campaign stream",
              "campaign broadcast",
              "campaign live",
              "campaign real-time",
              "campaign instant",
              "campaign immediate",
              "campaign urgent",
              "campaign critical",
              "campaign important",
              "campaign significant",
              "campaign major",
              "campaign minor",
              "campaign small",
              "campaign big",
              "campaign large",
              "campaign huge",
              "campaign massive",
              "campaign enormous",
              "campaign tiny",
              "campaign mini",
              "campaign micro",
              "campaign nano",
              "campaign pico",
              "campaign femto",
              "campaign atto",
              "campaign zepto",
              "campaign yocto",
            ],
          };

          return keywordMap[category] || [];
        };

        OmegaMinerTerminal.prototype.isMarketInCategory = function (
          market,
          keywords
        ) {
          const searchText = `${market.question || ""} ${
            market.description || ""
          } ${market.category || ""}`.toLowerCase();

          // Check if any keyword matches (more flexible matching)
          const matches = keywords.filter((keyword) => {
            const keywordLower = keyword.toLowerCase();
            // Exact match or word boundary match for better accuracy
            return (
              searchText.includes(keywordLower) ||
              searchText.includes(` ${keywordLower} `) ||
              searchText.startsWith(`${keywordLower} `) ||
              searchText.endsWith(` ${keywordLower}`)
            );
          });

          if (matches.length > 0) {
            console.log(
              `üéØ Category match found: "${matches[0]}" in "${market.question}"`
            );
            return true;
          }

          return false;
        };

        // Add Perp command handler
        OmegaMinerTerminal.prototype.handlePerpCommand = function (args) {
          this.log("üöÄ Opening Omega Perps Interface...", "info");

          // Create popup window with Omega Perps
          const perpUrl =
            "https://omegaperps.omeganetwork.co/perp/PERP_ETH_USDC/";
          const popupWidth = 1200;
          const popupHeight = 800;

          // Calculate center position
          const left = (screen.width - popupWidth) / 2;
          const top = (screen.height - popupHeight) / 2;

          // Open popup window
          const perpWindow = window.open(
            perpUrl,
            "OmegaPerps",
            `width=${popupWidth},height=${popupHeight},left=${left},top=${top},scrollbars=yes,resizable=yes,toolbar=no,menubar=no,location=no,status=no`
          );

          if (perpWindow) {
            this.log("‚úÖ Omega Perps opened in popup window", "success");
            this.log(
              "üí° Use F11 or the fullscreen button in the interface for fullscreen mode",
              "info"
            );

            // Create UI for fullscreen option
            const fullscreenHtml = `
                    <div style="
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 16px 0;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 16px;
                        ">
                            <div style="
                                width: 36px;
                                height: 36px;
                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 12px;
                                font-size: 16px;
                            ">üöÄ</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    color: #ffffff;
                                ">Omega Perps Interface</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                ">ETH/USDC Perpetual Trading</p>
                            </div>
                        </div>
                        
                        <div style="
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 12px;
                            margin-bottom: 16px;
                        ">
                            <button onclick="
                                if (window.omegaPerpWindow) {
                                    window.omegaPerpWindow.close();
                                }
                                window.omegaPerpWindow = window.open('${perpUrl}', '_blank', 'fullscreen=yes');
                                if (window.omegaPerpWindow) {
                                    this.style.background='linear-gradient(135deg, #059669, #047857)';
                                    this.innerHTML='‚úÖ Fullscreen Opened';
                                }
                            " style="
                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                color: white;
                                border: none;
                                padding: 12px 16px;
                                border-radius: 8px;
                                font-size: 14px;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(107, 114, 128, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                üñ•Ô∏è Open Fullscreen
                            </button>
                            
                            <button onclick="
                                if (window.omegaPerpWindow) {
                                    window.omegaPerpWindow.close();
                                    window.omegaPerpWindow = null;
                                    this.style.background='linear-gradient(135deg, #dc2626, #b91c1c)';
                                    this.innerHTML='‚ùå Closed';
                                }
                            " style="
                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                color: white;
                                border: none;
                                padding: 12px 16px;
                                border-radius: 8px;
                                font-size: 14px;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(107, 114, 128, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                ‚ùå Close Window
                            </button>
                        </div>
                        
                        <div style="
                            background: #0f0f0f;
                            border: 1px solid #333;
                            border-radius: 8px;
                            padding: 12px;
                            font-size: 12px;
                            color: #888;
                        ">
                            <strong>üîó URL:</strong> <a href="${perpUrl}" target="_blank" style="color: #6b7280; text-decoration: none;">${perpUrl}</a><br>
                            <strong>üìä Pair:</strong> ETH/USDC Perpetual<br>
                            <strong>üåê Network:</strong> Omega Network<br>
                            <strong>üí° Tip:</strong> Use F11 in the popup for fullscreen, or click the fullscreen button above
                        </div>
                    </div>
                `;

            this.logHtml(fullscreenHtml, "output");

            // Store reference to the window for later use
            window.omegaPerpWindow = perpWindow;
          } else {
            this.log(
              "‚ùå Failed to open popup. Please allow popups for this site.",
              "error"
            );
            this.log(
              "üí° Alternative: Visit the URL directly: " + perpUrl,
              "info"
            );
          }
        };

        console.log(
          "üîß DEBUG: Polymarket and Perp functions loaded successfully!"
        );
      } else {
        console.log(
          "üîß DEBUG: Terminal prototype not found, Polymarket and Perp functions not loaded"
        );
      }

      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOMContentLoaded - creating new terminal instance");
        window.terminal = new OmegaMinerTerminal();
        // init() is already called in the constructor, so we don't need to call it again
      });
    </script>
  </body>
</html>

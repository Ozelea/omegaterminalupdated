<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;"> -->
    <title>OMEGA TERMINAL - CLASSIFIED ACCESS SYSTEM v2.0.1</title>
    <style>
        /* Entertainment Command Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px currentColor; }
            50% { text-shadow: 0 0 30px currentColor, 0 0 40px currentColor; }
        }
        
            @keyframes matrixRain {
                0% { transform: translateY(-100vh); opacity: 0; }
                10% { opacity: 1; }
                90% { opacity: 1; }
                100% { transform: translateY(100vh); opacity: 0; }
            }
            
            @keyframes kalshiPulse {
                0%, 100% { 
                    transform: scale(1); 
                    opacity: 0.7; 
                    box-shadow: 0 0 10px #00d4ff;
                }
                50% { 
                    transform: scale(1.2); 
                    opacity: 1; 
                    box-shadow: 0 0 20px #00d4ff, 0 0 30px #00d4ff;
                }
            }
            
            @keyframes kalshiShimmer {
                0% { left: -100%; }
                100% { left: 100%; }
            }
            
            .entertainment-intro {
                animation: pulse 2s ease-in-out infinite;
            }
        
        .disco-intro {
            background-size: 400% 400%;
            animation: rainbow 3s ease infinite;
        }
        
        .matrix-text {
            animation: glow 1.5s ease-in-out infinite;
        }
    </style>
    <script>
      // Disable redirect loop - let page load normally
      console.log("✅ Page loading without redirect loop");
    </script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"
      type="application/javascript"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/eth-crypto@2.1.2/dist/lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.93.1/lib/index.iife.min.js"></script>

    <!-- Mobile Detection - Load First -->
    <script src="js/mobile-basic-mode.js"></script>

    <!-- Core Terminal Scripts -->
    <script src="js/config.js"></script>
    <script src="js/themes.js"></script>
    <!-- <script src="js/modern-ui-input-fix.js"></script> -->
    <!-- File doesn't exist - commented out -->
    <script src="js/core-modern-ui-integration.js"></script>
    <script src="js/utils.js"></script>

    <!-- Futuristic UI System -->
    <script src="js/futuristic/futuristic-customizer.js"></script>
    <script src="js/futuristic/terminal-theme-bridge.js"></script>
    <script src="js/futuristic/futuristic-welcome-screen-new.js"></script>
    <!-- <script src="js/futuristic/welcome-screen-fix.js"></script> -->
    <!-- File doesn't exist - commented out -->
    <script src="js/futuristic/futuristic-dashboard-transform.js"></script>

    <!-- UI Components -->
    <script src="ui/svg-icons-replacement.js"></script>
    <script src="ui/omega-symbol-logo.js"></script>

    <!-- Sound Effects System -->
    <script src="js/plugins/omega-sound-effects.js"></script>

    <link rel="stylesheet" href="styles/gui-themes.css" />
    <link rel="stylesheet" href="styles/apple-ui-theme.css" />
    <link rel="stylesheet" href="styles/simple-input-fix.css" />
    <link rel="stylesheet" href="styles/mobile-terminal-fix.css" />
    <link rel="stylesheet" href="styles/mobile-games-fix.css" />

    <!-- FUTURISTIC THEME -->
    <link rel="stylesheet" href="styles/futuristic-theme.css" />
    <link rel="stylesheet" href="styles/futuristic-mode.css" />
    <link rel="stylesheet" href="styles/futuristic-terminal-integration.css" />
    <link rel="stylesheet" href="styles/futuristic-font-override.css" />
    <link rel="stylesheet" href="styles/blues-player.css" />
    <link rel="stylesheet" href="styles/futuristic-welcome-screen-new.css" />
    <link rel="stylesheet" href="styles/svg-icons-system.css" />
    <link rel="stylesheet" href="styles/omega-logos.css" />
    <link rel="stylesheet" href="styles/omega-symbol-logo.css" />

    <!-- EXECUTIVE THEME - Premium Professional UI -->
    <link rel="stylesheet" href="styles/executive-theme.css" />
    <link rel="stylesheet" href="styles/pgt-portfolio-integration.css" />
    <link
      rel="stylesheet"
      href="styles/pgt-tracker-styles.css?v=layout-fix-2"
    />
    <link rel="stylesheet" href="styles/multi-network-connector.css" />
    <link rel="stylesheet" href="styles/network-logo-styling.css" />
    <link rel="stylesheet" href="styles/chart-viewer.css" />
    <link rel="stylesheet" href="styles/spotify-player.css" />
    <link rel="stylesheet" href="styles/youtube-player.css" />
    <link rel="stylesheet" href="styles/news-reader.css" />
    <link rel="stylesheet" href="styles/perps-viewer.css" />
    <link rel="stylesheet" href="styles/magiceden.css?v=2.0.0" />
    <link rel="stylesheet" href="styles/color-palettes.css" />
    <link rel="stylesheet" href="styles/unified-theme-system.css" />
    <link rel="stylesheet" href="styles/layout-fixes.css" />
    <link rel="stylesheet" href="styles/command-input-unified.css" />
    <link rel="stylesheet" href="styles/button-uniformity-fix.css" />
    <link rel="stylesheet" href="styles/command-input-cursor-fix.css" />
    <link rel="stylesheet" href="styles/modern-ui-futuristic-theme.css" />
    <link rel="stylesheet" href="styles/core-modern-ui-terminal.css" />
    <link rel="stylesheet" href="styles/modern-ui-command-input-fix.css" />
    <link rel="stylesheet" href="styles/terminal-output-color-fix.css" />
    <link rel="stylesheet" href="styles/custom-music-player.css" />
    <script src="js/plugins/dexscreener-analytics-ultimate.js"></script>
    <script src="js/plugins/omega-spotify-player.js"></script>
    <script src="js/plugins/omega-youtube-player.js"></script>
    <script src="js/plugins/omega-blues-player.js"></script>
    <script src="js/plugins/omega-custom-music-player.js"></script>
    <script src="js/commands/custom-music-commands.js"></script>
    <script src="js/plugins/omega-news-reader.js"></script>
    <script src="js/commands/news-commands.js"></script>
    <script src="js/plugins/omega-perps-viewer.js"></script>
    <script src="js/commands/perps-commands.js"></script>
    <script src="js/commands/color-commands.js"></script>
    <!-- <script src="near-wallet-plugin.js"></script> DISABLED: Was breaking existing NEAR commands -->
    <!-- <script src="input-visibility-hotfix.js"></script> DISABLED: Causing issues -->
    <!-- <script src="apple-ui-input-override.js"></script> DISABLED: Causing duplicate text -->
    <script src="js/plugins/apple-ui-plugin.js"></script>
    <script src="js/plugins/defillama-api-plugin.js"></script>
    <!-- <script src="opensea-nft-plugin.js"></script> REPLACED WITH ENHANCED VERSION -->
    <script src="js/plugins/opensea-enhanced-plugin.js"></script>

    <!-- Magic Eden NFT Plugin -->
    <script src="js/plugins/magiceden-plugin.js?v=2.3.0"></script>
    <script src="js/commands/magiceden-commands.js?v=2.3.0"></script>

    <!-- Ethereum Collections (Magic Eden) -->
    <script src="js/commands/ethereum-commands.js?v=1.0.0"></script>

    <script src="js/plugins/enhanced-profile-system.js?v=kalshi-fixed-20251009"></script>
    <script src="js/commands/chaingpt-chat.js?v=1.0.3"></script>
    <script src="js/plugins/terminal-chatter-mode.js?v=1.0.1"></script>
    <!-- Python integration disabled - causes initialization issues -->
    <!-- <script src="js/plugins/python-integration-system.js"></script> -->
    <!-- <script src="js/plugins/pgt-integration-live.js"></script> DISABLED: Replaced with pgt-terminal-integration.js -->
    <!-- <script src="js/plugins/pgt-cors-proxy.js"></script> DISABLED: Not needed with new multi-network system -->
    <!-- <script src="rome-network-plugin.js"></script> DISABLED: Rome commands integrated directly into index.html -->
    <!-- <script src="megaeth-network-plugin.js"></script> DISABLED: Not needed -->
    <script src="js/plugins/terminal-games-system.js"></script>
    <!-- <script src="simple-terminal-builder.js"></script> DISABLED: Causing conflicts -->
    <script src="js/plugins/omega-nft-onchain.js"></script>
    <script src="js/plugins/pgt-terminal-integration.js"></script>
    <script src="js/plugins/multi-network-connector.js"></script>
    <!-- Theme Input Field Fix -->
    <!-- <script src="js/plugins/theme-input-fix.js"></script> -->
    <!-- File doesn't exist - commented out -->

    <!-- Command Modules -->
    <script src="js/commands/basic.js"></script>
    <script src="js/commands/api.js"></script>
    <script src="js/commands/mining.js"></script>
    <script src="js/commands/entertainment.js"></script>
    <script src="js/commands/blues.js"></script>
    <script src="js/commands/network.js"></script>
    <script src="js/commands/mixer.js"></script>
    <script src="js/commands/solana.js"></script>
    <script src="js/commands/near.js"></script>
    <script src="js/commands/eclipse.js"></script>
    <script src="js/commands/kalshi.js"></script>
    <script src="js/commands/referral.js"></script>
    <script src="js/commands/remaining.js?v=1.0.1"></script>
    <script src="js/commands/wallet-commands.js?v=multi-network-3.0"></script>
    <script src="js/commands/chaingpt-nft.js?v=1.0.5"></script>
    <script src="js/commands/chaingpt-smart-contract.js?v=1.0.0"></script>
    <script src="js/commands/chaingpt-auditor.js?v=1.0.0"></script>
    <script src="js/commands/crypto-news.js?v=1.0.0"></script>
    <script src="js/commands/youtube.js"></script>

    <!-- Solana Web3.js for Solana support -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script>
      // VERSION CHECK - This should be visible in console if updated code is loaded
      console.log("═══════════════════════════════════════════════");
      console.log("🚀 OMEGA TERMINAL v3.0.0 - MULTI-NETWORK");
      console.log("═══════════════════════════════════════════════");
      console.log("✅ Multi-Network Support (EVM + Solana + NEAR)");
      console.log("✅ Network Selector with Real Logos");
      console.log("✅ 7 EVM Chains + Non-EVM Networks");
      console.log("✅ Media Players (Spotify, YouTube, News)");
      console.log("✅ Color Palette System (16 palettes)");
      console.log("═══════════════════════════════════════════════");
      console.log("🕒 Loaded: " + new Date().toISOString());

      // Cache bust for updates (clean version number)
      if (!window.location.search.includes("v=")) {
        const timestamp = Date.now();
        const newUrl = window.location.href.split("?")[0] + "?v=" + timestamp;
        console.log("Cache refresh: " + timestamp);
        window.location.href = newUrl;
      }

      // Simple base58 decoder implementation
      const base58Chars =
        "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      const base58Lookup = {};
      for (let i = 0; i < base58Chars.length; i++) {
        base58Lookup[base58Chars[i]] = i;
      }

      function base58Decode(str) {
        let decoded = 0n;
        let multi = 1n;
        const base = 58n;

        for (let i = str.length - 1; i >= 0; i--) {
          const char = str[i];
          if (!(char in base58Lookup)) {
            throw new Error("Invalid base58 character: " + char);
          }
          decoded += BigInt(base58Lookup[char]) * multi;
          multi *= base;
        }

        // Convert to bytes
        const bytes = [];
        while (decoded > 0n) {
          bytes.unshift(Number(decoded % 256n));
          decoded = decoded / 256n;
        }

        // Handle leading zeros
        for (let i = 0; i < str.length && str[i] === "1"; i++) {
          bytes.unshift(0);
        }

        return new Uint8Array(bytes);
      }
    </script>
    <script>
      // Ensure Solana Web3 is accessible
      if (
        typeof window.solanaWeb3 === "undefined" &&
        typeof solanaWeb3 !== "undefined"
      ) {
        window.solanaWeb3 = solanaWeb3;
      }

      // Completely prevent Phantom from taking over window.ethereum
      const originalEthereum = window.ethereum;
      if (originalEthereum && originalEthereum.isPhantom) {
        console.log("Phantom detected in early script - blocking immediately");
        // Store the original providers before Phantom takes over
        const providers = originalEthereum.providers || [];
        const metamaskProvider = providers.find((p) => p.isMetaMask);

        if (metamaskProvider) {
          window.ethereum = metamaskProvider;
          console.log("MetaMask restored in early script");
        } else {
          window.ethereum = null;
          console.log("No MetaMask found - blocking all wallets");
        }
      }

      // Force MetaMask preference immediately after libraries load
      (function () {
        // More aggressive MetaMask forcing
        if (
          window.ethereum &&
          window.ethereum.providers &&
          Array.isArray(window.ethereum.providers)
        ) {
          const metamaskProvider = window.ethereum.providers.find(
            (p) => p.isMetaMask
          );
          if (metamaskProvider) {
            // Completely replace window.ethereum with MetaMask
            window.ethereum = metamaskProvider;
            console.log("MetaMask provider selected (early)");

            // Also set a flag to prevent other providers from taking over
            window.ethereum._forceMetaMask = true;
          }
        }

        // Additional check: if we detect Phantom, try to find MetaMask again
        if (
          window.ethereum &&
          window.ethereum.isPhantom &&
          !window.ethereum._forceMetaMask
        ) {
          console.log("Phantom detected, searching for MetaMask...");
          // Look for MetaMask in the original providers array
          if (
            window.ethereum.providers &&
            Array.isArray(window.ethereum.providers)
          ) {
            const metamaskProvider = window.ethereum.providers.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              window.ethereum = metamaskProvider;
              window.ethereum._forceMetaMask = true;
              console.log("MetaMask found and forced after Phantom detection");
            }
          }
        }
      })();
    </script>
    <style>
      /* iOS Message Animations */
      @keyframes slideInRight {
        from {
          transform: translateX(100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideInLeft {
        from {
          transform: translateX(-100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background-color: #000;
        color: #ffffff;
        font-family: "Courier New", monospace;
        font-size: 14px;
        line-height: 1.4;
        overflow: hidden;
      }

      /* CRITICAL: Disable ALL animated overlays and scanlines */
      body::after,
      body::before,
      html::after,
      html::before {
        display: none !important;
        content: none !important;
        animation: none !important;
      }

      /* Hide native browser caret (we use custom indicator) */
      input[type="text"],
      #commandInput,
      .input-field,
      .terminal-input {
        caret-color: transparent !important; /* Hide native caret */
        text-align: left !important;
        direction: ltr !important;
        unicode-bidi: normal !important;
      }

      /* Enhanced cursor indicator */
      .omega-cursor-indicator {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-family: "Courier New", monospace;
        font-size: 14px;
        color: #00ffff;
        pointer-events: none;
        z-index: 100;
        animation: omegaCursorBlink 1s step-end infinite;
        user-select: none;
        line-height: 1;
      }

      @keyframes omegaCursorBlink {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      body.light-mode .omega-cursor-indicator {
        color: #0051d5;
      }

      /* Ensure input line is positioned */
      .input-line {
        position: relative;
      }

      /* Remove any custom cursor elements */
      .cursor,
      span.cursor,
      .custom-cursor,
      .fake-cursor {
        display: none !important;
        visibility: hidden !important;
      }

      /* Old Terminal Light Mode Styles */
      body.light-mode .terminal {
        background: #ffffff !important;
        color: #1d1d1f !important;
      }

      body.light-mode .terminal-header {
        background: #f5f5f7 !important;
        border-bottom-color: #d1d1d6 !important;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1) !important;
      }

      body.light-mode .terminal-title {
        color: #1d1d1f !important;
        font-weight: 600;
      }

      body.light-mode .terminal-status {
        color: #0051d5 !important;
        background: rgba(0, 81, 213, 0.08) !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
        font-weight: 600;
      }

      body.light-mode .tab-bar {
        background: #f5f5f7 !important;
        border-bottom-color: #d1d1d6 !important;
      }

      body.light-mode .tab {
        color: #636366 !important;
        font-weight: 500;
      }

      body.light-mode .tab.active {
        color: #0051d5 !important;
        border-bottom-color: #0051d5 !important;
        font-weight: 600;
      }

      body.light-mode .terminal-content {
        background: #ffffff !important;
        color: #1d1d1f !important;
      }

      body.light-mode .terminal-output {
        color: #1d1d1f !important;
      }

      body.light-mode .terminal-line,
      body.light-mode .output-line {
        color: #1d1d1f !important;
      }

      body.light-mode .input-prompt,
      body.light-mode .prompt-symbol,
      body.light-mode .prompt-text {
        color: #007a3d !important;
        font-weight: 600;
      }

      body.light-mode .input-field,
      body.light-mode #commandInput {
        color: #1d1d1f !important;
        caret-color: #0051d5 !important;
        font-weight: 500;
      }

      /* Light mode status message colors */
      body.light-mode .text-success,
      body.light-mode .success {
        color: #007a3d !important;
        font-weight: 600;
      }

      body.light-mode .text-error,
      body.light-mode .error {
        color: #d70015 !important;
        font-weight: 600;
      }

      body.light-mode .text-warning,
      body.light-mode .warning {
        color: #c93400 !important;
        font-weight: 600;
      }

      body.light-mode .text-info,
      body.light-mode .info {
        color: #0051d5 !important;
        font-weight: 500;
      }

      body.light-mode .text-matrix,
      body.light-mode .matrix {
        color: #007a3d !important;
      }

      body.light-mode .text-cyan,
      body.light-mode .cyan {
        color: #0051d5 !important;
      }

      body.light-mode .text-purple,
      body.light-mode .purple {
        color: #5e5ce6 !important;
      }

      /* Light mode links */
      body.light-mode a {
        color: #0051d5 !important;
      }

      body.light-mode a:hover {
        color: #0040dd !important;
        text-decoration: underline;
      }

      /* Light mode header buttons */
      body.light-mode .header-control-btn {
        background: rgba(0, 81, 213, 0.08) !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
        color: #0051d5 !important;
      }

      body.light-mode .header-control-btn:hover {
        background: rgba(0, 81, 213, 0.15) !important;
        border-color: #0051d5 !important;
        box-shadow: 0 0 10px rgba(0, 81, 213, 0.2) !important;
      }

      body.light-mode .ai-toggle {
        background: rgba(0, 81, 213, 0.08) !important;
        color: #0051d5 !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
      }

      body.light-mode .theme-toggle {
        background: rgba(0, 81, 213, 0.08) !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
      }

      /* Light mode input section */
      body.light-mode .terminal-input-section {
        background: transparent !important;
        border-top-color: rgba(0, 81, 213, 0.15) !important;
      }

      body.light-mode .input-line {
        background: rgba(0, 81, 213, 0.05) !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
      }

      body.light-mode .input-line:focus-within {
        background: rgba(0, 81, 213, 0.08) !important;
        border-color: #0051d5 !important;
        box-shadow: 0 0 0 2px rgba(0, 81, 213, 0.15) !important;
      }

      /* Light mode basic terminal mode */
      body.light-mode.basic-terminal-mode {
        background: #f5f5f7 !important;
      }

      body.light-mode.basic-terminal-mode #terminal-wrapper {
        background: #ffffff !important;
      }

      body.light-mode.basic-terminal-mode .terminal-header {
        background: #f5f5f7 !important;
      }

      /* Header control button hover effects */
      .header-control-btn:hover {
        background: rgba(0, 188, 242, 0.2) !important;
        border-color: #00bcf2 !important;
        box-shadow: 0 0 10px rgba(0, 188, 242, 0.2) !important;
        transform: translateY(-1px);
      }

      .header-control-btn:active {
        transform: translateY(0);
      }

      /* Header icon buttons (social links) */
      .header-icon-btn:hover {
        background: rgba(0, 188, 242, 0.2) !important;
        border-color: #00bcf2 !important;
        box-shadow: 0 0 10px rgba(0, 188, 242, 0.2) !important;
        transform: translateY(-2px);
      }

      body.light-mode .header-icon-btn {
        background: rgba(0, 81, 213, 0.08) !important;
        border-color: rgba(0, 81, 213, 0.2) !important;
        color: #0051d5 !important;
      }

      body.light-mode .header-icon-btn:hover {
        background: rgba(0, 81, 213, 0.15) !important;
        border-color: #0051d5 !important;
        box-shadow: 0 0 10px rgba(0, 81, 213, 0.2) !important;
      }

      /* Polymarket UI Variables */
      :root {
        --poly-text-primary: #1f2937;
        --poly-text-secondary: #6b7280;
        --poly-bg-primary: rgba(255, 255, 255, 0.05);
        --poly-bg-secondary: rgba(255, 255, 255, 0.1);
        --poly-border: rgba(255, 255, 255, 0.1);
        --poly-shadow: rgba(0, 0, 0, 0.1);
        --poly-backdrop: blur(10px);
      }

      /* Light theme overrides */
      [data-theme="light"] {
        --poly-text-primary: #111827;
        --poly-text-secondary: #6b7280;
        --poly-bg-primary: rgba(255, 255, 255, 0.8);
        --poly-bg-secondary: rgba(255, 255, 255, 0.9);
        --poly-border: rgba(0, 0, 0, 0.1);
        --poly-shadow: rgba(0, 0, 0, 0.05);
        --poly-backdrop: blur(20px);
      }

      .terminal {
        width: 100vw;
        height: 100vh;
        max-height: 100vh;
        padding: 0;
        background: linear-gradient(135deg, #000 0%, #111111 100%);
        position: relative;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
      }

      /* Ensure old terminal has proper flex layout */
      .terminal:not(.basic-terminal-mode) {
        display: flex !important;
        flex-direction: column !important;
        height: 100vh !important;
        width: 100vw !important;
      }

      .terminal-header {
        border-bottom: 1px solid #00bcf2;
        box-shadow: 0 1px 10px rgba(0, 188, 242, 0.3);
        padding: 16px 24px;
        margin-bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        position: relative;
        z-index: 10;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
      }

      .terminal-title {
        font-size: 18px;
        font-weight: 500;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        letter-spacing: 0.5px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
          "Helvetica Neue", Arial, sans-serif;
      }

      .terminal-status {
        font-size: 12px;
        color: #cccccc;
      }

      .theme-toggle {
        width: 22px;
        height: 22px;
        background: transparent;
        border: 2px solid #fff;
        border-radius: 50%;
        cursor: pointer;
        margin-right: 0;
        margin-left: 0;
        display: inline-block;
        transition: border-color 0.2s;
        box-sizing: border-box;
        outline: none;
      }

      .theme-toggle:hover {
        border-color: #99ccff;
        background: rgba(255, 255, 255, 0.05);
      }

      .ai-toggle {
        background: #ffffff;
        border: 1px solid #ffffff;
        border-radius: 4px;
        cursor: pointer;
        padding: 4px 8px;
        font-size: 12px;
        color: #333333;
        font-family: "Courier New", monospace;
        transition: all 0.3s ease;
        outline: none;
      }

      .ai-toggle:hover {
        background: #f0f0f0;
        border-color: #f0f0f0;
        color: #000000;
      }

      .terminal-input-section {
        border-top: 1px solid rgba(0, 188, 242, 0.2);
        padding: 12px 20px;
        margin-top: auto;
        background: transparent;
        width: 100%;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        gap: 0;
        flex-shrink: 0;
        position: relative;
        z-index: 5;
      }

      /* Basic terminal mode input section override */
      body.basic-terminal-mode .terminal-input-section {
        padding: 12px 20px !important;
        margin-top: auto !important;
        background: transparent !important;
        border-top: 1px solid rgba(0, 188, 242, 0.2) !important;
        width: 100% !important;
        box-sizing: border-box !important;
        display: flex !important;
        align-items: center !important;
        gap: 0 !important;
        flex-shrink: 0 !important;
        position: relative !important;
        z-index: 5 !important;
        order: 999 !important;
      }

      /* Basic terminal mode - Terminal container */
      body.basic-terminal-mode #terminal {
        display: flex !important;
        flex-direction: column !important;
        height: 100% !important;
        width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        overflow: hidden !important;
        flex: 1 !important;
      }

      /* Basic terminal mode - Content area */
      body.basic-terminal-mode .terminal-content {
        flex: 1 1 auto !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        padding: 20px 24px !important;
        margin: 0 !important;
        min-height: 0 !important;
        max-height: 100% !important;
        order: 1 !important;
      }

      .terminal-content {
        flex: 1 1 auto;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px 24px;
        margin-bottom: 0;
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
        min-height: 0;
        max-height: 100%;
        scrollbar-width: thin;
        scrollbar-color: rgba(0, 188, 242, 0.5) rgba(0, 0, 0, 0.2);
      }

      /* Ensure old terminal content is properly positioned */
      .terminal:not(.basic-terminal-mode) .terminal-content {
        flex: 1 1 auto !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        min-height: 0 !important;
        max-height: 100% !important;
      }

      /* Ensure old terminal input section is at bottom */
      .terminal:not(.basic-terminal-mode) .terminal-input-section {
        margin-top: auto !important;
        flex-shrink: 0 !important;
      }

      .terminal-content::-webkit-scrollbar {
        width: 8px;
      }

      .terminal-content::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
      }

      .terminal-content::-webkit-scrollbar-thumb {
        background: rgba(0, 188, 242, 0.5);
        border-radius: 4px;
        transition: background 0.2s ease;
      }

      .terminal-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 188, 242, 0.7);
      }

      body.light-mode .terminal-content::-webkit-scrollbar-thumb {
        background: rgba(0, 81, 213, 0.5);
      }

      body.light-mode .terminal-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 81, 213, 0.7);
      }

      /* Mobile responsive improvements for old terminal */
      @media (max-width: 768px) {
        .terminal-header {
          padding: 12px 16px;
        }

        .terminal-content {
          padding: 16px 20px;
        }

        .terminal-input-section {
          padding: 10px 16px;
        }

        .input-line {
          padding: 10px 14px;
          gap: 8px;
        }

        .input-prompt {
          font-size: 14px;
        }

        .input-field {
          font-size: 14px;
        }

        .terminal-title {
          font-size: 16px;
        }
      }

      /* Modal popup styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: linear-gradient(135deg, #000 0%, #111111 100%);
        border: 2px solid #ffffff;
        border-radius: 10px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        animation: modalFadeIn 0.5s ease-out;
      }

      @keyframes modalFadeIn {
        from {
          opacity: 0;
          transform: scale(0.8) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .modal-title {
        font-size: 24px;
        font-weight: bold;
        color: #ffffff;
        margin-bottom: 20px;
        text-shadow: 0 0 15px #ffffff;
        letter-spacing: 2px;
      }

      .modal-steps {
        text-align: left;
        margin: 20px 0;
      }

      .modal-step {
        font-size: 16px;
        color: #ffffff;
        margin: 15px 0;
        padding: 10px;
        border-left: 3px solid #33bbff;
        background: rgba(51, 187, 255, 0.1);
      }

      .modal-step-number {
        color: #33bbff;
        font-weight: bold;
        margin-right: 10px;
      }

      .modal-button {
        background: linear-gradient(135deg, #33bbff 0%, #0066cc 100%);
        border: none;
        color: white;
        padding: 12px 30px;
        font-size: 16px;
        font-weight: bold;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .modal-button:hover {
        background: linear-gradient(135deg, #66ccff 0%, #0099ff 100%);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(51, 187, 255, 0.4);
      }

      .terminal-line {
        margin-bottom: 5px;
        word-wrap: break-word;
      }

      .prompt {
        color: #ffffff;
        font-weight: bold;
      }

      .command {
        color: #ffffff;
      }

      .output {
        color: #cccccc;
        margin-left: 20px;
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .error {
        color: #ff6666;
      }

      .success {
        color: #ffffff;
      }

      .warning {
        color: #ffffcc;
      }

      .info {
        color: #99ccff;
      }

      .mining-status {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #ffffff;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background-color: #111111;
        border: 1px solid #ffffff;
        border-radius: 10px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ffffff, #cccccc);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px #ffffff;
      }

      .input-line {
        display: flex;
        align-items: center;
        background: rgba(0, 188, 242, 0.05);
        width: 100%;
        gap: 12px;
        position: relative;
        padding: 12px 18px;
        border-radius: 8px;
        border: 1px solid rgba(0, 188, 242, 0.2);
        transition: all 0.2s ease;
        box-sizing: border-box;
      }

      .input-line:focus-within {
        background: rgba(0, 188, 242, 0.08);
        border-color: rgba(0, 188, 242, 0.4);
        box-shadow: 0 0 0 2px rgba(0, 188, 242, 0.1);
        transform: translateY(-1px);
      }

      .input-prompt {
        color: #ffffff;
        font-weight: 600;
        margin-right: 0;
        font-size: 15px;
        white-space: nowrap;
        letter-spacing: 0.5px;
        flex-shrink: 0;
      }

      .input-field {
        background: transparent;
        border: none;
        color: #ffffff;
        font-family: "Courier New", monospace;
        font-size: 15px;
        outline: none;
        flex: 1;
        padding: 0;
        caret-color: #ffffff;
        width: 100%;
        min-width: 0;
        opacity: 1 !important;
        line-height: 1.5;
      }

      .input-field:focus {
        caret-color: #ffffff;
        opacity: 1 !important;
      }

      .input-field::placeholder {
        color: #ffffff;
      }

      /* Custom cursor - ENABLED with enhanced styling */
      .cursor {
        display: inline-block !important; /* Show custom cursor */
        color: var(--palette-primary, #00d4ff) !important;
        font-family: "Courier New", monospace !important;
        font-size: 14px !important;
        font-weight: 400 !important;
        line-height: 1 !important;
        margin-left: 2px !important;
        vertical-align: baseline !important;
        position: relative !important;
        z-index: 2 !important;
        animation: cursorBlink 1.2s ease-in-out infinite !important;
        text-shadow: 0 0 8px var(--palette-primary-glow, rgba(0, 212, 255, 0.4)) !important;
        transition: all 0.2s ease !important;
      }

      @keyframes cursorBlink {
        0%,
        50% {
          opacity: 1;
          transform: scaleY(1);
        }
        51%,
        100% {
          opacity: 0.3;
          transform: scaleY(0.8);
        }
      }

      /* Input field cursor indicator */
      .input-field {
        position: relative;
      }

      .input-field:focus {
        box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.3);
        border-radius: 2px;
      }

      /* Animated cursor after input field - DISABLED, using native caret */
      .input-line::after,
      .input-line.active::after {
        display: none !important;
        content: none !important;
        opacity: 0 !important;
        animation: none !important;
      }

      @keyframes cursorBlink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0;
        }
      }

      .mining-animation {
        display: inline-block;
        animation: mining-pulse 2s infinite;
      }

      @keyframes mining-pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin: 10px 0;
      }

      .stat-box {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid #ffffff;
        padding: 10px;
        border-radius: 5px;
      }

      .stat-label {
        color: #cccccc;
        font-size: 12px;
      }

      .stat-value {
        color: #ffffff;
        font-size: 16px;
        font-weight: bold;
      }

      /* Boot Animation Styles */
      .boot-animation {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Courier New", monospace;
      }

      .omega-symbols {
        font-size: 48px;
        color: #ffffff;
        text-shadow: 0 0 20px #ffffff;
        margin-bottom: 20px;
        animation: omega-float 3s ease-in-out infinite;
      }

      .pickaxe {
        font-size: 36px;
        color: #ffcc00;
        text-shadow: 0 0 15px #ffcc00;
        animation: pickaxe-swing 2s ease-in-out infinite;
        margin-bottom: 30px;
      }

      .welcome-text {
        font-size: 24px;
        color: #ffffff;
        text-align: center;
        line-height: 1.5;
        text-shadow: 0 0 10px #ffffff;
      }

      .loading-dots {
        font-size: 18px;
        color: #cccccc;
        margin-top: 20px;
        animation: loading-pulse 1.5s ease-in-out infinite;
      }

      @keyframes omega-float {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @keyframes pickaxe-swing {
        0%,
        100% {
          transform: rotate(-15deg);
        }
        50% {
          transform: rotate(15deg);
        }
      }

      @keyframes loading-pulse {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 1;
        }
      }

      .hidden {
        display: none !important;
      }

      /* Light Theme Styles */
      .terminal.light-theme {
        background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
        color: #000000;
      }

      .terminal.light-theme .terminal-header {
        border-bottom: 1px solid #000000;
      }

      .terminal.light-theme .terminal-title {
        color: #000000;
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .terminal.light-theme .terminal-status {
        color: #333333;
      }

      .terminal.light-theme .theme-toggle {
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid #000000;
        color: #000000;
      }

      .terminal.light-theme .theme-toggle:hover {
        background: rgba(0, 0, 0, 0.2);
      }

      .terminal.light-theme .terminal-input-section {
        border-top: 1px solid #000000;
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid #000000;
      }

      .terminal.light-theme .prompt {
        color: #000000;
      }

      .terminal.light-theme .command {
        color: #000000;
      }

      .terminal.light-theme .output {
        color: #333333;
      }

      .terminal.light-theme .error {
        color: #cc0000;
      }

      .terminal.light-theme .success {
        color: #000000;
      }

      .terminal.light-theme .warning {
        color: #cc6600;
      }

      .terminal.light-theme .info {
        color: #0066cc;
      }

      .terminal.light-theme .input-prompt {
        color: #000000;
      }

      .terminal.light-theme .input-field {
        color: #000000;
        caret-color: #000000;
      }

      .terminal.light-theme .input-field:focus {
        caret-color: #000000;
      }

      .terminal.light-theme .input-field::placeholder {
        color: #ffffff;
      }

      .terminal.light-theme .cursor {
        display: inline-block !important;
        color: #0066cc;
      }

      .terminal.light-theme .mining-status {
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid #000000;
      }

      .terminal.light-theme .stat-box {
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid #000000;
      }

      .terminal.light-theme .stat-label {
        color: #333333;
      }

      .terminal.light-theme .stat-value {
        color: #000000;
      }

      .output.error {
        color: #ff3333 !important;
        font-weight: bold !important;
      }

      /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
      .terminal-content .output.error,
      .output.error {
        color: #ff3333 !important;
        font-weight: bold !important;
      }

      .terminal-content,
      .output,
      .output.error,
      .output.success,
      .output.info,
      .output.warning,
      .terminal-content *,
      .output *,
      .output.error *,
      .output.success *,
      .output.info *,
      .output.warning * {
        user-select: text !important;
        -webkit-user-select: text !important;
        -moz-user-select: text !important;
        -ms-user-select: text !important;
      }

      .terminal-line .copyable {
        cursor: pointer;
        text-decoration: underline;
        color: #00ff00;
        transition: all 0.3s ease;
      }

      .terminal-line .copyable:hover {
        color: #ffff00;
        text-shadow: 0 0 10px #ffff00;
      }

      .terminal-line .copyable:active {
        color: #ff0000;
      }

      body.theme-dark {
        background: #000;
        color: #fff;
      }
      body.theme-light {
        background: #fff;
        color: #111;
      }
      body.theme-matrix {
        background: #000;
        color: #00ff00;
      }
      body.theme-retro {
        background: #111;
        color: #39ff14;
      }
      .theme-matrix .terminal-header,
      .theme-retro .terminal-header {
        border-bottom: 1px solid #00ff00;
      }
      .theme-matrix .input-prompt,
      .theme-retro .input-prompt {
        color: #39ff14;
      }
      .theme-retro .input-prompt {
        color: orange;
      }

      /* Matrix Theme Styles */
      body.theme-matrix {
        background: #000 !important;
        color: #00ff00 !important;
      }
      body.theme-matrix .terminal {
        background: #000 !important;
        color: #00ff00 !important;
      }
      body.theme-matrix .terminal-header {
        border-bottom: 1px solid #00ff00 !important;
      }
      body.theme-matrix .prompt,
      body.theme-matrix .input-prompt {
        color: #00ff00 !important;
        font-weight: bold;
      }
      body.theme-matrix .command {
        color: #00ff00 !important;
      }
      body.theme-matrix .output {
        color: #00ff00 !important;
      }
      body.theme-matrix .error {
        color: #ff3333 !important;
      }
      body.theme-matrix .success {
        color: #00ff00 !important;
      }
      body.theme-matrix .warning {
        color: #ffff00 !important;
      }
      body.theme-matrix .info {
        color: #00ffff !important;
      }

      /* Retro Theme Styles */
      body.theme-retro {
        background: #181200 !important;
        color: #39ff14 !important;
      }
      body.theme-retro .terminal {
        background: #181200 !important;
        color: #39ff14 !important;
      }
      body.theme-retro .terminal-header {
        border-bottom: 1px solid #ffaa00 !important;
      }
      body.theme-retro .prompt,
      body.theme-retro .input-prompt {
        color: #ffaa00 !important;
        font-weight: bold;
      }
      body.theme-retro .command {
        color: #39ff14 !important;
      }
      body.theme-retro .output {
        color: #39ff14 !important;
      }
      body.theme-retro .error {
        color: #ff3333 !important;
      }
      body.theme-retro .success {
        color: #ffaa00 !important;
      }
      body.theme-retro .warning {
        color: #ffff00 !important;
      }
      body.theme-retro .info {
        color: #00ffff !important;
      }

      body.theme-retro .info {
        color: #00ffff !important;
      }

      /* PowerShell Theme Styles */
      body.theme-powershell {
        background: #012456 !important;
        color: #ffffff !important;
      }
      body.theme-powershell .terminal {
        background: #012456 !important;
        color: #ffffff !important;
      }
      body.theme-powershell .terminal-header {
        border-bottom: 1px solid #00bcf2 !important;
      }
      body.theme-powershell .prompt,
      body.theme-powershell .input-prompt {
        color: #f9f1a5 !important;
        font-weight: bold;
      }
      body.theme-powershell .command {
        color: #ffffff !important;
      }
      body.theme-powershell .output {
        color: #d7eaff !important;
      }
      body.theme-powershell .error {
        color: #ff3333 !important;
      }
      body.theme-powershell .success {
        color: #00bcf2 !important;
      }
      body.theme-powershell .warning {
        color: #f9f1a5 !important;
      }
      body.theme-powershell .info {
        color: #00bcf2 !important;
      }

      .omega-test-wallet-prompt {
        color: #fff !important;
        font-size: 1.5em !important;
        font-weight: bold;
        margin: 16px 0;
        display: block;
      }

      /* Modern Boot Animation Styles */
      .boot-animation {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          135deg,
          #000000 0%,
          #0a0a0a 50%,
          #000000 100%
        );
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        overflow: hidden;
      }

      /* Boot animation background - DISABLED */
      .boot-animation::before {
        display: none !important;
        content: none !important;
        animation: none !important;
      }

      @keyframes gridMove {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(50px, 50px);
        }
      }

      /* Ensure boot animation is hidden after initialization */
      body.omega-initialized .boot-animation,
      body.omega-initialized #bootAnimation {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
      }

      .omega-container {
        position: relative;
        margin-bottom: 60px;
        animation: floatIn 1s ease-out;
      }

      @keyframes floatIn {
        from {
          opacity: 0;
          transform: translateY(-50px) scale(0.5);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .omega-main {
        font-size: 120px;
        color: #ffffff;
        text-shadow: 0 0 20px #ffffff, 0 0 40px #ffffff, 0 0 60px #99ccff,
          0 0 80px #99ccff;
        animation: pulseglow 2s ease-in-out infinite;
        position: relative;
        z-index: 2;
      }

      @keyframes pulseglow {
        0%,
        100% {
          text-shadow: 0 0 20px #ffffff, 0 0 40px #ffffff, 0 0 60px #99ccff,
            0 0 80px #99ccff;
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 30px #ffffff, 0 0 60px #ffffff, 0 0 90px #66ccff,
            0 0 120px #66ccff;
          transform: scale(1.05);
        }
      }

      .omega-orbit {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 300px;
        height: 300px;
        margin: -150px 0 0 -150px;
        animation: rotate 10s linear infinite;
      }

      @keyframes rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .omega-orbit-symbol {
        position: absolute;
        font-size: 24px;
        color: #99ccff;
        opacity: 0.3;
        animation: orbitFade 2s ease-in-out infinite;
      }

      @keyframes orbitFade {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 0.8;
        }
      }

      .omega-orbit-symbol:nth-child(1) {
        top: 0;
        left: 50%;
        transform: translateX(-50%);
      }
      .omega-orbit-symbol:nth-child(2) {
        top: 21%;
        right: 21%;
      }
      .omega-orbit-symbol:nth-child(3) {
        top: 50%;
        right: 0;
        transform: translateY(-50%);
      }
      .omega-orbit-symbol:nth-child(4) {
        bottom: 21%;
        right: 21%;
      }
      .omega-orbit-symbol:nth-child(5) {
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
      }
      .omega-orbit-symbol:nth-child(6) {
        bottom: 21%;
        left: 21%;
      }
      .omega-orbit-symbol:nth-child(7) {
        top: 50%;
        left: 0;
        transform: translateY(-50%);
      }
      .omega-orbit-symbol:nth-child(8) {
        top: 21%;
        left: 21%;
      }

      .welcome-container {
        text-align: center;
        margin-bottom: 40px;
        animation: fadeInUp 1s ease-out 0.3s both;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .welcome-title {
        font-size: 48px;
        font-weight: bold;
        color: #ffffff;
        letter-spacing: 8px;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        margin-bottom: 10px;
      }

      .welcome-subtitle {
        font-size: 20px;
        color: #99ccff;
        letter-spacing: 4px;
        margin-bottom: 15px;
      }

      .welcome-description {
        font-size: 16px;
        color: #cccccc;
        letter-spacing: 2px;
      }

      .loading-container {
        width: 400px;
        max-width: 80vw;
        margin-bottom: 40px;
        animation: fadeInUp 1s ease-out 0.6s both;
      }

      .loading-bar {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
      }

      .loading-progress {
        height: 100%;
        background: linear-gradient(90deg, #66ccff, #ffffff, #66ccff);
        background-size: 200% 100%;
        animation: loadingProgress 2s ease-in-out infinite;
        box-shadow: 0 0 10px #66ccff;
      }

      @keyframes loadingProgress {
        0% {
          width: 0%;
          background-position: 0% 50%;
        }
        50% {
          width: 70%;
          background-position: 100% 50%;
        }
        100% {
          width: 100%;
          background-position: 200% 50%;
        }
      }

      .loading-text {
        text-align: center;
        color: #99ccff;
        font-size: 14px;
        margin-top: 15px;
        letter-spacing: 2px;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      .boot-features {
        display: flex;
        gap: 30px;
        flex-wrap: wrap;
        justify-content: center;
        animation: fadeInUp 1s ease-out 0.9s both;
      }

      .feature-item {
        color: #99ccff;
        font-size: 14px;
        padding: 8px 16px;
        border: 1px solid rgba(153, 204, 255, 0.3);
        border-radius: 20px;
        background: rgba(153, 204, 255, 0.05);
        backdrop-filter: blur(10px);
        animation: featureGlow 3s ease-in-out infinite;
        animation-delay: calc(var(--i) * 0.2s);
      }

      .feature-item:nth-child(1) {
        --i: 0;
      }
      .feature-item:nth-child(2) {
        --i: 1;
      }
      .feature-item:nth-child(3) {
        --i: 2;
      }
      .feature-item:nth-child(4) {
        --i: 3;
      }

      @keyframes featureGlow {
        0%,
        100% {
          box-shadow: 0 0 5px rgba(153, 204, 255, 0.3);
          border-color: rgba(153, 204, 255, 0.3);
        }
        50% {
          box-shadow: 0 0 15px rgba(153, 204, 255, 0.6);
          border-color: rgba(153, 204, 255, 0.6);
        }
      }

      @media (max-width: 768px) {
        .omega-main {
          font-size: 80px;
        }
        .omega-orbit {
          width: 200px;
          height: 200px;
          margin: -100px 0 0 -100px;
        }
        .welcome-title {
          font-size: 32px;
          letter-spacing: 4px;
        }
        .welcome-subtitle {
          font-size: 16px;
        }
        .loading-container {
          width: 300px;
        }
        .boot-features {
          gap: 15px;
        }
        .feature-item {
          font-size: 12px;
          padding: 6px 12px;
        }
      }

      /* UI Selection Screen removed - terminal loads directly */
    </style>
  </head>
  <body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
      <div class="omega-container">
        <div
          class="omega-main"
          style="color: #ffffff; text-shadow: 0 0 20px rgba(255, 255, 255, 0.8)"
        >
          Ω
        </div>
        <!-- Removed omega-orbit circle for clean logo -->
      </div>
      <div class="welcome-container">
        <div class="welcome-title">OMEGA TERMINAL</div>
        <div class="welcome-subtitle">v2.0.1</div>
        <div class="welcome-description">Multi-Chain Web3 Terminal</div>
      </div>
      <div class="loading-container">
        <div class="loading-bar">
          <div class="loading-progress"></div>
        </div>
        <div class="loading-text">Initializing Terminal...</div>
      </div>
      <div class="boot-features">
        <div class="feature-item">🤖 AI</div>
        <div class="feature-item">⚡ Multi-Chain</div>
        <div class="feature-item">🏛️ Defi</div>
        <div class="feature-item">🎨 NFTs</div>
      </div>
    </div>

    <!-- UI Selection Screen removed - terminal loads directly -->

    <div class="terminal" id="terminal" style="display: none">
      <div class="terminal-header">
        <div class="terminal-title">Ω Terminal v2.0.1</div>
        <div
          style="
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: auto;
          "
        >
          <a
            href="https://omeganetwork.co/landing"
            target="_blank"
            class="header-icon-btn"
            title="Omega Network Website"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px;
              color: #00bcf2;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              text-decoration: none;
              transition: all 0.2s ease;
            "
          >
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M16.36,14C16.44,13.34 16.5,12.68 16.5,12C16.5,11.32 16.44,10.66 16.36,10H19.74C19.9,10.64 20,11.31 20,12C20,12.69 19.9,13.36 19.74,14M14.59,19.56C15.19,18.45 15.65,17.25 15.97,16H18.92C17.96,17.65 16.43,18.93 14.59,19.56M14.34,14H9.66C9.56,13.34 9.5,12.68 9.5,12C9.5,11.32 9.56,10.65 9.66,10H14.34C14.43,10.65 14.5,11.32 14.5,12C14.5,12.68 14.43,13.34 14.34,14M12,19.96C11.17,18.76 10.5,17.43 10.09,16H13.91C13.5,17.43 12.83,18.76 12,19.96M8,8H5.08C6.03,6.34 7.57,5.06 9.4,4.44C8.8,5.55 8.35,6.75 8,8M5.08,16H8C8.35,17.25 8.8,18.45 9.4,19.56C7.57,18.93 6.03,17.65 5.08,16M4.26,14C4.1,13.36 4,12.69 4,12C4,11.31 4.1,10.64 4.26,10H7.64C7.56,10.66 7.5,11.32 7.5,12C7.5,12.68 7.56,13.34 7.64,14M12,4.03C12.83,5.23 13.5,6.57 13.91,8H10.09C10.5,6.57 11.17,5.23 12,4.03M18.92,8H15.97C15.65,6.75 15.19,5.55 14.59,4.44C16.43,5.07 17.96,6.34 18.92,8M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"
              />
            </svg>
          </a>
          <a
            href="https://discord.com/invite/omeganetwork"
            target="_blank"
            class="header-icon-btn"
            title="Discord Community"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px;
              color: #00bcf2;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              text-decoration: none;
              transition: all 0.2s ease;
            "
          >
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M22,24L16.75,19L17.38,21H4.5A2.5,2.5 0 0,1 2,18.5V3.5A2.5,2.5 0 0,1 4.5,1H19.5A2.5,2.5 0 0,1 22,3.5V24M12,6.8C9.32,6.8 7.44,7.95 7.44,7.95C8.47,7.03 10.27,6.5 10.27,6.5L10.1,6.33C8.41,6.36 6.88,7.53 6.88,7.53C5.16,11.12 5.27,14.22 5.27,14.22C6.67,16.03 8.75,15.9 8.75,15.9L9.46,15C8.21,14.73 7.42,13.62 7.42,13.62C7.42,13.62 9.3,14.9 12,14.9C14.7,14.9 16.58,13.62 16.58,13.62C16.58,13.62 15.79,14.73 14.54,15L15.25,15.9C15.25,15.9 17.33,16.03 18.73,14.22C18.73,14.22 18.84,11.12 17.12,7.53C17.12,7.53 15.59,6.36 13.9,6.33L13.73,6.5C13.73,6.5 15.53,7.03 16.56,7.95C16.56,7.95 14.68,6.8 12,6.8Z"
              />
            </svg>
          </a>
          <a
            href="https://x.com/omega_netw0rk"
            target="_blank"
            class="header-icon-btn"
            title="X (Twitter)"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px;
              color: #00bcf2;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              text-decoration: none;
              transition: all 0.2s ease;
            "
          >
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
              />
            </svg>
          </a>
          <a
            href="https://omega-6.gitbook.io/omega/"
            target="_blank"
            class="header-icon-btn"
            title="Documentation"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px;
              color: #00bcf2;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              text-decoration: none;
              transition: all 0.2s ease;
            "
          >
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
              <path
                d="M19,2L14,6.5V17.5L19,13V2M6.5,5C4.55,5 2.45,5.4 1,6.5V21.16C1,21.41 1.25,21.66 1.5,21.66C1.6,21.66 1.65,21.59 1.75,21.59C3.1,20.94 5.05,20.5 6.5,20.5C8.45,20.5 10.55,20.9 12,22C13.35,21.15 15.8,20.5 17.5,20.5C19.15,20.5 20.85,20.81 22.25,21.56C22.35,21.61 22.4,21.59 22.5,21.59C22.75,21.59 23,21.34 23,21.09V6.5C22.4,6.05 21.75,5.75 21,5.5V7.5L21,13V19C19.9,18.65 18.7,18.5 17.5,18.5C15.8,18.5 13.35,19.15 12,20V13L12,8.5V6.5C10.55,5.4 8.45,5 6.5,5Z"
              />
            </svg>
          </a>
          <div
            style="
              width: 1px;
              height: 20px;
              background: rgba(0, 188, 242, 0.3);
              margin: 0 4px;
            "
          ></div>
          <button
            class="header-control-btn"
            title="Cycle Color Palette"
            id="colorPaletteToggle"
            onclick="window.cycleColorPalette()"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 12px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
              <path
                d="M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z"
              />
            </svg>
            <span>PALETTE</span>
          </button>
          <button
            class="header-control-btn"
            title="Cycle Theme"
            id="themeCycleToggle"
            onclick="window.cycleTheme()"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 12px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
              <path
                d="M12,18C11.11,18 10.26,17.8 9.5,17.45C11.56,16.5 13,14.42 13,12C13,9.58 11.56,7.5 9.5,6.55C10.26,6.2 11.11,6 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"
              />
            </svg>
            <span>CYCLE</span>
          </button>
          <button
            class="header-control-btn"
            title="Cycle Theme"
            id="themeSelectorToggle"
            onclick="window.cycleTheme()"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 12px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
              <path
                d="M12,2C6.5,2 2,6.5 2,12C2,17.5 6.5,22 12,22C17.5,22 22,17.5 22,12C22,6.5 17.5,2 12,2M12,4C16.4,4 20,7.6 20,12C20,16.4 16.4,20 12,20C7.6,20 4,16.4 4,12C4,7.6 7.6,4 12,4M12,6C8.7,6 6,8.7 6,12C6,15.3 8.7,18 12,18C15.3,18 18,15.3 18,12C18,8.7 15.3,6 12,6M12,8C14.2,8 16,9.8 16,12C16,14.2 14.2,16 12,16C9.8,16 8,14.2 8,12C8,9.8 9.8,8 12,8M12,10C10.9,10 10,10.9 10,12C10,13.1 10.9,14 12,14C13.1,14 14,13.1 14,12C14,10.9 13.1,10 12,10Z"
              />
            </svg>
            <span>THEME</span>
          </button>
          <button
            class="header-control-btn"
            title="Toggle Dark/Light Mode"
            id="oldTerminalThemeToggle"
            onclick="window.toggleOldTerminalTheme()"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 12px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
              <path
                d="M12,18C11.11,18 10.26,17.8 9.5,17.45C11.56,16.5 13,14.42 13,12C13,9.58 11.56,7.5 9.5,6.55C10.26,6.2 11.11,6 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"
              />
            </svg>
            <span id="oldTerminalThemeLabel">LIGHT</span>
          </button>
          <button
            class="header-control-btn"
            title="Switch to Dashboard View"
            id="oldTerminalDashboardToggle"
            onclick="window.switchToFuturisticUI()"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 12px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 6px;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
          >
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
              <path
                d="M3,3H9V7H3V3M15,10H21V14H15V10M15,17H21V21H15V17M13,13H7V18H13V13Z"
              />
            </svg>
            <span>DASHBOARD</span>
          </button>
          <!-- AI Provider Dropdown -->
          <label
            for="aiProviderSelect"
            style="
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              text-transform: uppercase;
              letter-spacing: 0.5px;
            "
            >AI:</label
          >
          <select
            id="aiProviderSelect"
            title="Select AI Provider"
            style="
              background: rgba(0, 188, 242, 0.1);
              border: 1px solid rgba(0, 188, 242, 0.3);
              border-radius: 6px;
              padding: 6px 10px;
              color: #00bcf2;
              font-family: 'Courier New', monospace;
              font-size: 11px;
              font-weight: 600;
              cursor: pointer;
              text-transform: uppercase;
              letter-spacing: 0.5px;
              appearance: none;
              -webkit-appearance: none;
              -moz-appearance: none;
              background-image: linear-gradient(
                  45deg,
                  transparent 50%,
                  #00bcf2 50%
                ),
                linear-gradient(135deg, #00bcf2 50%, transparent 50%);
              background-position: calc(100% - 15px) calc(1em + 2px),
                calc(100% - 10px) calc(1em + 2px);
              background-size: 5px 5px, 5px 5px;
              background-repeat: no-repeat;
              min-width: 110px;
            "
          >
            <option value="off">Off</option>
            <option value="near">NEAR AI</option>
            <option value="openai">OpenAI</option>
          </select>
          <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
        </div>
      </div>
      <div
        class="tab-bar"
        id="tabBar"
        style="
          display: flex;
          align-items: center;
          background: #111;
          border-bottom: 1px solid #00bcf2;
          box-shadow: 0 1px 10px rgba(0, 188, 242, 0.3);
        "
      >
        <div
          class="tab active"
          data-tab="0"
          style="
            padding: 8px 18px;
            cursor: pointer;
            border-right: 1px solid #333;
            color: #fff;
            font-weight: bold;
          "
        >
          Terminal 1
        </div>
        <div
          id="addTabBtn"
          style="
            padding: 8px 18px;
            cursor: pointer;
            color: #00bcf2;
            font-size: 1.3em;
          "
        >
          +
        </div>
      </div>

      <!-- Faucet Info Box -->
      <div
        id="faucetInfoBox"
        style="
          background: rgba(0, 188, 242, 0.1);
          border: 1px solid #00bcf2;
          color: #00bcf2;
          padding: 10px 16px;
          border-radius: 6px;
          margin: 0 0 12px 0;
          font-size: 15px;
          box-shadow: 0 0 10px rgba(0, 188, 242, 0.3);
        "
      >
        <b>⚡ Faucet Cooldown:</b> Each wallet can only claim once every 24
        hours.<br />
        If you try to claim again before the cooldown is over, the transaction
        will fail.<br /><br />
        <b>📱 Platform Notice:</b> Mobile experience is currently being
        optimized. For the best terminal experience with full features and
        optimal performance, we recommend using a desktop browser. Mobile
        support coming soon! 🚀
      </div>
      <div class="terminal-content" id="terminalContent"></div>
      <div class="terminal-input-section">
        <div class="input-line">
          <span class="input-prompt">Ω Terminal:~$</span>
          <input
            type="text"
            class="input-field"
            id="commandInput"
            autocomplete="off"
            spellcheck="false"
            placeholder="Enter command..."
          />
        </div>
      </div>
    </div>

    <script>
      // API URLs for different services
      const RELAYER_URL = "https://terminal-v1-5-9.onrender.com"; // Production relayer for mining/claims
      const OMEGA_API_URL = "https://omeganetwork.co/api"; // Production API for ambassador data

      // Simplified ethers loading with fallback support
      function loadEthers() {
        return new Promise((resolve, reject) => {
          // Small delay to ensure CDN script has time to load
          setTimeout(() => {
            console.log("Checking for ethers availability...");

            // Check if ethers is already loaded (CDN success)
            if (typeof ethers !== "undefined") {
              console.log("Ethers loaded successfully from CDN");
              resolve(ethers);
              return;
            }

            console.log(
              "CDN ethers not loaded, trying additional CDN sources..."
            );

            // Try multiple CDN sources
            const cdnSources = [
              "https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js",
              "https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js",
            ];

            let currentSource = 0;

            function tryNextSource() {
              if (currentSource >= cdnSources.length) {
                // All CDN sources failed, load fallback
                console.log(
                  "All CDN sources failed, loading fallback ethers..."
                );
                loadEthersFallback();
                resolve(ethers);
                return;
              }

              const script = document.createElement("script");
              script.src = cdnSources[currentSource];
              script.onload = () => {
                if (typeof ethers !== "undefined") {
                  console.log(
                    `Ethers loaded successfully from: ${cdnSources[currentSource]}`
                  );
                  resolve(ethers);
                } else {
                  currentSource++;
                  tryNextSource();
                }
              };
              script.onerror = () => {
                console.warn(
                  `Failed to load ethers from: ${cdnSources[currentSource]}`
                );
                currentSource++;
                tryNextSource();
              };
              document.head.appendChild(script);
            }

            tryNextSource();
          }, 500); // 500ms delay to ensure CDN script has time to load
        });
      }

      // Fallback ethers implementation - only loads if all CDN sources fail
      function loadEthersFallback() {
        console.log("Loading ethers fallback...");
        window.ethers = {
          providers: {
            Web3Provider: function (provider) {
              this.provider = provider;
              this.getSigner = () => ({
                getAddress: () =>
                  Promise.resolve("0x0000000000000000000000000000000000000000"),
                sendTransaction: () =>
                  Promise.reject(
                    new Error("Fallback ethers - no real transactions")
                  ),
              });
              this.getGasPrice = () =>
                Promise.resolve({ toString: () => "20000000000" });
              this.getBalance = () => Promise.resolve({ isZero: () => true });
              this.getTransactionCount = () => Promise.resolve(0);
            },
          },
          Contract: function (address, abi, signer) {
            this.address = address;
            this.abi = abi;
            this.signer = signer;
            // Add basic contract methods
            this.startMining = () =>
              Promise.resolve({ wait: () => Promise.resolve() });
            this.claimRewards = () =>
              Promise.resolve({ wait: () => Promise.resolve() });
          },
          Wallet: {
            createRandom: function () {
              return {
                address: "0x" + Math.random().toString(16).substr(2, 40),
                privateKey: "0x" + Math.random().toString(16).substr(2, 64),
                connect: function (provider) {
                  return this;
                },
                sendTransaction: function (tx) {
                  return Promise.resolve({
                    hash: "0x" + Math.random().toString(16).substr(2, 64),
                    wait: () => Promise.resolve(),
                  });
                },
              };
            },
          },
          utils: {
            formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
            parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
            id: (text) => "0x" + Math.random().toString(16).substr(2, 64),
            defaultAbiCoder: {
              decode: () => [
                "0x0000000000000000000000000000000000000000",
                "1000000000000000000",
                "1",
              ],
            },
            hexDataSlice: (data, start) => data,
          },
        };
        console.log("Ethers fallback loaded successfully");
      }

      // Old Terminal UI Theme Toggle Function
      window.toggleOldTerminalTheme = function () {
        const currentTheme = localStorage.getItem("omega-theme-mode") || "dark";
        const newTheme = currentTheme === "dark" ? "light" : "dark";

        localStorage.setItem("omega-theme-mode", newTheme);

        const terminal = document.getElementById("terminal");
        const terminalContent = document.querySelector(".terminal-content");
        const terminalOutput = document.querySelector(".terminal-output");
        const body = document.body;

        // Check if terminal is in Apple UI (Modern UI) mode
        const isAppleUI = terminal && terminal.classList.contains("apple-ui");

        if (newTheme === "light") {
          // Apply light mode
          body.classList.add("light-mode");
          body.classList.remove("dark-mode");

          // Handle Apple UI theme specifically
          if (isAppleUI && terminal) {
            terminal.classList.remove("dark");
            console.log("✅ Apple UI: Switched to light mode");
          }

          // Update terminal styles
          if (terminal) {
            terminal.style.background = "#ffffff";
            terminal.style.color = "#1d1d1f";
          }
          if (terminalContent) {
            terminalContent.style.background = "#ffffff";
            terminalContent.style.color = "#1d1d1f";
          }
          if (terminalOutput) {
            terminalOutput.style.color = "#1d1d1f";
          }

          // Update all output lines
          document
            .querySelectorAll(".terminal-line, .output-line")
            .forEach((line) => {
              line.style.color = "#1d1d1f";
            });

          // Update prompts
          document
            .querySelectorAll(".input-prompt, .prompt-symbol, .prompt-text")
            .forEach((prompt) => {
              prompt.style.color = "#007a3d";
            });

          // Update command input
          const commandInput = document.getElementById("commandInput");
          if (commandInput) {
            commandInput.style.color = "#1d1d1f";
          }

          // Update button label
          const label = document.getElementById("oldTerminalThemeLabel");
          if (label) label.textContent = "DARK";

          console.log("✅ Switched to light mode - all text updated");

          // Log to terminal if available
          if (window.terminal && window.terminal.log) {
            window.terminal.log("🌞 Light mode enabled", "success");
          }
        } else {
          // Apply dark mode
          body.classList.add("dark-mode");
          body.classList.remove("light-mode");

          // Handle Apple UI theme specifically
          if (isAppleUI && terminal) {
            terminal.classList.add("dark");
            console.log("✅ Apple UI: Switched to dark mode");
          }

          // Update terminal styles
          if (terminal) {
            terminal.style.background = "#000";
            terminal.style.color = "#ffffff";
          }
          if (terminalContent) {
            terminalContent.style.background = "#000";
            terminalContent.style.color = "#ffffff";
          }
          if (terminalOutput) {
            terminalOutput.style.color = "#ffffff";
          }

          // Update all output lines
          document
            .querySelectorAll(".terminal-line, .output-line")
            .forEach((line) => {
              line.style.color = "";
            });

          // Update prompts
          document
            .querySelectorAll(".input-prompt, .prompt-symbol, .prompt-text")
            .forEach((prompt) => {
              prompt.style.color = "";
            });

          // Update command input
          const commandInput = document.getElementById("commandInput");
          if (commandInput) {
            commandInput.style.color = "";
          }

          // Update button label
          const label = document.getElementById("oldTerminalThemeLabel");
          if (label) label.textContent = "LIGHT";

          console.log("✅ Switched to dark mode");

          // Log to terminal if available
          if (window.terminal && window.terminal.log) {
            window.terminal.log("🌙 Dark mode enabled", "success");
          }
        }

        // If futuristic dashboard exists, sync with it
        if (
          window.FuturisticDashboard &&
          window.FuturisticDashboard.updateThemeModeButton
        ) {
          window.FuturisticDashboard.updateThemeModeButton();
        }
      };

      // Switch from Old Terminal to Futuristic Dashboard UI
      window.switchToFuturisticUI = function () {
        console.log("🚀 Switching to Futuristic Dashboard UI...");

        // Save preference
        localStorage.setItem("omega-view-mode", "futuristic");

        // If dashboard already exists, just enable it
        if (
          window.FuturisticDashboard &&
          window.FuturisticDashboard.enableFuturisticMode
        ) {
          window.FuturisticDashboard.enableFuturisticMode();

          if (window.terminal) {
            window.terminal.log(
              "✅ Switched to Futuristic Dashboard",
              "success"
            );
          }
        } else {
          // Dashboard doesn't exist yet, reload page (it will auto-load dashboard)
          console.log("🔄 Reloading to initialize dashboard...");
          location.reload();
        }
      };

      // Initialize theme on page load for old terminal
      (function () {
        const savedTheme = localStorage.getItem("omega-theme-mode") || "dark";
        if (savedTheme === "light") {
          document.body.classList.add("light-mode");
          document.body.classList.remove("dark-mode");
        } else {
          document.body.classList.add("dark-mode");
          document.body.classList.remove("light-mode");
        }
      })();

      // Enhanced cursor indicator system
      window.initCursorIndicator = function () {
        const input = document.getElementById("commandInput");
        if (!input) {
          // Retry if input not ready
          setTimeout(window.initCursorIndicator, 100);
          return;
        }

        // Check if already initialized
        if (input.dataset.cursorInit === "true") return;
        input.dataset.cursorInit = "true";

        // Create cursor indicator element
        let indicator = document.getElementById("omegaCursorIndicator");
        if (!indicator) {
          indicator = document.createElement("span");
          indicator.id = "omegaCursorIndicator";
          indicator.className = "omega-cursor-indicator";
          indicator.textContent = "█";

          // Insert after the input
          const inputLine = input.closest(".input-line");
          if (inputLine) {
            inputLine.appendChild(indicator);
          }
        }

        // Position updater function
        function updateCursorPosition() {
          if (!indicator || !input) return;

          // Create measurement element
          const measure = document.createElement("span");
          measure.style.cssText = `
              font-family: ${window.getComputedStyle(input).fontFamily};
              font-size: ${window.getComputedStyle(input).fontSize};
              font-weight: ${window.getComputedStyle(input).fontWeight};
              letter-spacing: ${window.getComputedStyle(input).letterSpacing};
              position: absolute;
              visibility: hidden;
              white-space: pre;
              left: -9999px;
            `;
          measure.textContent = input.value || "";
          document.body.appendChild(measure);

          const textWidth = measure.offsetWidth;
          document.body.removeChild(measure);

          // Get input's offset relative to parent
          const inputRect = input.getBoundingClientRect();
          const lineRect = input
            .closest(".input-line")
            ?.getBoundingClientRect();

          if (lineRect) {
            const offset = inputRect.left - lineRect.left;
            indicator.style.left = offset + textWidth + 2 + "px";
          }
        }

        // Attach event listeners
        input.addEventListener("input", updateCursorPosition);
        input.addEventListener("keyup", updateCursorPosition);
        input.addEventListener("keydown", updateCursorPosition);
        input.addEventListener("click", updateCursorPosition);
        input.addEventListener("focus", updateCursorPosition);

        // Initial position
        setTimeout(updateCursorPosition, 50);

        console.log("✅ Cursor indicator initialized");
      };

      // Initialize on DOM ready
      document.addEventListener("DOMContentLoaded", window.initCursorIndicator);

      // Also retry after a delay to catch dynamically created inputs
      setTimeout(window.initCursorIndicator, 500);
      setTimeout(window.initCursorIndicator, 1000);
      setTimeout(window.initCursorIndicator, 2000);

      class OmegaMinerTerminal {
        // For AI/automation: queue of prompt responses
        aiPromptQueue = [];
        // Chat history for AI context and error handling
        chatHistory = [];
        // Handle the 'shade' command: deploy/check agent, show info
        constructor() {
          // VERSION CHECK - This should be visible in terminal if updated code is loaded
          console.log("🚀 OMEGA TERMINAL CONSTRUCTOR VERSION 2.0.1");
          this.version = "2.0.1";
          this.tabs = [{ id: 0, name: "Terminal 1", history: [], output: [] }];
          this.activeTab = 0;
          console.log("[DEBUG] OmegaMinerTerminal constructor called");
          if (window && window.terminal) {
            console.log(
              "[DEBUG] Previous terminal instance found, overwriting"
            );
          }
          this.provider = null;
          this.signer = null;
          this.contract = null;
          this.isMining = false;
          this.miningInterval = null;
          this.currentNonce = 0;
          this.ethers = null;
          this.isDarkTheme = true; // Default to dark theme

          // Load saved theme preference
          const savedTheme = localStorage.getItem("omega-terminal-theme");
          if (savedTheme) {
            this.isDarkTheme = savedTheme === "dark";
          }

          // New mining system properties
          this.pendingClaimableBalance = 0;
          this.totalEarned = 0; // Track total earned during session
          this.waitingForContinueResponse = false;

          // Stress test properties
          this.isStressTesting = false;
          this.stressTestInterval = null;
          this.stressTestStats = {
            walletsCreated: 0,
            transactionsSent: 0,
            successfulTxs: 0,
            failedTxs: 0,
            startTime: 0,
          };
          this.stressWallet = null;
          this.stressNonce = 0;

          // Contract properties
          this.contractAddress = "0x54c731627f2d2b55267b53e604c869ab8e6a323b"; // SimpleMiner contract with claimTo
          this.faucetAddress = "0xf8e00f8cfaccf9b95f703642ec589d1c6ceee1a9"; // Update faucet contract address
          this.minerFaucetAddress =
            "0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207"; // Deployed OmegaMinerFaucet contract
          this.contractABI = [
            "function mineBlock(uint256 nonce, bytes32 solution) external",
            "function claimRewards() external",
            "function claimTo(address recipient) external",
            "function getMinerInfo(address miner) external view returns (uint256 _totalMined, uint256 _lastMineTime, uint256 _pendingRewards)",
            "function calculateReward(address miner, uint256 nonce, bytes32 solution) external view returns (uint256)",
            "function cooldownPeriod() external view returns (uint256)",
            "function totalRewardsDistributed() external view returns (uint256)",
            "function owner() external view returns (address)",
            "function setCooldownPeriod(uint256 _cooldown) external",
            "function withdrawExcess() external",
            "event BlockMined(address indexed miner, uint256 nonce, bytes32 solution, uint256 reward)",
            "event RewardsClaimed(address indexed miner, uint256 amount)",
          ];
          this.faucetABI = [
            {
              inputs: [],
              name: "claim",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "user", type: "address" },
              ],
              name: "getFaucetStatus",
              outputs: [
                { internalType: "bool", name: "canClaimNow", type: "bool" },
                { internalType: "uint256", name: "lastClaim", type: "uint256" },
                {
                  internalType: "uint256",
                  name: "timeUntilNextClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "claimAmount",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "faucetBalance",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "totalClaims_",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "emergencyWithdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              stateMutability: "nonpayable",
              type: "constructor",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "amount",
                  type: "uint256",
                },
              ],
              name: "FaucetRefilled",
              type: "event",
            },
            {
              inputs: [],
              name: "refillFaucet",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "amount",
                  type: "uint256",
                },
                {
                  indexed: false,
                  internalType: "uint256",
                  name: "timestamp",
                  type: "uint256",
                },
              ],
              name: "TokensClaimed",
              type: "event",
            },
            {
              inputs: [],
              name: "withdrawFaucet",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              stateMutability: "payable",
              type: "receive",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "canClaim",
              outputs: [
                {
                  internalType: "bool",
                  name: "",
                  type: "bool",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "CLAIM_AMOUNT",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "CLAIM_COOLDOWN",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "faucetBalance",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "getClaimInfo",
              outputs: [
                {
                  internalType: "bool",
                  name: "canClaimNow",
                  type: "bool",
                },
                {
                  internalType: "uint256",
                  name: "lastClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "timeUntilNextClaim",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "claimAmount",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "getFaucetBalance",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "user",
                  type: "address",
                },
              ],
              name: "getTimeUntilNextClaim",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "",
                  type: "address",
                },
              ],
              name: "lastClaimTime",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "totalClaims",
              outputs: [
                {
                  internalType: "uint256",
                  name: "",
                  type: "uint256",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
          ];
          this.minerFaucetABI = [
            {
              inputs: [],
              name: "mine",
              outputs: [],
              stateMutability: "payable",
              type: "function",
            },
            {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "totalMined",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "lastMineTime",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          ];

          this.loadTheme();
          console.log("[DEBUG] Calling init() from constructor");
          this.init();

          // In the OmegaMinerTerminal class:
          // 1. Add DM prompt state variables to the constructor
          this.awaitingDMRecipient = false;
          this.awaitingDMMessage = false;
          this.tempDMRecipient = "";
          this.solanaAddress = null;
          this.awaitingWalletChoice = false;

          // Initialize AI provider/mode state
          this.aiProvider = localStorage.getItem("omega-ai-provider") || "off"; // 'off' | 'near' | 'openai'
          this.isAIModeOn = this.aiProvider !== "off";
          this.executingAICommands = false;
        }

        async init() {
          // Show boot animation first
          await this.showBootAnimation();
          // Always set up event listeners immediately after boot
          this.setupEventListeners();
          try {
            this.ethers = await loadEthers();
          } catch (error) {
            console.error("Failed to load ethers:", error);
            this.log(
              "Failed to load ethers library: " + error.message,
              "error"
            );
            this.log(
              "Please check your internet connection and refresh the page",
              "error"
            );
          }
        }

        /**
         * Check if a command looks like a question
         */
        isQuestionLike(command) {
          const questionWords = [
            "what",
            "how",
            "why",
            "when",
            "where",
            "who",
            "which",
            "can",
            "could",
            "would",
            "should",
            "is",
            "are",
            "was",
            "were",
            "do",
            "does",
            "did",
            "will",
            "shall",
            "may",
            "might",
            "explain",
            "tell",
            "describe",
            "define",
            "show",
            "help",
            "guide",
            "tutorial",
          ];

          const questionMarks = ["?"];
          const commandLower = command.toLowerCase().trim();

          // Check for question marks
          if (questionMarks.some((mark) => commandLower.includes(mark))) {
            return true;
          }

          // Check if it starts with a question word
          if (
            questionWords.some((word) => commandLower.startsWith(word + " "))
          ) {
            return true;
          }

          // Check if it contains multiple words and looks like a question
          const words = commandLower.split(/\s+/);
          if (words.length >= 2) {
            // Check if it contains question words anywhere
            if (questionWords.some((word) => words.includes(word))) {
              return true;
            }

            // Check for common question patterns
            const questionPatterns = [
              /^what is/,
              /^how to/,
              /^how do/,
              /^how can/,
              /^why is/,
              /^when is/,
              /^where is/,
              /^who is/,
              /^can you/,
              /^could you/,
              /^would you/,
              /^should i/,
              /^explain/,
              /^tell me/,
              /^describe/,
              /^define/,
              /^show me/,
              /^help me/,
            ];

            if (
              questionPatterns.some((pattern) => pattern.test(commandLower))
            ) {
              return true;
            }
          }

          return false;
        }

        loadTheme() {
          const theme = localStorage.getItem("omega-terminal-theme") || "dark";
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro"
            );
            terminal.classList.add("theme-" + theme);
          }
          localStorage.setItem("omega-terminal-theme", theme);
        }

        async showBootAnimation() {
          return new Promise((resolve) => {
            setTimeout(() => {
              // Hide boot animation
              document.getElementById("bootAnimation").style.display = "none";

              // Always go directly to terminal (no UI selection screen)
              document.getElementById("terminal").style.display = "flex";
              this.applyTheme();
              // Enhanced welcome sequence
              this.log(
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                "output"
              );
              this.log("", "output");
              this.log(
                "    01001111 01101101 01100101 01100111 01100001",
                "info"
              );
              this.log("", "output");
              this.log("    ⚡ WELCOME TO Ω OMEGA TERMINAL v2.0.1", "success");
              this.log("", "output");
              this.log(
                "    🚀 Your Gateway to Web3, DeFi, NFTs & Advanced Trading",
                "info"
              );
              this.log("", "output");
              this.log("    💡 Quick Start:", "output");
              this.log(
                '       • Type "connect" to connect your wallet',
                "output"
              );
              this.log(
                '       • Type "help" to see all available commands',
                "output"
              );
              this.log(
                '       • Type "chart BTC" for live crypto charts',
                "output"
              );
              this.log(
                '       • Type "spotify" for music player integration',
                "output"
              );
              this.log("", "output");
              this.log(
                "    🌐 Access: Omega Network • Multi-Chain • DeFi Analytics",
                "info"
              );
              this.log("", "output");
              this.log(
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                "output"
              );
              this.log("", "output");
              resolve();
            }, 4000); // Extended boot time to show cool animation
          });
        }

        applyUIPreference(preference) {
          const terminal = document.getElementById("terminal");
          if (preference === "modern") {
            terminal.classList.add("apple-ui", "dark");
          }
          // Terminal UI is default, no class needed
        }

        showGettingStartedModal() {
          // Create modal HTML
          const modalHTML = `
                    <div class="modal-overlay" id="gettingStartedModal">
                        <div class="modal-content">
                            <div class="modal-title">🚀 How To Get Started</div>
                            <div class="modal-steps">
                                <div class="modal-step">
                                    <span class="modal-step-number">1.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">connect</span> for MetaMask, <span style="color:#33bbff;font-weight:bold;">yes</span> for new Omega Wallet, or <span style="color:#33bbff;font-weight:bold;">import</span> for existing wallet
                                </div>
                                <div class="modal-step">
                                    <span class="modal-step-number">2.</span>
                                    Type <span style="color:#33bbff;font-weight:bold;">help</span> for a list of commands
                                </div>
                            </div>
                            <button class="modal-button" onclick="document.getElementById('gettingStartedModal').remove(); document.getElementById('commandInput').focus();">
                                Let's Get Started!
                            </button>
                        </div>
                    </div>
                `;

          // Add modal to page
          document.body.insertAdjacentHTML("beforeend", modalHTML);

          // Focus on the button for accessibility
          setTimeout(() => {
            const button = document.querySelector(".modal-button");
            if (button) button.focus();
          }, 100);
        }

        setupEventListeners() {
          const input = document.getElementById("commandInput");
          if (input) {
            input.focus();

            // Add cursor indicator animation on focus/blur
            const inputLine = input.closest(".input-line");
            if (inputLine) {
              input.addEventListener("focus", () => {
                inputLine.classList.add("active");
              });
              input.addEventListener("blur", () => {
                inputLine.classList.remove("active");
              });
              // Start with active state since we auto-focus
              inputLine.classList.add("active");
            }

            // Command history and autocomplete state
            this.commandHistory = [];
            this.historyIndex = -1;
            this.lastInputValue = "";
            this.availableCommands = [
              "help",
              "clear",
              "connect",
              "disconnect",
              "balance",
              "faucet",
              "mine",
              "claim",
              "status",
              "stats",
              "send",
              "ens",
              "mixer",
              "stress",
              "stopstress",
              "stressstats",
              "theme",
              "rickroll",
              "fortune",
              "matrix",
              "hack",
              "disco",
              "stop",
              "tab",
              "email",
              "inbox",
              "dexscreener",
              "geckoterminal",
              "stock",
              "alphakey",
              "ds",
              "cg",
              "alpha",
              "airdrop",
              "solana",
              "eclipse",
              "fair",
              "fns",
              "hyperliquid",
              "polymarket",
              "poly",
              "events",
              "recent",
              "magiceden",
              "import",
              "ambassador",
              "profile",
              "gui",
              "rome",
              "kalshi",
              "bot",
              "bots",
              "pgt",
              "pgt-demo",
              "game",
              "play",
              "chat",
              "near-wallet",
              "nearwallet",
              "near",
              "ref",
              "defillama",
              "llama",
              "defi",
              "tvl",
              "modern",
              "nft",
              "opensea",
              "profile",
              "terminal",
              "mint",
            ];
            input.addEventListener("keydown", (e) => {
              // Up arrow: previous command
              if (e.key === "ArrowUp") {
                if (this.commandHistory.length > 0) {
                  if (this.historyIndex === -1) {
                    this.historyIndex = this.commandHistory.length - 1;
                    this.lastInputValue = input.value;
                  } else if (this.historyIndex > 0) {
                    this.historyIndex--;
                  }
                  input.value = this.commandHistory[this.historyIndex];
                  setTimeout(
                    () =>
                      input.setSelectionRange(
                        input.value.length,
                        input.value.length
                      ),
                    0
                  );
                }
                e.preventDefault();
              }
              // Down arrow: next command or clear
              if (e.key === "ArrowDown") {
                if (
                  this.commandHistory.length > 0 &&
                  this.historyIndex !== -1
                ) {
                  if (this.historyIndex < this.commandHistory.length - 1) {
                    this.historyIndex++;
                    input.value = this.commandHistory[this.historyIndex];
                  } else {
                    this.historyIndex = -1;
                    input.value = this.lastInputValue || "";
                  }
                  setTimeout(
                    () =>
                      input.setSelectionRange(
                        input.value.length,
                        input.value.length
                      ),
                    0
                  );
                }
                e.preventDefault();
              }
              // Tab: autocomplete
              if (e.key === "Tab") {
                e.preventDefault();
                const val = input.value.trim();
                if (!val) return;
                const matches = this.availableCommands.filter((cmd) =>
                  cmd.startsWith(val)
                );
                if (matches.length === 1) {
                  input.value = matches[0] + " ";
                } else if (matches.length > 1) {
                  this.logHtml(
                    '<span style="color:#cccccc">' +
                      matches.join("    ") +
                      "</span>",
                    "info"
                  );
                }
              }
            });
            // Position cursor dynamically after text - DISABLED, using native browser caret
            const cursorElement = document.querySelector(".cursor");
            const promptElement = document.querySelector(".input-prompt");
            let animationFrameId = null;

            const updateCursorPosition = () => {
              // DISABLED: Using native browser caret instead of custom cursor
              return;

              if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
              }

              animationFrameId = requestAnimationFrame(() => {
                if (cursorElement && input && promptElement) {
                  // Get the actual computed font from the input element
                  const computedStyle = window.getComputedStyle(input);
                  const fontSize = computedStyle.fontSize;
                  const fontFamily = computedStyle.fontFamily;
                  const fontWeight = computedStyle.fontWeight;
                  const font = `${fontWeight} ${fontSize} ${fontFamily}`;

                  // Get actual text width
                  const textWidth = this.getTextWidth(input.value, font);

                  // Get input field's actual position relative to parent
                  const inputRect = input.getBoundingClientRect();
                  const inputLineRect =
                    input.parentElement.getBoundingClientRect();
                  const promptRect = promptElement.getBoundingClientRect();

                  // Calculate position relative to input-line container
                  const relativeInputLeft = inputRect.left - inputLineRect.left;

                  cursorElement.style.position = "absolute";
                  cursorElement.style.left = `${
                    relativeInputLeft + textWidth
                  }px`;
                  cursorElement.style.top = "50%";
                  cursorElement.style.transform = "translateY(-50%)";
                }
              });
            };

            // Update on every input event immediately - DISABLED
            // input.addEventListener("input", () => {
            //   updateCursorPosition();
            // });

            // input.addEventListener("keydown", () => {
            //   updateCursorPosition();
            // });

            // DISABLED: Using native browser caret
            // input.addEventListener("keyup", () => {
            //   updateCursorPosition();
            // });

            // Continuous update for smooth cursor following - DISABLED
            // setInterval(() => {
            //   if (document.activeElement === input) {
            //     updateCursorPosition();
            //   }
            // }, 50); // Update every 50ms when input is focused

            // setTimeout(updateCursorPosition, 100); // Initial position with delay - DISABLED

            input.addEventListener("keypress", async (e) => {
              if (e.key === "Enter") {
                const val = input.value;
                input.value = "";
                updateCursorPosition(); // Reset cursor position after clearing input
                if (this.awaitingPromptInput && this.promptResolver) {
                  const value = val.trim();
                  this.awaitingPromptInput = false;
                  this.promptResolver(value);
                  this.promptResolver = null;
                } else {
                  if (val.trim()) {
                    this.commandHistory.push(val.trim());
                    if (this.commandHistory.length > 100)
                      this.commandHistory.shift();
                  }
                  this.historyIndex = -1;
                  this.lastInputValue = "";
                  await this.executeCommand(val);
                }
              }
              // Ctrl+C to stop stress test
              if (e.key === "c" && e.ctrlKey) {
                // 'this' is not needed here, as isStressTesting is not used in this context
              }
            });

            // Input field is now clean - hardcoded cursor spans are hidden via CSS

            // Fallback: refocus input if user clicks anywhere in the terminal
            document
              .getElementById("terminal")
              .addEventListener("click", function () {
                input.focus();
              });
          }
          // Setup AI provider selector
          const aiProviderSelect = document.getElementById("aiProviderSelect");
          if (aiProviderSelect) {
            // Set initial value from state/localStorage
            try {
              aiProviderSelect.value = this.aiProvider || "off";
            } catch (e) {
              aiProviderSelect.value = "off";
            }
            // Apply initial UI and placeholder
            this.applyAIProviderUI();
            aiProviderSelect.addEventListener("change", (e) => {
              const provider = e.target.value;
              this.setAIProvider(provider);
            });
          }

          // Setup theme toggle
          const themeToggle = document.querySelector(".theme-toggle");
          if (themeToggle) {
            themeToggle.addEventListener("click", () => {
              this.toggleTheme();
            });
            // Remove emoji/text, just hollow circle
            themeToggle.textContent = "";
          }

          // Setup tab system
          const addTabBtn = document.getElementById("addTabBtn");
          if (addTabBtn) {
            addTabBtn.addEventListener("click", () => {
              const newId = this.tabs.length;
              this.tabs.push({
                id: newId,
                name: `Terminal ${newId + 1}`,
                history: [],
                output: [],
              });
              this.activeTab = newId;
              this.renderTabs();
              this.clearTerminalContent();
            });
          }
        }

        async promptTerminalInput() {
          return new Promise((resolve) => {
            this.awaitingPromptInput = true;
            this.promptResolver = resolve;
          });
        }

        // Alias for promptTerminalInput
        async promptUser() {
          return this.promptTerminalInput();
        }

        async checkWalletConnection() {
          if (typeof window.ethereum !== "undefined") {
            try {
              // Force MetaMask selection before checking accounts
              if (
                window.ethereum.providers &&
                Array.isArray(window.ethereum.providers)
              ) {
                const metamaskProvider = window.ethereum.providers.find(
                  (p) => p.isMetaMask
                );
                if (metamaskProvider) {
                  window.ethereum = metamaskProvider;
                  console.log(
                    "MetaMask provider forced in checkWalletConnection"
                  );
                }
              }

              // Check if we have a valid MetaMask provider after forcing
              if (window.ethereum && window.ethereum.isMetaMask) {
                const accounts = await window.ethereum.request({
                  method: "eth_accounts",
                });
                if (accounts.length > 0) {
                  await this.connectWallet();
                }
              } else {
                console.log("MetaMask not available after provider selection");
              }
            } catch (error) {
              this.log(
                "Error checking wallet connection: " + error.message,
                "error"
              );
            }
          }
        }

        async connectWallet() {
          try {
            if (!this.ethers) {
              this.log(
                "Ethers library not loaded. Please refresh the page.",
                "error"
              );
              return;
            }

            // Smart MetaMask detection and Phantom handling
            let provider;
            let providerName = "Unknown";

            if (window.ethereum) {
              // If we already have MetaMask selected, use it
              if (window.ethereum.isMetaMask) {
                provider = window.ethereum;
                providerName = "MetaMask";
                this.log("✅ Using MetaMask provider", "success");
              }
              // Check if we have multiple providers and can find MetaMask
              else if (
                window.ethereum.providers &&
                Array.isArray(window.ethereum.providers)
              ) {
                const metamaskProvider = window.ethereum.providers.find(
                  (p) => p.isMetaMask
                );
                if (metamaskProvider) {
                  // Force MetaMask
                  window.ethereum = metamaskProvider;
                  provider = metamaskProvider;
                  providerName = "MetaMask";
                  this.log("✅ MetaMask provider found and forced", "success");
                } else if (window.ethereum.isPhantom) {
                  // Only Phantom available - reject
                  this.log(
                    "❌ Only Phantom EVM detected - blocking connection",
                    "error"
                  );
                  this.log(
                    "💡 Please install MetaMask for Omega network support",
                    "info"
                  );
                  return;
                } else {
                  // Other provider - try to use it but warn
                  provider = window.ethereum;
                  providerName = "Other";
                  this.log(
                    "⚠️ Using non-MetaMask provider - may not support Omega network",
                    "warning"
                  );
                }
              }
              // Single provider case
              else {
                if (window.ethereum.isPhantom) {
                  this.log(
                    "❌ Phantom EVM detected - blocking connection",
                    "error"
                  );
                  this.log(
                    "💡 Please disable Phantom EVM or use MetaMask for Omega network",
                    "info"
                  );
                  return;
                } else {
                  provider = window.ethereum;
                  providerName = window.ethereum.isMetaMask
                    ? "MetaMask"
                    : "Other";
                  if (!window.ethereum.isMetaMask) {
                    this.log(
                      "⚠️ Using non-MetaMask provider - may not support Omega network",
                      "warning"
                    );
                  }
                }
              }
            } else {
              this.log(
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                "output"
              );
              this.log("", "info");
              this.log("    ⚠️  NO EVM WALLET DETECTED", "error");
              this.log("", "info");
              this.log(
                "    🎁 EXCLUSIVE OFFER: Create Your Ω OMEGA Wallet!",
                "success"
              );
              this.log("", "info");
              this.log("    💎 What You Get:", "info");
              this.log(
                "       • 🆓 Free Omega Network wallet (browser-based)",
                "output"
              );
              this.log("       • 💰 Instant 0.1 OMEGA token airdrop", "output");
              this.log(
                "       • ⛏️  Ready for mining & claiming rewards",
                "output"
              );
              this.log(
                "       • 🔐 Secure, encrypted private key storage",
                "output"
              );
              this.log(
                "       • 🚀 Start trading & earning immediately",
                "output"
              );
              this.log("", "info");
              this.log("    ⌨️  Your Choice:", "info");
              this.log(
                '       • Type "yes" → Generate Ω OMEGA Wallet + FREE 0.1 OMEGA',
                "success"
              );
              this.log(
                '       • Type "no" → Cancel (install MetaMask instead)',
                "output"
              );
              this.log("", "info");
              this.log(
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                "output"
              );
              this.log("", "info");
              this.awaitingWalletChoice = true;
              return;
            }

            this.log(`🔗 Connecting to ${providerName}...`, "info");

            // Request account access
            try {
              await provider.request({ method: "eth_requestAccounts" });
              this.log("✅ Account access granted", "success");
            } catch (requestError) {
              this.log("❌ Connection denied by user", "error");
              return;
            }

            this.provider = new this.ethers.providers.Web3Provider(provider);
            this.signer = this.provider.getSigner();

            this.log("🔍 Getting wallet address...", "info");
            const address = await this.signer.getAddress();
            this.userAddress = address;

            // CRITICAL: Check if this is actually MetaMask by testing network switching
            try {
              const currentNetwork = await this.provider.getNetwork();
              this.log(
                `🔍 Current network: Chain ID ${currentNetwork.chainId}`,
                "info"
              );

              // Try to switch to Omega network - this will fail with Phantom EVM
              try {
                await provider.request({
                  method: "wallet_switchEthereumChain",
                  params: [{ chainId: "0x4e454228" }], // Omega chain ID
                });
                this.log(
                  "✅ Successfully switched to Omega network - this is MetaMask!",
                  "success"
                );
              } catch (switchError) {
                if (switchError.code === 4902) {
                  // Chain not added, try to add it
                  try {
                    const networkConfig = {
                      chainId: "0x4e454228",
                      chainName: "Omega Network",
                      nativeCurrency: {
                        name: "OMEGA",
                        symbol: "OMEGA",
                        decimals: 18,
                      },
                      rpcUrls: ["https://0x4e454228.rpc.aurora-cloud.dev"],
                      blockExplorerUrls: [
                        "https://0x4e454228.explorer.aurora-cloud.dev/",
                      ],
                    };

                    this.log("🔍 Adding network with config:", "info");
                    this.log(
                      `   Chain ID: ${networkConfig.chainId} (${parseInt(
                        networkConfig.chainId,
                        16
                      )} decimal)`,
                      "info"
                    );
                    this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, "info");
                    this.log(
                      `   Explorer: ${networkConfig.blockExplorerUrls[0]}`,
                      "info"
                    );

                    // Debug: Log the exact request being sent
                    console.log(
                      "[DEBUG] Sending wallet_addEthereumChain request:",
                      {
                        method: "wallet_addEthereumChain",
                        params: [networkConfig],
                      }
                    );

                    await provider.request({
                      method: "wallet_addEthereumChain",
                      params: [networkConfig],
                    });
                    this.log(
                      "✅ Successfully added Omega network - this is MetaMask!",
                      "success"
                    );
                  } catch (addError) {
                    this.log(
                      "❌ Failed to add Omega network - this might be Phantom EVM",
                      "error"
                    );
                    this.log(
                      "💡 Phantom EVM does not support custom networks like Omega",
                      "info"
                    );
                    return;
                  }
                } else {
                  this.log(
                    "❌ Failed to switch to Omega network - this might be Phantom EVM",
                    "error"
                  );
                  this.log(
                    "💡 Phantom EVM does not support custom networks like Omega",
                    "info"
                  );
                  return;
                }
              }
            } catch (networkError) {
              this.log(
                "❌ Failed to check network - this might be Phantom EVM",
                "error"
              );
              return;
            }

            // Check if we're using fallback ethers (which would return 0x000... address)
            if (address === "0x0000000000000000000000000000000000000000") {
              this.log(
                "⚠️ Using fallback ethers - real transactions not available",
                "warning"
              );
              this.log(
                "💡 Please check your internet connection and refresh the page",
                "info"
              );
              return;
            }

            this.log(`✅ Wallet connected: ${address}`, "success");
            this.updateConnectionStatus("CONNECTED");

            if (
              this.contractAddress !==
              "0x0000000000000000000000000000000000000000"
            ) {
              this.contract = new this.ethers.Contract(
                this.contractAddress,
                this.contractABI,
                this.signer
              );
              this.log("✅ Mining contract connected", "success");
            }
          } catch (error) {
            console.error("Connect wallet error:", error);
            this.log("❌ Failed to connect wallet: " + error.message, "error");
            this.log(
              "💡 Make sure MetaMask is unlocked and you approve the connection",
              "info"
            );
          }
        }

        async disconnectWallet() {
          try {
            if (!this.signer) {
              this.log("No wallet connected to disconnect.", "warning");
              return;
            }

            // Get the address before disconnecting for the message
            const address = await this.signer.getAddress();

            // Clear all wallet-related properties
            this.provider = null;
            this.signer = null;
            this.contract = null;
            this.pendingClaimableBalance = 0;

            this.log(`🔌 Wallet disconnected: ${address}`, "success");
            this.updateConnectionStatus("DISCONNECTED");
            this.log(
              '💡 Use "connect" command to reconnect your wallet',
              "info"
            );
          } catch (error) {
            console.error("Disconnect wallet error:", error);
            this.log(
              "❌ Error disconnecting wallet: " + error.message,
              "error"
            );
          }
        }

        async executeCommand(command) {
          // Debug logging
          console.log("executeCommand called with:", typeof command, command);

          // Handle array commands first (from AI)
          if (Array.isArray(command)) {
            console.log("Processing array command:", command);
            if (command.length > 0) {
              const [mainCommand, ...promptResponses] = command;
              console.log(
                "Main command extracted:",
                typeof mainCommand,
                mainCommand
              );
              console.log("Prompt responses:", promptResponses);

              // Ensure mainCommand is a string
              if (typeof mainCommand !== "string") {
                console.log("Main command is not a string:", mainCommand);
                this.log("❌ Invalid main command in array", "error");
                return;
              }

              this.aiPromptQueue = promptResponses;
              console.log("Executing main command:", mainCommand);
              await this.executeCommand(mainCommand, true);
              this.aiPromptQueue = [];
            }
            return;
          }

          // Ensure command is a string before proceeding
          if (typeof command !== "string") {
            console.log("Invalid command type:", typeof command, command);
            this.log("❌ Invalid command format", "error");
            return;
          }

          // Track user input in chat history (if not from AI)
          if (!arguments[1] || arguments[1] !== true) {
            this.chatHistory.push({ type: "user", message: command });
          }

          // Handle custom swap direction first!
          if (this.awaitingCustomSwapDirection) {
            const dir = command.trim();
            if (dir === "1") {
              this.customSwapDirection = 1;
              this.awaitingCustomSwapDirection = false;
              this.awaitingCustomSwapAmount = true;
              this.log(
                `Enter amount of SOL to swap (e.g. 0.001, you have X SOL):`,
                "info"
              );
            } else if (dir === "2") {
              this.customSwapDirection = 2;
              this.awaitingCustomSwapDirection = false;
              this.awaitingCustomSwapAmount = true;
              this.log(
                `Enter amount of ${this.customSwapTokenSymbol} to swap (e.g. 1000, you have X):`,
                "info"
              );
            } else {
              this.log("Please type 1 or 2.", "warning");
            }
            return;
          }
          if (this.awaitingCustomSwapAmount) {
            const amtStr = command.trim();
            this.awaitingCustomSwapAmount = false;
            let amountLamports;
            let fromMint, toMint;
            if (this.customSwapDirection === 1) {
              // SOL → Token
              fromMint = "So11111111111111111111111111111111111111112";
              toMint = this.customSwapTokenMint;
              amountLamports = Math.round(parseFloat(amtStr) * 1e9).toString();
            } else {
              // Token → SOL (assume 6 decimals for most SPL tokens)
              fromMint = this.customSwapTokenMint;
              toMint = "So11111111111111111111111111111111111111112";
              amountLamports = Math.round(parseFloat(amtStr) * 1e6).toString();
            }
            this.log(
              `Executing custom swap: ${amtStr} ${
                this.customSwapDirection === 1
                  ? "SOL"
                  : this.customSwapTokenSymbol
              }...`,
              "info"
            );
            await this.executeSolanaSwap(amountLamports, fromMint, toMint);
            this.customSwapTokenMint = null;
            this.customSwapTokenSymbol = null;
            this.customSwapDirection = null;
            return;
          }
          if (this.awaitingPromptInput) return;

          // Profile registration input handling
          if (
            this.awaitingInput &&
            this.inputType &&
            this.inputType.startsWith("profile_")
          ) {
            await this.handleProfileRegistrationInput(command.trim());
            return;
          }

          // At the top of executeCommand, before command parsing:
          if (this.awaitingDMRecipient) {
            this.tempDMRecipient = command.trim();
            this.awaitingDMRecipient = false;
            this.awaitingDMMessage = true;
            this.logHtml(
              '<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' +
                this.tempDMRecipient +
                "</span>",
              "info"
            );
            this.log("Enter your message:", "info");
            return;
          }
          if (this.awaitingDMMessage) {
            const message = command.trim();
            const recipient = this.tempDMRecipient;
            this.awaitingDMMessage = false;
            this.tempDMRecipient = "";
            if (!recipient || !message) {
              this.log("Recipient and message required.", "error");
              return;
            }
            this.logHtml(
              '<span style="color:#99ccff">Message:</span> <span style="color:#fff">' +
                message +
                "</span>",
              "info"
            );
            await this.sendDirectMessage(recipient, message);
            this.log("✅ Email sent!", "success");
            return;
          }

          this.logCommand(command);
          // Hide faucet info box after first command
          try {
            const infoBox = document.getElementById("faucetInfoBox");
            if (infoBox && infoBox.style.display !== "none") {
              infoBox.style.display = "none";
            }
          } catch (e) {}

          // Parse command early so it can be used in AI mode check
          const args = command.trim().split(/\s+/);
          const cmd = args[0].toLowerCase();

          // Debug logging

          if (cmd === "email" && args[1] === "clearkey") {
            this.e2eePrivateKey = null;
            this.log("E2EE private key cleared from memory.", "success");
            return;
          }

          // --- Handle awaiting input states before command parsing ---

          // Handle wallet choice (yes/no for creating Omega Wallet)
          if (this.awaitingWalletChoice) {
            this.awaitingWalletChoice = false;
            if (cmd === "yes") {
              this.log(
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                "output"
              );
              this.log("", "info");
              this.log("    🎉 GENERATING YOUR Ω OMEGA WALLET...", "info");
              this.log("", "info");
              const wallet = this.ethers.Wallet.createRandom();
              this.storedPrivateKey = wallet.privateKey;
              this.log("    ✅ WALLET SUCCESSFULLY CREATED!", "success");
              this.log("", "info");
              this.log("    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "output");
              this.log("    📋 YOUR WALLET CREDENTIALS", "info");
              this.log("    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "output");
              this.log("", "info");
              this.logHtml(
                `🏛️ Address: <span class="copyable" onclick="navigator.clipboard.writeText('${wallet.address}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${wallet.address}</span>`,
                "output"
              );
              this.logHtml(
                `🔑 Private Key: <span class="copyable" onclick="navigator.clipboard.writeText('${wallet.privateKey}').then(() => window.terminal.log('✅ Private key copied!', 'success'))">${wallet.privateKey}</span>`,
                "output"
              );
              this.log("", "info");
              this.log("    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "output");
              this.log("", "info");
              this.log("    ⚠️  CRITICAL: SAVE THESE DETAILS NOW!", "error");
              this.log(
                "    🔒 Store your private key in a secure password manager",
                "error"
              );
              this.log(
                "    ⛔ Never share your private key with anyone",
                "error"
              );
              this.log("", "info");
              this.log("    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "output");
              this.log("", "info");
              this.log("    💰 ACTIVATING WELCOME BONUS...", "info");
              this.log(
                "    🎁 Requesting 0.1 OMEGA tokens from faucet...",
                "info"
              );

              // Fund the wallet via relayer
              try {
                const response = await fetch(`${RELAYER_URL}/fund`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    address: wallet.address,
                    amount: "0.1",
                  }),
                });
                const data = await response.json();
                if (data.success) {
                  this.log("", "info");
                  this.log(
                    "    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                    "output"
                  );
                  this.log("    🎉 WELCOME BONUS ACTIVATED!", "success");
                  this.log(
                    "    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                    "output"
                  );
                  this.log("", "info");
                  this.log(
                    `    ✅ 0.1 OMEGA tokens deposited to your wallet!`,
                    "success"
                  );
                  this.log(`    📜 Transaction Hash: ${data.txHash}`, "info");
                  this.log("", "info");
                  this.log(
                    "    🚀 YOUR OMEGA TERMINAL IS NOW READY!",
                    "success"
                  );
                  this.log("", "info");
                  this.log("    ⚡ Try These Commands:", "info");
                  this.log(
                    '       • "balance" → Check your 0.1 OMEGA balance',
                    "output"
                  );
                  this.log(
                    '       • "mine" → Start mining more OMEGA tokens',
                    "output"
                  );
                  this.log(
                    '       • "faucet" → Claim additional tokens (24h cooldown)',
                    "output"
                  );
                  this.log(
                    '       • "chart BTC" → View live crypto charts',
                    "output"
                  );
                  this.log('       • "help" → Explore all features', "output");
                  this.log("", "info");
                  this.log("    🎯 Happy trading & earning!", "success");
                  this.log("", "info");
                  this.log(
                    "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
                    "output"
                  );
                  this.log("", "info");

                  // Set up the wallet for use
                  const OMEGA_RPC_URL =
                    "https://0x4e454228.rpc.aurora-cloud.dev";
                  this.provider = new this.ethers.providers.JsonRpcProvider(
                    OMEGA_RPC_URL
                  );
                  this.signer = new this.ethers.Wallet(
                    wallet.privateKey,
                    this.provider
                  );
                  this.updateConnectionStatus("CONNECTED (Omega Wallet)");
                } else {
                  this.log(
                    "❌ Funding failed: " + (data.error || "Unknown error"),
                    "error"
                  );
                  this.log(
                    "💡 You can still use this wallet by funding it manually",
                    "info"
                  );
                }
              } catch (err) {
                this.log("❌ Funding request failed: " + err.message, "error");
                this.log(
                  "💡 You can still use this wallet by funding it manually",
                  "info"
                );
              }
            } else if (cmd === "no") {
              this.log("Wallet creation cancelled.", "info");
              this.log(
                "💡 Please install MetaMask to connect a browser wallet",
                "info"
              );
            } else {
              this.log(
                '❌ Invalid response. Please type "yes" or "no"',
                "error"
              );
              this.awaitingWalletChoice = true;
            }
            return;
          }

          if (this.awaitingMixerDirectInput && args.length === 2) {
            this.awaitingMixerDirectInput = false;
            const privateKeyInput = args[0];
            const amountStr = args[1];
            try {
              const mixerABI = [
                "function deposit(bytes32 commitment) external payable",
              ];
              // Always use a JsonRpcProvider for direct private key flows
              const OMEGA_RPC_URL = "https://0x4e454228.rpc.aurora-cloud.dev";
              const provider = new this.ethers.providers.JsonRpcProvider(
                OMEGA_RPC_URL
              );
              const privateKey = privateKeyInput.startsWith("0x")
                ? privateKeyInput
                : "0x" + privateKeyInput;
              const wallet = new this.ethers.Wallet(privateKey, provider);
              // Debug: print wallet address
              this.log(`Using wallet address: ${wallet.address}`, "info");
              // Debug: print provider network
              const network = await provider.getNetwork();
              this.log(
                `Provider network: ${network.name} (chainId: ${network.chainId})`,
                "info"
              );
              // Debug: print wallet balance
              const balance = await wallet.getBalance();
              this.log(
                `Wallet balance: ${this.ethers.utils.formatEther(
                  balance
                )} OMEGA`,
                "info"
              );
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const depositAmount = this.ethers.utils.parseEther(amountStr);
              const array = window.crypto.getRandomValues(new Uint8Array(32));
              const secret = Array.from(array)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
              const commitment = this.ethers.utils.keccak256("0x" + secret);
              this.logHtml(
                `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`,
                "info"
              );
              this.log(`2. Commitment: ${commitment}`, "info");
              this.log(`3. Deposit amount: ${amountStr} OMEGA`, "info");
              this.log("4. Creating wallet and calling contract...", "info");
              const tx = await mixerContract.deposit(commitment, {
                value: depositAmount,
              });
              this.log(
                `✅ Deposit transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              try {
                const receipt = await tx.wait();
                this.log(
                  `✅ Deposit confirmed! Block: ${receipt.blockNumber}`,
                  "success"
                );
                this.log(
                  "Your funds are now in the mixer. Use your secret to withdraw later.",
                  "info"
                );
              } catch (err) {
                this.log(
                  "⚠️ Transaction was submitted but confirmation could not be detected in time.",
                  "warning"
                );
                this.log(
                  "You can check the status manually on the block explorer:",
                  "info"
                );
                this.logHtml(
                  `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                  "info"
                );
              }
            } catch (error) {
              this.log(`❌ Deposit failed: ${error.message}`, "error");
              this.log(
                "Make sure you have enough OMEGA and a valid private key.",
                "info"
              );
            }
            return;
          }
          if (this.awaitingMixerDirectAmount && args.length === 1) {
            this.awaitingMixerDirectAmount = false;
            const amountStr = args[0];
            try {
              // Mixer contract ABI (updated for new contract)
              const mixerABI = [
                "function deposit(bytes32 commitment) external payable",
              ];
              const privateKey = this.storedPrivateKey.startsWith("0x")
                ? this.storedPrivateKey
                : "0x" + this.storedPrivateKey;
              const wallet = new this.ethers.Wallet(privateKey, this.provider);
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const depositAmount = this.ethers.utils.parseEther(amountStr);
              // Generate secret and commitment
              const array = window.crypto.getRandomValues(new Uint8Array(32));
              const secret = Array.from(array)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
              const commitment = this.ethers.utils.keccak256("0x" + secret);
              this.logHtml(
                `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`,
                "info"
              );
              this.log(`2. Commitment: ${commitment}`, "info");
              this.log(`3. Deposit amount: ${amountStr} OMEGA`, "info");
              this.log("4. Creating wallet and calling contract...", "info");
              const tx = await mixerContract.deposit(commitment, {
                value: depositAmount,
              });
              this.log(
                `✅ Deposit transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              try {
                const receipt = await tx.wait();
                this.log(
                  `✅ Deposit confirmed! Block: ${receipt.blockNumber}`,
                  "success"
                );
                this.log(
                  "Your funds are now in the mixer. Use your secret to withdraw later.",
                  "info"
                );
              } catch (err) {
                this.log(
                  "⚠️ Transaction was submitted but confirmation could not be detected in time.",
                  "warning"
                );
                this.log(
                  "You can check the status manually on the block explorer:",
                  "info"
                );
                this.logHtml(
                  `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                  "info"
                );
              }
              // Clear stored private key
              this.storedPrivateKey = null;
            } catch (error) {
              this.log(`❌ Deposit failed: ${error.message}`, "error");
              this.log(
                "Make sure you have enough OMEGA and a valid private key.",
                "info"
              );
              this.storedPrivateKey = null;
            }
            return;
          }
          if (
            this.awaitingPrivateKey &&
            this.awaitingMixerWithdrawDirect &&
            args.length === 1
          ) {
            // Withdraw-direct: received private key
            this.awaitingPrivateKey = false;
            this.awaitingMixerWithdrawDirect = false;
            this.storedPrivateKey = args[0];
            this.log(
              "Now enter your secret and withdrawal address separated by a space:",
              "info"
            );
            this.awaitingMixerWithdrawDirectParams = true;
            return;
          }
          if (this.awaitingMixerWithdrawDirectParams && args.length === 2) {
            // Withdraw-direct: received secret and address
            this.awaitingMixerWithdrawDirectParams = false;
            try {
              this.log("=== Omega Mixer Withdraw (Direct) ===", "info");
              this.log("Withdrawing funds directly from contract...", "info");
              // Validate secret
              let secretHex = args[0];
              if (!secretHex.startsWith("0x")) secretHex = "0x" + secretHex;
              if (secretHex.length !== 66) {
                // 2 for '0x' + 64 hex chars
                this.log(
                  "❌ Secret must be 32 bytes (64 hex characters).",
                  "error"
                );
                this.storedPrivateKey = null;
                return;
              }
              // Create wallet from private key (stored from previous step)
              const privateKey = this.storedPrivateKey.startsWith("0x")
                ? this.storedPrivateKey
                : "0x" + this.storedPrivateKey;
              const wallet = new this.ethers.Wallet(privateKey, this.provider);
              // Mixer contract ABI
              const mixerABI = [
                "function withdraw(bytes32 secret, address to) external",
              ];
              const mixerContract = new this.ethers.Contract(
                "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                mixerABI,
                wallet
              );
              const tx = await mixerContract.withdraw(secretHex, args[1]);
              this.log(
                `✅ Withdrawal transaction submitted! Hash: ${tx.hash}`,
                "success"
              );
              this.log("Waiting for confirmation...", "info");
              const receipt = await tx.wait();
              this.log(
                `✅ Withdrawal confirmed! Block: ${receipt.blockNumber}`,
                "success"
              );
              this.log(`✅ Funds withdrawn to: ${args[1]}`, "success");
              // Clear stored private key
              this.storedPrivateKey = null;
            } catch (error) {
              this.log(`❌ Withdrawal failed: ${error.message}`, "error");
              this.log(
                "Make sure you have a valid private key and the secret is correct.",
                "info"
              );
              this.storedPrivateKey = null;
            }
            return;
          }

          // Handle custom swap input
          if (this.awaitingCustomSwap && args.length === 2) {
            const amount = args[0];
            const toMint = args[1];
            await this.handleCustomSwapInput(amount, toMint);
            return;
          }

          // AI Mode: If active and command is not recognized, send to AI API
          console.log(
            "Checking AI mode. isAIModeOn:",
            this.isAIModeOn,
            "cmd:",
            cmd,
            "executingAICommands:",
            this.executingAICommands
          );
          if (this.isAIModeOn && !this.executingAICommands) {
            // List of known commands - execute these directly even in AI mode
            const knownCommands = [
              // Core system commands
              "help",
              "clear",
              "cls",
              "?",
              "connect",
              "disconnect",
              "balance",
              "status",
              "stats",
              "themes",
              "theme",
              "tab",
              "stop",
              "info",
              "test",

              // Wallet & connection
              "faucet",
              "send",
              "yes",
              "no",
              "gen-wallet",

              // Mining & rewards
              "mine",
              "claim",
              "fund",
              "sudo",

              // Network & development
              "network",
              "forceadd",
              "rpccheck",
              "stress",
              "stopstress",
              "stressstats",

              // Name services
              "ens",
              "fns",

              // FAIR blockchain
              "fair",

              // Privacy & security
              "mixer",

              // Token & asset creation
              "create",
              "mint",

              // Trading systems
              "solana",
              "eclipse",
              "near",
              "hyperliquid",
              "perp",
              "perps",

              // Analytics & data
              "dexscreener",
              "ds",
              "geckoterminal",
              "cg",
              "stock",
              "alphakey",
              "alpha",
              "defillama",
              "llama",

              // Prediction markets
              "polymarket",
              "pm",
              "poly",
              "kalshi",

              // NFTs & marketplaces
              "nft",
              "opensea",
              "magiceden",
              "me",

              // Social & communication
              "farcaster",
              "email",
              "dm",
              "inbox",
              "messages",
              "chat",

              // Gaming & entertainment
              "games",
              "arcade",
              "flappy",
              "omega-io",
              "mystery-box",
              "rickroll",
              "fortune",
              "matrix",
              "hack",
              "disco",

              // Profile & social
              "ambassador",
              "profile",
              "profile_username",
              "profile_display_name",
              "profile_bio",
              "profile_location",
              "profile_twitter",
              "profile_discord",
              "profile_email",
              "profile_confirmation",

              // Trading interfaces
              "pgt",
              "pgt-demo",
              "terminal",

              // Rome network
              "rome",

              // Shade protocol
              "shade",

              // UI & system
              "gui",
              "ai",

              // URLs & navigation
              "url",
              "urls",
              "airdrop",

              // Theme management
              "ios",
              "chatgpt",
              "discord",
              "aol",
              "windows95",
              "limewire",
              "off",
              "normal",
              "default",
              "apple",

              // Configuration
              "list",
              "set",
              "remove",
              "delete",
              "show",
              "set-api-key",
              "set-key",
              "set-private-key",

              // Market categories
              "market",
              "active",
              "trending",
              "recent",
              "breaking",
              "new",
              "earnings",
              "geopolitics",
              "culture",
              "world",
              "economy",
              "trump",
              "elections",
              "tech",
              "crypto",
              "politics",
              "sports",

              // Legacy/aliases
              "modern",
              "token",
            ];

            // Only send to AI if it's NOT a known command and is direct user input
            console.log(
              "AI mode check - Known command?",
              knownCommands.includes(cmd),
              "Direct user input?",
              !arguments[1] || arguments[1] !== true
            );
            if (
              !knownCommands.includes(cmd) &&
              (!arguments[1] || arguments[1] !== true)
            ) {
              this.logHtml(
                `<span style='color:#99ccff'>🤖 Processing</span>`,
                "info"
              );
              const url = "https://ai.omeganetwork.co/chat";
              const evm = this.userAddress || null;
              const solana = this.solanaAddress || null;

              try {
                const res = await fetch(url, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    question: command,
                    evm,
                    solana,
                    chatHistory: this.chatHistory, // Send history for context
                    ...(this.aiProvider && this.aiProvider !== "off"
                      ? { provider: this.aiProvider }
                      : {}),
                  }),
                });
                const data = await res.json();
                if (data && data.data) {
                  const d = data.data;
                  // Track AI reply in chat history
                  if (d.additionalInfoRequired) {
                    this.chatHistory.push({
                      type: "ai",
                      message: d.additionalInfo,
                    });
                  }
                  if (d.additionalInfoRequired) {
                    this.log(d.additionalInfo, "info");
                  }
                  if (Array.isArray(d.commands) && d.commands.length > 0) {
                    // Execute each command in the array individually to avoid plugin conflicts
                    console.log("AI returned commands array:", d.commands);
                    this.chatHistory.push({
                      type: "command",
                      command: d.commands,
                    });

                    try {
                      // Set flag to prevent recursive AI calls
                      this.executingAICommands = true;

                      for (let i = 0; i < d.commands.length; i++) {
                        const cmd = d.commands[i];
                        console.log(
                          `Executing AI command ${i + 1}/${
                            d.commands.length
                          }: "${cmd}"`
                        );
                        if (typeof cmd === "string") {
                          await this.executeCommand(cmd, true);
                        } else {
                          console.warn("Skipping non-string command:", cmd);
                        }
                      }
                      console.log(
                        "AI command execution completed successfully"
                      );
                    } catch (error) {
                      console.error("Error executing AI commands:", error);
                      console.error("Error stack:", error.stack);
                      this.log(
                        `AI command execution failed: ${error.message}`,
                        "error"
                      );
                    } finally {
                      // Always reset the flag when done
                      this.executingAICommands = false;
                    }
                  } else if (!d.additionalInfoRequired) {
                    this.log("Can't perform this action", "error");
                  }
                } else {
                  this.log("AI agent error: Invalid response.", "error");
                }
              } catch (err) {
                this.log("AI agent error: " + err.message, "error");
              }
              return;
            }
          }

          // --- End awaiting input checks ---

          // --- Handle command parsing ---
          switch (cmd) {
            case "connect":
              // Use multi-network connector
              if (window.OmegaCommands && window.OmegaCommands.Wallet) {
                await OmegaCommands.Wallet.connect(this);
              } else {
                await this.connectWallet();
              }
              break;
            case "disconnect":
              this.disconnectWallet();
              break;
            case "balance":
              await this.showBalance();
              break;
            case "theme":
            case "themes":
              this.setTheme(args[1]);
              break;
            case "color":
            case "palette":
              if (window.OmegaCommands && window.OmegaCommands.Color) {
                window.OmegaCommands.Color.color(this, args.slice(1));
              } else {
                this.log(
                  "❌ Color palette system not loaded. Please refresh.",
                  "error"
                );
              }
              break;
            case "mine":
              this.mine();
              break;
            case "faucet":
              if (args[1] === "status") {
                await this.showFaucetStatus();
              } else {
                this.faucetClaim();
              }
              break;
            case "status":
              this.showStatus();
              break;
            case "stats":
              this.showStats();
              break;
            case "send":
              this.sendOmega(command);
              break;
            case "clear":
            case "cls":
              this.clearTerminal();
              break;
            case "help":
            case "?":
              this.showHelp();
              break;
            case "pgt":
              await this.handlePGTCommand(args);
              break;

            case "chart":
              const chartSymbol = args[1];
              if (!chartSymbol) {
                this.log("╔═══════════════════════════════════════╗", "info");
                this.log("║          LIVE CHART VIEWER            ║", "info");
                this.log("╚═══════════════════════════════════════╝", "info");
                this.log("", "info");
                this.log("Usage: chart <symbol>", "info");
                this.log("", "info");
                this.log("Examples:", "info");
                this.log("  chart BTC    - Bitcoin chart", "info");
                this.log("  chart ETH    - Ethereum chart", "info");
                this.log("  chart SOL    - Solana chart", "info");
                this.log("  chart MATIC  - Polygon chart", "info");
                this.log("", "info");
                this.log("💡 Chart will appear in the right panel", "info");
              } else {
                // Play chart viewer sound effect
                if (
                  window.OmegaSoundEffects &&
                  window.OmegaSoundEffects.isSoundEnabled()
                ) {
                  window.OmegaSoundEffects.playChartViewerSound();
                }

                if (
                  window.FuturisticDashboard &&
                  window.FuturisticDashboard.showChart
                ) {
                  window.FuturisticDashboard.showChart(chartSymbol);
                } else {
                  this.log("❌ Chart viewer not available", "error");
                  this.log("💡 Please refresh the page", "info");
                }
              }
              break;
            case "network":
              await this.checkNetwork();
              break;
            case "forceadd":
              await this.forceAddNetwork();
              break;
            case "rpccheck":
              await this.checkRpcChainId();
              break;
            case "rickroll":
              this.rickroll();
              break;
            case "fortune":
              this.fortune();
              break;
            case "matrix":
              this.matrix();
              break;
            case "hack":
              this.hack();
              break;
            case "disco":
              this.disco();
              break;
            case "sudo":
              this.sudoMine();
              break;
            case "fund":
              this.fundMiningWallet(args[1]);
              break;
            case "stress":
              this.startStressTest();
              break;
            case "stopstress":
              this.stopStressTest();
              break;
            case "stressstats":
              this.showStressStats();
              break;
            case "mixer":
              if (args[1] === "-help") {
                this.log("=== Omega Mixer Help ===", "info");
                this.log(
                  "The Omega Mixer allows you to privately send OMEGA tokens by breaking the on-chain link between sender and receiver.",
                  "info"
                );
                this.log("How it works:", "info");
                this.log(
                  '1. Use "mixer deposit" to generate a secret and commitment, then manually call the contract.',
                  "info"
                );
                this.log(
                  '2. Use "mixer deposit-execute" to generate secret and call contract via MetaMask.',
                  "info"
                );
                this.log(
                  '3. Use "mixer deposit-direct" to generate secret and call contract directly (requires private key).',
                  "info"
                );
                this.log(
                  "4. Wait for the mixing round to complete (more users = more privacy).",
                  "info"
                );
                this.log(
                  '5. Use "mixer withdraw" to prepare your withdrawal. Enter your secret and the new address you want to receive funds at.',
                  "info"
                );
                this.log(
                  "6. In MetaMask (or via a relayer), call the withdraw function on the mixer contract with your secret and new address.",
                  "info"
                );
                this.log(
                  "7. For maximum privacy, use a relayer to submit the withdrawal transaction.",
                  "info"
                );
                this.log(
                  "NEVER share your secret. Anyone with the secret can withdraw your funds!",
                  "warning"
                );
                this.log(
                  "WARNING: Using deposit-direct requires entering your private key. Use at your own risk!",
                  "warning"
                );
              } else if (args[1] === "deposit") {
                // Generate secret and commitment
                const array = window.crypto.getRandomValues(new Uint8Array(32));
                const secret = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                const commitment = this.ethers.utils.keccak256("0x" + secret);
                this.log("=== Omega Mixer Deposit ===", "info");
                this.logHtml(
                  `1. Save this secret for withdrawal: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`,
                  "info"
                );
                this.log(`2. Commitment (for deposit): ${commitment}`, "info");
                this.log(
                  `3. In MetaMask, interact with the mixer contract:`,
                  "info"
                );
                this.logHtml(
                  `   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>`,
                  "info"
                );
                this.log(
                  `   IMPORTANT: Do NOT send a plain transaction to this address!`,
                  "warning"
                );
                this.log(`   Instead, call the deposit function:`, "info");
                this.log(`   - Go to the contract in MetaMask`, "info");
                this.log(`   - Click "Write Contract"`, "info");
                this.log(`   - Find the "deposit" function`, "info");
                this.log(`   - Enter commitment: ${commitment}`, "info");
                this.log(`   - Set value to your desired OMEGA amount`, "info");
                this.log(`   - Submit the transaction`, "info");
                this.log(
                  "4. After mixing, use your secret to withdraw to a new address.",
                  "info"
                );
              } else if (args[1] === "deposit-execute") {
                // Generate secret and commitment, then prompt for amount
                const array = window.crypto.getRandomValues(new Uint8Array(32));
                const secret = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                const commitment = this.ethers.utils.keccak256("0x" + secret);
                this.storedMixerSecret = secret;
                this.storedMixerCommitment = commitment;
                this.awaitingMixerExecuteAmount = true;
                this.log("=== Omega Mixer Deposit (Auto-Execute) ===", "info");
                this.logHtml(
                  `1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`,
                  "info"
                );
                this.log(`2. Commitment: ${commitment}`, "info");
                this.log(
                  "3. Enter deposit amount in OMEGA (e.g. 0.1):",
                  "info"
                );
                return;
              }
              // Add handler for awaitingMixerExecuteAmount
              if (this.awaitingMixerExecuteAmount && args.length === 1) {
                this.awaitingMixerExecuteAmount = false;
                const amountStr = args[0];
                try {
                  const mixerABI = [
                    "function deposit(bytes32 commitment) external payable",
                  ];
                  const mixerContract = new this.ethers.Contract(
                    "0xc57824b37a7fc769871075103c4dd807bfb3fd3e",
                    mixerABI,
                    this.provider.getSigner()
                  );
                  const depositAmount = this.ethers.utils.parseEther(amountStr);
                  const commitment = this.storedMixerCommitment;
                  const tx = await mixerContract.deposit(commitment, {
                    value: depositAmount,
                  });
                  this.log(
                    `✅ Deposit transaction submitted! Hash: ${tx.hash}`,
                    "success"
                  );
                  this.log("Waiting for confirmation...", "info");
                  try {
                    const receipt = await tx.wait();
                    this.log(
                      `✅ Deposit confirmed! Block: ${receipt.blockNumber}`,
                      "success"
                    );
                    this.log(
                      "Your funds are now in the mixer. Use your secret to withdraw later.",
                      "info"
                    );
                  } catch (err) {
                    this.log(
                      "⚠️ Transaction was submitted but confirmation could not be detected in time.",
                      "warning"
                    );
                    this.log(
                      "You can check the status manually on the block explorer:",
                      "info"
                    );
                    this.logHtml(
                      `<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`,
                      "info"
                    );
                  }
                  // Clear stored secret/commitment
                  this.storedMixerSecret = null;
                  this.storedMixerCommitment = null;
                } catch (error) {
                  this.log(`❌ Deposit failed: ${error.message}`, "error");
                  this.log(
                    "Make sure you have enough OMEGA in your wallet.",
                    "info"
                  );
                  this.storedMixerSecret = null;
                  this.storedMixerCommitment = null;
                }
                return;
              } else if (args[1] === "deposit-direct") {
                this.log("=== Omega Mixer Deposit (Direct) ===", "warning");
                this.log(
                  "WARNING: This will require your private key. Use at your own risk!",
                  "warning"
                );
                this.log(
                  "Enter your private key and deposit amount separated by a space (e.g. <privatekey> 0.1):",
                  "info"
                );
                this.awaitingMixerDirectInput = true;
                return;
              } else if (args[1] === "withdraw") {
                this.log("=== Omega Mixer Withdraw ===", "info");
                this.log(
                  "Enter your secret (hex) and withdrawal address separated by a space:",
                  "info"
                );
                this.awaitingMixerWithdraw = true;
              } else if (this.awaitingMixerWithdraw && args.length === 3) {
                // args[1] = secret, args[2] = to_address
                this.awaitingMixerWithdraw = false;
                this.log("=== Omega Mixer Withdraw ===", "info");
                this.log(
                  "In MetaMask (or via relayer), call the withdraw function on the mixer contract:",
                  "info"
                );
                this.logHtml(
                  "   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>",
                  "info"
                );
                this.log(
                  "   Function: withdraw(bytes32 secret, address to)",
                  "info"
                );
                this.log(`   Secret: ${args[1]}`, "info");
                this.log(`   To: ${args[2]}`, "info");
                this.log(
                  "You can use a relayer to submit this transaction for extra privacy.",
                  "info"
                );
              } else if (args[1] === "withdraw-direct") {
                this.log("=== Omega Mixer Withdraw (Direct) ===", "warning");
                this.log(
                  "WARNING: This will require your private key. Use at your own risk!",
                  "warning"
                );
                this.log("Enter your private key (without 0x prefix):", "info");
                this.awaitingPrivateKey = true;
                this.awaitingMixerWithdrawDirect = true;
              } else {
                this.log(
                  "Usage: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help",
                  "info"
                );
              }
              break;
            case "claim":
              await this.claim();
              break;
            case "stop":
              this.stopAll();
              break;
            case "tab":
              const newId = this.tabs.length;
              this.tabs.push({
                id: newId,
                name: `Terminal ${newId + 1}`,
                history: [],
                output: [],
              });
              this.activeTab = newId;
              this.renderTabs();
              this.clearTerminalContent();
              return;
            case "ens":
              if (!args[1]) {
                this.log(
                  "Usage: ens register <name> | ens resolve <name>",
                  "info"
                );
                break;
              }
              if (args[1] === "register" && args[2]) {
                if (!this.signer) {
                  this.log(
                    "Please connect your wallet first using: connect",
                    "error"
                  );
                  break;
                }
                const name = args[2];
                this.log(`Registering ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract(this.signer);
                  const tx = await ens.register(name);
                  this.log(
                    `✅ Registration transaction sent: ${tx.hash}`,
                    "success"
                  );
                  this.log("Waiting for confirmation...", "info");
                  await tx.wait();
                  this.log(`✅ Name registered: ${name}`, "success");
                } catch (err) {
                  this.log(`❌ Registration failed: ${err.message}`, "error");
                }
                break;
              } else if (args[1] === "resolve" && args[2]) {
                const name = args[2];
                this.log(`Resolving ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract();
                  const address = await ens.resolve(name);
                  if (
                    address &&
                    address !== "0x0000000000000000000000000000000000000000"
                  ) {
                    this.logHtml(
                      `✅ <b>${name}</b> resolves to <span class="copyable" onclick="navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${address}</span>`,
                      "success"
                    );
                  } else {
                    this.log(`❌ Name not found: ${name}`, "error");
                  }
                } catch (err) {
                  this.log(`❌ Resolve failed: ${err.message}`, "error");
                }
                break;
              } else if (args[1] === "search" && args[2]) {
                const name = args[2];
                this.log(`Searching for ENS name: ${name}...`, "info");
                try {
                  const ens = this.getENSContract();
                  const address = await ens.resolve(name);
                  if (
                    address &&
                    address !== "0x0000000000000000000000000000000000000000"
                  ) {
                    this.logHtml(
                      `✅ <b>${name}</b> is owned by <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))\">${address}</span>`,
                      "success"
                    );
                  } else {
                    this.log(`❌ Name not found: ${name}`, "error");
                  }
                } catch (err) {
                  this.log(`❌ ENS search failed: ${err.message}`, "error");
                }
                break;
              } else {
                this.log(
                  "Usage: ens register <name> | ens resolve <name>",
                  "info"
                );
              }
              break;
            case "dm":
              if (!args[1]) {
                this.log("Usage: dm <recipient> <message>", "info");
                break;
              }
              if (args.length < 3) {
                this.log("Usage: dm <recipient> <message>", "info");
                break;
              }
              const recipient = args[1];
              const dmMessage = args.slice(2).join(" ");
              await this.sendDirectMessage(recipient, dmMessage);
              break;
            case "inbox":
            case "messages":
              if (args[1] === "all") {
                await this.showInbox(true); // Show all messages
              } else {
                await this.showInbox(false); // Show limited messages
              }
              break;
            case "email":
              this.awaitingDMRecipient = true;
              this.awaitingDMMessage = false;
              this.tempDMRecipient = "";
              this.log("Enter recipient (address or ENS):", "info");
              break;
            case "dexscreener":
              await this.handleDexScreenerCommand(args);
              break;
            case "geckoterminal":
              await this.handleGeckoTerminalCommand(args);
              break;
            case "stock":
              await this.handleStockCommand(args);
              break;
            case "alphakey":
              await this.handleAlphaKeyCommand(args);
              break;
            case "ds":
              await this.handleDexScreenerAlias(args);
              break;
            case "cg":
              await this.handleGeckoTerminalAlias(args);
              break;
            case "alpha":
              await this.handleAlphaAlias(args);
              break;
            case "create":
              await this.handleCreateCommand(args);
              break;
            case "url":
            case "urls":
              this.logHtml("Helpful URLs:", "info");
              this.logHtml(
                'Gitbook: <a href="https://omega-6.gitbook.io/omega" target="_blank" style="color:#fff;">https://omega-6.gitbook.io/omega</a>',
                "info"
              );
              this.logHtml(
                'Block Explorer: <a href="https://0x4e454228.explorer.aurora-cloud.dev/" target="_blank" style="color:#fff;">https://0x4e454228.explorer.aurora-cloud.dev/</a>',
                "info"
              );
              this.logHtml(
                'Website: <a href="https://omeganetwork.co" target="_blank" style="color:#fff;">omeganetwork.co</a>',
                "info"
              );
              break;
            case "airdrop":
              this.airdrop();
              break;
            case "solana":
              if (args[1] === "help") {
                this.log("=== Solana/Jupiter Commands ===", "info");
                this.log("solana connect - Connect Phantom wallet", "output");
                this.log(
                  "solana search <query> - Search for Solana tokens",
                  "output"
                );
                this.log(
                  "solana quote <amount> <fromMint> <toMint> - Get swap quote",
                  "output"
                );
                this.log(
                  "solana swap - Open interactive swap interface",
                  "output"
                );
                this.log(
                  "solana swap <amount> <fromMint> <toMint> - Execute swap",
                  "output"
                );
                this.log("", "output");
                this.log("Examples:", "output");
                this.log("solana search bonk", "output");
                this.log(
                  "solana quote 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112",
                  "output"
                );
                this.log("solana swap", "output");
                this.log(
                  "solana swap 1000000 DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 So11111111111111111111111111111111111111112",
                  "output"
                );
                return;
              }
              if (args[1] === "connect") {
                if (window.solana && window.solana.isPhantom) {
                  try {
                    const resp = await window.solana.connect();
                    const address = resp.publicKey.toString();
                    this.solanaAddress = address;
                    // Fetch SOL balance using direct fetch to Helius
                    try {
                      const body = {
                        jsonrpc: "2.0",
                        id: 1,
                        method: "getBalance",
                        params: [address],
                      };
                      const res = await fetch(
                        "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082",
                        {
                          method: "POST",
                          headers: { "Content-Type": "application/json" },
                          body: JSON.stringify(body),
                        }
                      );
                      const data = await res.json();
                      let sol = "N/A";
                      if (
                        data &&
                        data.result &&
                        typeof data.result.value === "number"
                      ) {
                        sol = data.result.value / 1e9;
                      }
                      this.logHtml(
                        `<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#99ff99'>Balance:</span> <b>${sol} SOL</b>`,
                        "success"
                      );
                    } catch (err) {
                      this.logHtml(
                        `<span style='color:#33bbff'>Phantom Wallet Connected:</span> <span style='color:#fff'>${address}</span> <button onclick=\"navigator.clipboard.writeText('${address}')\">Copy</button><br><span style='color:#ff3333'>Failed to fetch balance</span>`,
                        "success"
                      );
                    }
                  } catch (e) {
                    this.log("User rejected the connection request.", "error");
                  }
                } else {
                  this.logHtml(
                    "<span style='color:#ff3333'>Phantom wallet not detected. <a href='https://phantom.app/download' target='_blank' style='color:#33bbff'>Install Phantom</a></span>",
                    "error"
                  );
                }
                return;
              }
              if (args[1] === "search" && args[2]) {
                const query = args.slice(2).join(" ");
                this.log(`Searching Solana tokens for: ${query}`, "info");
                try {
                  const res = await fetch(
                    `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                      query
                    )}`
                  );
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    data.forEach((token, idx) => {
                      // Card-like top section: logo | name (symbol) | mint | price
                      let cardTop = `<div style='display:flex;align-items:center;justify-content:space-between;gap:14px;margin-bottom:4px;'>`;
                      // Left: logo, name, symbol, mint, price, volume, holders
                      cardTop += `<div style='display:flex;align-items:center;gap:14px;'>`;
                      if (token.logoURI || token.icon) {
                        const logo = token.logoURI || token.icon;
                        cardTop += `<img src='${logo}' alt='icon' style='width:40px;height:40px;border-radius:50%;background:#fff;padding:2px;'>`;
                      }
                      cardTop += `<div><span style='font-size:1.2em;font-weight:bold;'>${
                        token.name || ""
                      }</span> <span style='color:#99ccff;'>(${
                        token.symbol || ""
                      })</span><br>`;
                      cardTop += `Mint: <span class='copyable' onclick=\"navigator.clipboard.writeText('${
                        token.address || token.id
                      }')\">${token.address || token.id}</span><br>`;
                      if (token.usdPrice !== undefined)
                        cardTop += `Price: <b>$${Number(
                          token.usdPrice
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 8,
                        })}</b><br>`;
                      if (
                        token.volume24h !== undefined ||
                        token.stats24h?.buyVolume !== undefined ||
                        token.stats24h?.sellVolume !== undefined
                      ) {
                        let vol = token.volume24h;
                        if (vol === undefined && token.stats24h) {
                          const buy = Number(token.stats24h.buyVolume || 0);
                          const sell = Number(token.stats24h.sellVolume || 0);
                          vol = buy + sell;
                        }
                        if (vol !== undefined)
                          cardTop += `24h Volume: <b>$${Number(
                            vol
                          ).toLocaleString(undefined, {
                            maximumFractionDigits: 2,
                          })}</b><br>`;
                      }
                      if (token.holderCount !== undefined)
                        cardTop += `Holders: <b>${Number(
                          token.holderCount
                        ).toLocaleString()}</b><br>`;
                      cardTop += `</div></div>`;
                      // Middle: audit and CEXes
                      cardTop += `<div style='min-width:200px;text-align:center;'>`;
                      if (token.audit) {
                        cardTop += `<div style='margin-bottom:4px;'><b>Audit</b><br>`;
                        if (token.audit.mintAuthorityDisabled !== undefined)
                          cardTop += `Mint Authority: <b>${
                            token.audit.mintAuthorityDisabled
                              ? "Disabled"
                              : "Enabled"
                          }</b><br>`;
                        if (token.audit.freezeAuthorityDisabled !== undefined)
                          cardTop += `Freeze Authority: <b>${
                            token.audit.freezeAuthorityDisabled
                              ? "Disabled"
                              : "Enabled"
                          }</b><br>`;
                        if (token.audit.topHoldersPercentage !== undefined)
                          cardTop += `Top Holders: <b>${Number(
                            token.audit.topHoldersPercentage
                          ).toLocaleString(undefined, {
                            maximumFractionDigits: 2,
                          })}%</b><br>`;
                        cardTop += `</div>`;
                      }
                      if (
                        token.cexes &&
                        Array.isArray(token.cexes) &&
                        token.cexes.length > 0
                      ) {
                        cardTop += `<div><b>CEXs</b><br><span style='font-size:0.95em;'>${token.cexes.join(
                          ", "
                        )}</span></div>`;
                      }
                      cardTop += `</div>`;
                      // Right: mcap and fdv
                      cardTop += `<div style='text-align:right;min-width:180px;'>`;
                      if (token.mcap !== undefined)
                        cardTop += `Market Cap:<br><b>$${Number(
                          token.mcap
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 2,
                        })}</b><br>`;
                      if (token.fdv !== undefined)
                        cardTop += `FDV:<br><b>$${Number(
                          token.fdv
                        ).toLocaleString(undefined, {
                          maximumFractionDigits: 2,
                        })}</b><br>`;
                      cardTop += `</div>`;
                      cardTop += `</div>`;

                      // Add swap buttons section
                      let swapSection = `<div style='margin-top:8px;padding:8px;background:rgba(0,255,0,0.1);border:1px solid #00ff00;border-radius:4px;'>`;
                      swapSection += `<div style='font-weight:bold;margin-bottom:4px;'>Quick Swap Actions:</div>`;
                      swapSection += `<div style='display:flex;gap:8px;flex-wrap:wrap;'>`;

                      // Swap from SOL to this token (use 1 SOL = 1,000,000,000 lamports)
                      swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000000', 'So11111111111111111111111111111111111111112', '${
                        token.address || token.id
                      }')\" style='background:#00ff00;color:#000;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1 SOL → ${
                        token.symbol || "Token"
                      }</button>`;

                      // Swap from this token to SOL (use 1,000,000 units; adjust decimals as needed)
                      swapSection += `<button onclick=\"window.terminal.executeSolanaSwap('1000000', '${
                        token.address || token.id
                      }', 'So11111111111111111111111111111111111111112')\" style='background:#ff6600;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Swap 1M ${
                        token.symbol || "Token"
                      } → SOL</button>`;

                      // Custom swap button
                      swapSection += `<button onclick=\"window.terminal.promptCustomSwap('${
                        token.address || token.id
                      }', '${
                        token.symbol || "Token"
                      }')\" style='background:#0066ff;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px;'>Custom Swap</button>`;

                      swapSection += `</div></div>`;

                      this.logHtml(cardTop + swapSection, "output");
                      this.logHtml("<hr>", "output");
                    });
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">No results found.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana token search failed: " + e.message, "error");
                }
                return;
              }
              if (args[1] === "quote" && args.length === 5) {
                const amount = args[2];
                const fromMint = args[3];
                const toMint = args[4];
                this.log(
                  `Getting quote for ${amount} (mint: ${fromMint}) to (mint: ${toMint})`,
                  "info"
                );
                try {
                  const res = await fetch(
                    `${RELAYER_URL}/jupiter/quote?amount=${encodeURIComponent(
                      amount
                    )}&fromMint=${encodeURIComponent(
                      fromMint
                    )}&toMint=${encodeURIComponent(toMint)}`
                  );
                  const data = await res.json();
                  if (data && data.outAmount) {
                    this.logHtml(
                      `<b>Quote:</b> ${amount} → ${data.outAmount} (route: ${
                        data.marketInfos?.map((m) => m.label).join(", ") ||
                        "N/A"
                      })`,
                      "success"
                    );
                  } else if (data && data.error) {
                    this.logHtml(
                      `<span style='color:#ff3333'>${data.error}</span>`,
                      "error"
                    );
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">No quote found.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana quote failed: " + e.message, "error");
                }
                return;
              }
              if (args[1] === "swap" && args.length === 2) {
                this.showSolanaSwapInterface();
                return;
              }
              if (args[1] === "swap" && args.length === 5) {
                if (!this.solanaAddress) {
                  this.log(
                    "Please connect your Phantom wallet first using: solana connect",
                    "error"
                  );
                  return;
                }
                const amount = args[2];
                const fromMint = args[3];
                const toMint = args[4];
                this.log(
                  `Swapping ${amount} (mint: ${fromMint}) to (mint: ${toMint})`,
                  "info"
                );
                try {
                  const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      inputMint: fromMint,
                      outputMint: toMint,
                      amount,
                      userPublicKey: this.solanaAddress,
                    }),
                  });
                  const data = await res.json();
                  this.log(
                    "DEBUG: Full relayer response: " + JSON.stringify(data),
                    "info"
                  );
                  if (data && data.transaction) {
                    // Ask Phantom to sign and send the transaction
                    if (window.solana && window.solana.isPhantom) {
                      try {
                        const txBuf = Uint8Array.from(
                          atob(data.transaction),
                          (c) => c.charCodeAt(0)
                        );
                        this.log(
                          "DEBUG: About to send transaction to Phantom",
                          "info"
                        );
                        this.log(
                          "DEBUG: User address: " + this.solanaAddress,
                          "info"
                        );
                        this.log(
                          "DEBUG: Transaction buffer (base64): " +
                            data.transaction,
                          "info"
                        );
                        this.log(
                          "DEBUG: Transaction buffer (Uint8Array length): " +
                            txBuf.length,
                          "info"
                        );
                        let signed;
                        if (
                          window.solanaWeb3 &&
                          window.solanaWeb3.VersionedTransaction
                        ) {
                          try {
                            const transaction =
                              window.solanaWeb3.VersionedTransaction.deserialize(
                                txBuf
                              );
                            this.log(
                              "DEBUG: Deserialized VersionedTransaction:",
                              "info"
                            );
                            this.log(JSON.stringify(transaction), "info");
                            signed = await window.solana.signAndSendTransaction(
                              transaction
                            );
                            this.log(
                              "DEBUG: Used VersionedTransaction object for signing.",
                              "info"
                            );
                          } catch (err) {
                            this.log(
                              "DEBUG: Failed to deserialize VersionedTransaction, falling back to buffer. Error: " +
                                (err && err.message ? err.message : err),
                              "warning"
                            );
                            signed = await window.solana.signAndSendTransaction(
                              { message: txBuf }
                            );
                            this.log("DEBUG: Used buffer for signing.", "info");
                          }
                        } else {
                          signed = await window.solana.signAndSendTransaction({
                            message: txBuf,
                          });
                          this.log(
                            "DEBUG: Used buffer for signing (no VersionedTransaction available).",
                            "info"
                          );
                        }
                        this.log(
                          "DEBUG: Phantom signAndSendTransaction result: " +
                            JSON.stringify(signed),
                          "info"
                        );
                        this.logHtml(
                          `<b>Swap transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signed.signature}')">${signed.signature}</span>`,
                          "success"
                        );
                      } catch (e) {
                        this.log(
                          "DEBUG: Error from Phantom signAndSendTransaction: " +
                            (e && e.message ? e.message : e),
                          "error"
                        );
                        this.log(
                          "User rejected or failed to sign the swap transaction.",
                          "error"
                        );
                      }
                    } else {
                      this.log(
                        "Phantom wallet not available for signing.",
                        "error"
                      );
                    }
                  } else if (data && data.error) {
                    this.logHtml(
                      `<span style='color:#ff3333'>${data.error}</span>`,
                      "error"
                    );
                  } else {
                    this.logHtml(
                      '<span style="color:#ff3333">Swap failed.</span>',
                      "error"
                    );
                  }
                } catch (e) {
                  this.log("Solana swap failed: " + e.message, "error");
                }
                return;
              }

              // Forward unknown Solana subcommands to the modular system
              if (
                window.OmegaCommands &&
                window.OmegaCommands.Solana &&
                window.OmegaCommands.Solana.solana
              ) {
                await window.OmegaCommands.Solana.solana(this, args);
              } else {
                this.log(
                  'Unknown solana command. Type "solana" for help.',
                  "error"
                );
              }
              return;

            case "near":
              this.log("Near Intents command detected!", "info");

              // near-tokens
              if (args[1] === "tokens") {
                this.log("Fetching Near Intents supported tokens...", "info");
                try {
                  const response = await fetch(
                    "https://1click.chaindefuser.com/v0/tokens"
                  );
                  if (!response.ok) {
                    this.log(
                      `Failed to fetch tokens: HTTP ${response.status}`,
                      "error"
                    );
                    return;
                  }

                  const tokens = await response.json();
                  let html = `<b>Near Intents Supported Tokens (${tokens.length} total):</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Blockchain</th><th>Asset ID</th><th>Price (USD)</th><th>Decimals</th></tr>`;

                  tokens.forEach((token) => {
                    html += `<tr><td>${token.symbol}</td><td>${token.blockchain}</td><td>${token.assetId}</td><td>$${token.price}</td><td>${token.decimals}</td></tr>`;
                  });

                  html += `</table>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Near Intents tokens: " + e.message,
                    "error"
                  );
                }
                return;
              }

              // near-quote
              if (args[1] === "quote") {
                if (args.length < 6) {
                  this.log(
                    "Usage: near quote <originAsset> <destinationAsset> <amount> <slippageBps> <recipient>",
                    "info"
                  );
                  this.log(
                    'Example: near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-recipient-address"',
                    "info"
                  );
                  return;
                }

                const originAsset = args[2];
                const destinationAsset = args[3];
                const amount = args[4];
                const slippageBps = parseInt(args[5]);
                const recipient = args[6];

                this.log(
                  `Getting Near Intents quote for ${amount} ${originAsset} → ${destinationAsset}...`,
                  "info"
                );

                try {
                  const quotePayload = {
                    dry: true, // Dry run for quote
                    swapType: "EXACT_INPUT",
                    slippageTolerance: slippageBps,
                    originAsset,
                    depositType: "ORIGIN_CHAIN",
                    destinationAsset,
                    amount,
                    refundTo: recipient, // Use recipient as refund address for now
                    refundType: "ORIGIN_CHAIN",
                    recipient,
                    recipientType: "DESTINATION_CHAIN",
                    deadline: new Date(
                      Date.now() + 24 * 60 * 60 * 1000
                    ).toISOString(), // 24 hours from now
                    quoteWaitingTimeMs: 3000,
                  };

                  const response = await fetch(
                    "https://1click.chaindefuser.com/v0/quote",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify(quotePayload),
                    }
                  );

                  if (!response.ok) {
                    const errorText = await response.text();
                    this.log(`Quote failed: HTTP ${response.status}`, "error");
                    this.log(`Error details: ${errorText}`, "error");
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Near Intents Quote:</b><br>`;
                  html += `Input: <b>${data.quote.amountInFormatted} ${originAsset}</b> ($${data.quote.amountInUsd})<br>`;
                  html += `Output: <b>${data.quote.amountOutFormatted} ${destinationAsset}</b> ($${data.quote.amountOutUsd})<br>`;
                  html += `Min Output: <b>${data.quote.minAmountOutFormatted} ${destinationAsset}</b><br>`;
                  html += `Slippage: <b>${slippageBps / 100}%</b><br>`;
                  html += `Time Estimate: <b>${data.quote.timeEstimate} seconds</b><br>`;
                  html += `Deposit Address: <b>${data.quote.depositAddress}</b><br>`;
                  html += `Deadline: <b>${new Date(
                    data.quote.deadline
                  ).toLocaleString()}</b><br>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Quote failed: ${e.message}`, "error");
                }
                return;
              }

              // near-swap
              if (args[1] === "swap") {
                // Show interactive swap interface
                this.showNearSwapInterface();
                return;
              }

              // near-status
              if (args[1] === "status") {
                let depositAddress;
                if (args[2]) {
                  depositAddress = args[2];
                } else if (window.nearSwapInfo) {
                  depositAddress = window.nearSwapInfo.depositAddress;
                } else {
                  this.log("Usage: near status <depositAddress>", "info");
                  this.log(
                    "Or use: near status (if you have a recent swap)",
                    "info"
                  );
                  return;
                }

                this.log(
                  `Checking Near Intents swap status for: ${depositAddress}`,
                  "info"
                );

                try {
                  const response = await fetch(
                    `https://1click.chaindefuser.com/v0/status?depositAddress=${depositAddress}`
                  );

                  if (!response.ok) {
                    if (response.status === 404) {
                      this.log(
                        "Swap not found. Make sure the deposit address is correct.",
                        "warning"
                      );
                    } else {
                      const errorText = await response.text();
                      this.log(
                        `Status check failed: HTTP ${response.status}`,
                        "error"
                      );
                      this.log(`Error details: ${errorText}`, "error");
                    }
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Near Intents Swap Status:</b><br>`;
                  html += `Status: <b>${data.status}</b><br>`;
                  html += `Updated: <b>${new Date(
                    data.updatedAt
                  ).toLocaleString()}</b><br>`;

                  if (data.swapDetails) {
                    html += `<br><b>Swap Details:</b><br>`;
                    html += `Input: <b>${data.swapDetails.amountInFormatted} ${data.quoteResponse.quoteRequest.originAsset}</b><br>`;
                    html += `Output: <b>${data.swapDetails.amountOutFormatted} ${data.quoteResponse.quoteRequest.destinationAsset}</b><br>`;
                    html += `Slippage: <b>${
                      data.swapDetails.slippage / 100
                    }%</b><br>`;

                    if (
                      data.swapDetails.originChainTxHashes &&
                      data.swapDetails.originChainTxHashes.length > 0
                    ) {
                      html += `<br><b>Origin Chain Transactions:</b><br>`;
                      data.swapDetails.originChainTxHashes.forEach((tx) => {
                        html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                      });
                    }

                    if (
                      data.swapDetails.destinationChainTxHashes &&
                      data.swapDetails.destinationChainTxHashes.length > 0
                    ) {
                      html += `<br><b>Destination Chain Transactions:</b><br>`;
                      data.swapDetails.destinationChainTxHashes.forEach(
                        (tx) => {
                          html += `<a href="${tx.explorerUrl}" target="_blank">${tx.hash}</a><br>`;
                        }
                      );
                    }

                    if (data.swapDetails.refundedAmount) {
                      html += `<br><b>Refunded Amount:</b> ${data.swapDetails.refundedAmountFormatted}<br>`;
                    }
                  }

                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Status check failed: ${e.message}`, "error");
                }
                return;
              }

              // Wallet commands (added by NEAR wallet fix)
              if (args[1] === "connect" || args[1] === "wallet") {
                if (this.connectNearWalletFixed) {
                  await this.connectNearWalletFixed();
                } else {
                  this.log(
                    "❌ NEAR wallet functionality not loaded. Please refresh the page.",
                    "error"
                  );
                }
                return;
              }

              if (args[1] === "disconnect") {
                if (this.disconnectNearWallet) {
                  this.disconnectNearWallet();
                } else {
                  this.log("❌ NEAR wallet functionality not loaded.", "error");
                }
                return;
              }

              if (args[1] === "balance" && (!args[2] || args[2] === "wallet")) {
                if (this.showNearWalletBalance) {
                  await this.showNearWalletBalance();
                } else {
                  this.log("❌ NEAR wallet functionality not loaded.", "error");
                }
                return;
              }

              if (args[1] === "debug") {
                if (this.debugNearWalletDetection) {
                  this.debugNearWalletDetection();
                } else {
                  this.log(
                    "❌ NEAR wallet debug functionality not loaded.",
                    "error"
                  );
                }
                return;
              }

              // near help
              if (args[1] === "help") {
                let html = `<b>NEAR Protocol Commands:</b><br>`;
                html += `<br><b>💼 Wallet Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>near connect</b> — Connect NEAR wallet</li>`;
                html += `<li><b>near wallet</b> — Same as near connect</li>`;
                html += `<li><b>near disconnect</b> — Disconnect NEAR wallet</li>`;
                html += `<li><b>near balance</b> — Check NEAR wallet balance</li>`;
                html += `<li><b>near debug</b> — Debug wallet detection</li>`;
                html += `</ul>`;
                html += `<br><b>🔄 Trading Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>near tokens</b> — List all supported tokens for cross-chain swaps</li>`;
                html += `<li><b>near quote &lt;originAsset&gt; &lt;destinationAsset&gt; &lt;amount&gt; &lt;slippageBps&gt; &lt;recipient&gt;</b> — Get a quote for a cross-chain swap</li>`;
                html += `<li><b>near swap</b> — Show interactive cross-chain swap interface</li>`;
                html += `<li><b>near status [depositAddress]</b> — Check swap status (uses recent swap if no address provided)</li>`;
                html += `<li><b>near help</b> — Show this help</li>`;
                html += `</ul>`;
                html += `<br><b>Examples:</b><br>`;
                html += `<code>near connect</code><br>`;
                html += `<code>near tokens</code><br>`;
                html += `<code>near quote "nep141:wrap.near" "nep141:sol-5ce3bf3a31af18be40ba30f721101b4341690186.omft.near" "1000000000000000000000000" 100 "your-address"</code><br>`;
                html += `<code>near swap</code><br>`;
                html += `<code>near status 0x123abc456def789</code><br>`;
                this.logHtml(html, "output");
                return;
              }

              // Default Near help
              this.log(
                "NEAR commands: connect | wallet | tokens | quote | swap | status | help",
                "info"
              );
              return;

            case "eclipse":
              this.log("Eclipse command detected!", "info");
              if (args[1] === "-help" || args[1] === "help") {
                let html = `<b>Eclipse (SVM) Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>eclipse gen-wallet</b> — Generate a new Eclipse (SVM) wallet</li>`;
                html += `<li><b>eclipse wallet-info</b> — Show current Eclipse wallet details</li>`;
                html += `<li><b>eclipse balance</b> — Check Eclipse wallet balance</li>`;
                html += `<li><b>eclipse swap &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> — Execute a swap on Solar DEX</li>`;
                html += `<li><b>eclipse quote &lt;inputMint&gt; &lt;outputMint&gt; &lt;amount&gt; &lt;slippageBps&gt;</b> — Get swap quote without executing</li>`;
                html += `<li><b>eclipse tokens</b> — List available tokens on Eclipse</li>`;
                html += `<li><b>eclipse price &lt;mint&gt;</b> — Get token price from Solar DEX</li>`;
                html += `</ul>`;
                html += `<br><b>Examples:</b><br>`;
                html += `<code>eclipse swap So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                html += `<code>eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100</code><br>`;
                html += `<code>eclipse price CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze</code><br>`;
                html += `<br><b>Note:</b> Slippage is in basis points (100 = 1%, 50 = 0.5%)<br>`;
                this.logHtml(html, "output");
                return;
              }

              // eclipse gen-wallet
              if (args[1] === "gen-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot generate Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                try {
                  // Generate Solana keypair
                  const keypair = window.solanaWeb3.Keypair.generate();
                  const publicKey = keypair.publicKey.toString();
                  const privateKey = Array.from(keypair.secretKey)
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey,
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                  html += `<br>💡 Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to generate Eclipse wallet: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // eclipse wallet-info
              if (args[1] === "wallet-info") {
                if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                  let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                  html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Eclipse wallet generated in this session. Use: eclipse gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse balance
              if (args[1] === "balance") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                try {
                  const connection = new window.solanaWeb3.Connection(
                    window.eclipseWallet.rpcUrl,
                    "confirmed"
                  );
                  const publicKey = new window.solanaWeb3.PublicKey(
                    window.eclipseWallet.publicKey
                  );
                  const balance = await connection.getBalance(publicKey);
                  const balanceInSol =
                    balance / window.solanaWeb3.LAMPORTS_PER_SOL;

                  this.logHtml(`<b>Eclipse Wallet Balance:</b>`, "output");
                  this.logHtml(
                    `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`,
                    "output"
                  );
                  this.logHtml(
                    `<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`,
                    "output"
                  );
                  this.logHtml(`<b>Network:</b> Eclipse (SVM)`, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Eclipse wallet balance: " + e.message,
                    "error"
                  );
                }
                return;
              }

              // eclipse import-wallet
              if (args[1] === "import-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot import Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                if (args.length < 3) {
                  this.log(
                    "Usage: eclipse import-wallet <private_key>",
                    "info"
                  );
                  this.log(
                    "Example: eclipse import-wallet 1234567890abcdef...",
                    "info"
                  );
                  this.log(
                    "Note: Private key should be a 64-character hex string",
                    "info"
                  );
                  return;
                }

                try {
                  const privateKeyInput = args[2];
                  let keypair;

                  // Try to detect format and handle accordingly
                  this.log(
                    `Debug: Private key length: ${privateKeyInput.length}`,
                    "info"
                  );

                  if (/^[0-9a-fA-F]{64}$/.test(privateKeyInput)) {
                    // Hex format (64 characters)
                    const privateKeyBytes = new Uint8Array(
                      privateKeyInput
                        .match(/.{1,2}/g)
                        .map((byte) => parseInt(byte, 16))
                    );
                    keypair =
                      window.solanaWeb3.Keypair.fromSecretKey(privateKeyBytes);
                    this.log("✅ Detected hex format private key", "success");
                  } else if (
                    /^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(privateKeyInput)
                  ) {
                    // Base58 format (80-88 characters) - standard Solana format
                    this.log(
                      "✅ Base58 pattern matched, attempting decode...",
                      "success"
                    );
                    try {
                      // Use our custom base58 decoder
                      this.log("Debug: Using custom base58 decoder", "info");
                      const privateKeyBytes = base58Decode(privateKeyInput);

                      // Handle different private key formats
                      if (privateKeyBytes.length === 32) {
                        // 32 bytes: Just the private key
                        this.log(
                          "Debug: Detected 32-byte private key format",
                          "info"
                        );
                        keypair =
                          window.solanaWeb3.Keypair.fromSecretKey(
                            privateKeyBytes
                          );
                      } else if (privateKeyBytes.length === 64) {
                        // 64 bytes: Private key + public key (keypair format)
                        this.log(
                          "Debug: Detected 64-byte keypair format, using full keypair data",
                          "info"
                        );
                        // Use the full 64-byte array directly - Solana expects this format
                        keypair =
                          window.solanaWeb3.Keypair.fromSecretKey(
                            privateKeyBytes
                          );
                      } else {
                        this.log(
                          `❌ Invalid private key length: ${privateKeyBytes.length} bytes (expected 32 or 64)`,
                          "error"
                        );
                        return;
                      }
                      this.log(
                        "✅ Detected base58 format private key",
                        "success"
                      );
                    } catch (e) {
                      this.log("❌ Invalid base58 private key format", "error");
                      this.log(
                        `Debug: base58 decode error: ${e.message}`,
                        "error"
                      );
                      return;
                    }
                  } else {
                    this.log("❌ Invalid private key format.", "error");
                    this.log(
                      `Debug: Hex pattern match: ${/^[0-9a-fA-F]{64}$/.test(
                        privateKeyInput
                      )}`,
                      "info"
                    );
                    this.log(
                      `Debug: Base58 pattern match: ${/^[1-9A-HJ-NP-Za-km-z]{80,88}$/.test(
                        privateKeyInput
                      )}`,
                      "info"
                    );
                    this.log("Supported formats:", "info");
                    this.log("- Hex: 64-character hex string", "info");
                    this.log(
                      "- Base58: 80-88 character base58 string (standard Solana format)",
                      "info"
                    );
                    this.log(
                      "Example hex: eclipse import-wallet 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                      "info"
                    );
                    this.log(
                      "Example base58: eclipse import-wallet 4dmKkXNHJm1RX4bqrLHBg4m5vMwSrERmyi6CgbdW54BL2ktHvH6zJpFGz7kq8r8WNz1E1LJHaFUztcJLdDFD5xUy",
                      "info"
                    );
                    return;
                  }
                  const publicKey = keypair.publicKey.toString();

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey: privateKeyInput, // Store the original input format
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>Eclipse (SVM) Wallet Imported Successfully!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Your private key is now stored in session memory!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<br>✅ Wallet imported and ready to use!<br>`;
                  html += `<br>💡 Use <b>eclipse balance</b> to check your funds.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to import Eclipse wallet: " + e.message,
                    "error"
                  );
                  this.log(
                    "Make sure your private key is correct and in hex format.",
                    "info"
                  );
                  return;
                }
              }

              // eclipse swap
              if (args[1] === "swap") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                // Show interactive swap interface
                this.showEclipseSwapInterface();
                return;
              }

              // eclipse quote
              if (args[1] === "quote") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                if (args.length < 5) {
                  this.log(
                    "Usage: eclipse quote <inputMint> <outputMint> <amount> <slippageBps>",
                    "info"
                  );
                  this.log(
                    "Example: eclipse quote So11111111111111111111111111111111111111112 CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze 0.1 100",
                    "info"
                  );
                  return;
                }

                const inputMint = args[2];
                const outputMint = args[3];
                const amount = parseFloat(args[4]);
                const slippageBps = parseInt(args[5]);

                this.log(
                  `Getting quote for ${amount} ${inputMint} → ${outputMint}...`,
                  "info"
                );

                try {
                  // Ensure we have the correct SOL mint address
                  const solMintAddress =
                    "So11111111111111111111111111111111111111112";
                  const actualInputMint =
                    inputMint === "11111111111111111111111111111111"
                      ? solMintAddress
                      : inputMint;

                  // Get compute unit price from Solar API
                  let computeUnitPrice = "auto";
                  try {
                    const feeResponse = await fetch(
                      "https://api.solarstudios.co/main/auto-fee"
                    );
                    if (feeResponse.ok) {
                      const feeData = await feeResponse.json();
                      computeUnitPrice = String(feeData.data.default.h); // Use high priority
                      this.log(
                        `Using compute unit price: ${computeUnitPrice}`,
                        "info"
                      );
                    }
                  } catch (e) {
                    this.log("Using default compute unit price", "info");
                  }

                  const quotePayload = {
                    inputMint: actualInputMint,
                    outputMint,
                    amount: amount * 1e9, // Convert to lamports
                    slippageBps,
                    version: "LEGACY",
                    wallet: window.eclipseWallet.keypair.publicKey.toString(),
                    computeUnitPriceMicroLamports: computeUnitPrice,
                    wrapSol:
                      actualInputMint ===
                      "So11111111111111111111111111111111111111112"
                        ? true
                        : false,
                  };

                  this.log(
                    `Quote payload: ${JSON.stringify(quotePayload)}`,
                    "info"
                  );

                  // Build query parameters for GET request
                  const queryParams = new URLSearchParams({
                    inputMint: actualInputMint,
                    outputMint: outputMint,
                    amount: (amount * 1e9).toString(),
                    slippageBps: slippageBps.toString(),
                    txVersion: "LEGACY",
                  });

                  const response = await fetch(
                    `https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`,
                    {
                      method: "GET",
                      headers: { "Content-Type": "application/json" },
                    }
                  );

                  if (!response.ok) {
                    const errorText = await response.text();
                    this.log(`Quote failed: HTTP ${response.status}`, "error");
                    this.log(`Error details: ${errorText}`, "error");
                    return;
                  }

                  const data = await response.json();
                  let html = `<b>Eclipse Swap Quote:</b><br>`;
                  html += `Input: <b>${amount} ${inputMint}</b><br>`;
                  html += `Output: <b>${(data.outAmount / 1e9).toFixed(
                    9
                  )} ${outputMint}</b><br>`;
                  html += `Price Impact: <b>${data.priceImpactPct}%</b><br>`;
                  html += `Minimum Output: <b>${(
                    data.otherAmountThreshold / 1e9
                  ).toFixed(9)} ${outputMint}</b><br>`;
                  html += `Slippage: <b>${slippageBps / 100}%</b><br>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Quote failed: ${e.message}`, "error");
                }
                return;
              }

              // eclipse tokens
              if (args[1] === "tokens") {
                this.log("Fetching Eclipse token lists...", "info");
                try {
                  // Fetch Solar tokens
                  this.log("Fetching Solar DEX tokens...", "info");
                  const solarResponse = await fetch(
                    "https://api.solarstudios.co/mint/list"
                  );
                  let solarTokens = [];
                  if (solarResponse.ok) {
                    const solarData = await solarResponse.json();
                    if (
                      solarData.success &&
                      solarData.data &&
                      solarData.data.mintList
                    ) {
                      solarTokens = solarData.data.mintList;
                    }
                  }

                  // Fetch Deserialize tokens
                  this.log("Fetching Deserialize tokens...", "info");
                  const deserializeResponse = await fetch(
                    "https://api.deserialize.xyz/tokenList"
                  );
                  let deserializeTokens = [];
                  if (deserializeResponse.ok) {
                    const deserializeData = await deserializeResponse.json();
                    if (
                      deserializeData.data &&
                      Array.isArray(deserializeData.data)
                    ) {
                      deserializeTokens = deserializeData.data;
                    }
                  }

                  // Merge tokens and remove duplicates
                  const allTokens = new Map();

                  // Add Solar tokens
                  solarTokens.forEach((token) => {
                    allTokens.set(token.address, {
                      address: token.address,
                      symbol: token.symbol,
                      name: token.name,
                      decimals: token.decimals,
                      source: "Solar",
                    });
                  });

                  // Add Deserialize tokens (will override if duplicate address)
                  deserializeTokens.forEach((token) => {
                    allTokens.set(token.address, {
                      address: token.address,
                      symbol: token.metadata?.symbol || "N/A",
                      name: token.metadata?.name || "N/A",
                      decimals: token.decimals,
                      source: allTokens.has(token.address)
                        ? "Both"
                        : "Deserialize",
                    });
                  });

                  const tokens = Array.from(allTokens.values());

                  let html = `<b>Eclipse Tokens (${tokens.length} total):</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;'><tr><th>Symbol</th><th>Name</th><th>Mint Address</th><th>Source</th><th>Solar DEX</th><th>Deserialize Agg</th></tr>`;

                  // Show all tokens
                  const displayTokens = tokens;

                  // Fetch Solar prices for all tokens
                  this.log("Fetching Solar DEX prices...", "info");
                  const mintAddresses = displayTokens
                    .map((token) => token.address)
                    .join(",");
                  const solarPriceResponse = await fetch(
                    `https://api.solarstudios.co/mint/price?mints=${mintAddresses}`
                  );
                  const solarPriceData = solarPriceResponse.ok
                    ? await solarPriceResponse.json()
                    : { data: {} };

                  // Fetch Deserialize prices for all tokens
                  this.log("Fetching Deserialize prices...", "info");
                  const deserializePrices = {};

                  // Fetch prices one by one for Deserialize (since it doesn't support batch)
                  for (const token of displayTokens) {
                    try {
                      const deserializeResponse = await fetch(
                        `https://api.deserialize.xyz/tokenPrice/${token.address}`
                      );
                      if (deserializeResponse.ok) {
                        const deserializeData =
                          await deserializeResponse.json();
                        deserializePrices[token.address] =
                          deserializeData.price;
                      }
                    } catch (e) {
                      // Continue if one fails
                    }
                  }

                  displayTokens.forEach((token) => {
                    const solarPrice = solarPriceData.data?.[token.address];
                    const deserializePrice = deserializePrices[token.address];

                    const solarPriceDisplay = solarPrice
                      ? `$${parseFloat(solarPrice).toFixed(6)}`
                      : "N/A";
                    const deserializePriceDisplay = deserializePrice
                      ? `$${parseFloat(deserializePrice).toFixed(6)}`
                      : "N/A";

                    // Color code the source
                    let sourceColor = "#ffffff";
                    if (token.source === "Solar") sourceColor = "#99ccff";
                    if (token.source === "Deserialize") sourceColor = "#ffcc99";
                    if (token.source === "Both") sourceColor = "#ccff99";

                    html += `<tr><td>${token.symbol || "N/A"}</td><td>${
                      token.name || "N/A"
                    }</td><td style='font-size:0.8em;'>${
                      token.address || "N/A"
                    }</td><td style='color:${sourceColor}'>${
                      token.source
                    }</td><td>${solarPriceDisplay}</td><td>${deserializePriceDisplay}</td></tr>`;
                  });

                  // No need for "more tokens" message since we're showing all

                  html += `</table>`;
                  this.logHtml(html, "output");
                } catch (e) {
                  this.log(`Failed to fetch tokens: ${e.message}`, "error");
                }
                return;
              }

              // eclipse price
              if (args[1] === "price" && args[2]) {
                const mint = args[2];
                this.log(`Fetching price for ${mint}...`, "info");
                try {
                  const response = await fetch(
                    `https://api.solarstudios.co/mint/price?mints=${mint}`
                  );
                  if (!response.ok) {
                    this.log("Failed to fetch price", "error");
                    return;
                  }

                  const data = await response.json();
                  const price = data.data?.[mint];

                  if (price) {
                    this.log(`✅ Price: $${price}`, "success");
                  } else {
                    this.log("❌ Price not found", "error");
                  }
                } catch (e) {
                  this.log(`Failed to fetch price: ${e.message}`, "error");
                }
                return;
              }

              // Default Eclipse help
              this.log(
                "Eclipse (SVM) commands: gen-wallet | import-wallet | wallet-info | balance | swap | quote | tokens | price | help",
                "info"
              );
              this.log(
                "Near Intents commands: near-tokens | near-quote | near-swap | near-status | help",
                "info"
              );
              this.log(
                "Solana Web3 available: " + (window.solanaWeb3 ? "Yes" : "No"),
                "info"
              );
              return;

            case "chat":
              // ChainGPT Web3 AI Chatbot commands
              console.log("[DEBUG] Chat command detected:", args[1]);
              console.log(
                "[DEBUG] ChainGPTChatCommands available:",
                !!window.ChainGPTChatCommands
              );
              console.log(
                "[DEBUG] ChainGPT chat function available:",
                !!(
                  window.ChainGPTChatCommands &&
                  window.ChainGPTChatCommands.chat
                )
              );

              if (
                window.ChainGPTChatCommands &&
                window.ChainGPTChatCommands.chat
              ) {
                console.log("[DEBUG] Routing to ChainGPT Chat commands");
                await window.ChainGPTChatCommands.chat(this, args.slice(1));
                return;
              } else {
                this.log(
                  "❌ ChainGPT Chat not loaded. Please refresh.",
                  "error"
                );
              }
              return;

            case "news":
              // Crypto News commands
              console.log("[DEBUG] News command detected:", args[1]);
              console.log(
                "[DEBUG] CryptoNewsCommands available:",
                !!window.CryptoNewsCommands
              );

              if (window.CryptoNewsCommands && window.CryptoNewsCommands.news) {
                console.log("[DEBUG] Routing to Crypto News commands");
                await window.CryptoNewsCommands.news(this, args.slice(1));
                return;
              } else {
                this.log("❌ Crypto News not loaded. Please refresh.", "error");
              }
              return;

            case "referral":
              // Omega Network Referral System
              console.log("[DEBUG] Referral command detected:", args[1]);
              console.log(
                "[DEBUG] OmegaCommands.Referral available:",
                !!window.OmegaCommands?.Referral
              );

              if (window.OmegaCommands && window.OmegaCommands.Referral) {
                console.log(
                  "[DEBUG] Routing to Omega Network Referral commands"
                );
                await window.OmegaCommands.Referral.referral(this, args);
              } else {
                console.log(
                  "[DEBUG] Omega Network Referral commands not found"
                );
                this.log(
                  "❌ Referral commands not loaded. Please refresh the page.",
                  "error"
                );
              }
              return;

            case "contract":
              // ChainGPT AI Smart Contract Creator
              console.log("[DEBUG] Contract command detected:", args[1]);
              console.log(
                "[DEBUG] ChainGPTSmartContractCommands available:",
                !!window.ChainGPTSmartContractCommands
              );
              console.log(
                "[DEBUG] ChainGPT contract function available:",
                !!(
                  window.ChainGPTSmartContractCommands &&
                  window.ChainGPTSmartContractCommands.contract
                )
              );

              if (
                window.ChainGPTSmartContractCommands &&
                window.ChainGPTSmartContractCommands.contract
              ) {
                console.log(
                  "[DEBUG] Routing to ChainGPT Smart Contract Creator commands"
                );
                await window.ChainGPTSmartContractCommands.contract(
                  this,
                  args.slice(1)
                );
              } else {
                console.log(
                  "[DEBUG] ChainGPT Smart Contract Creator commands not found"
                );
                this.log(
                  "❌ Smart Contract Creator commands not loaded. Please refresh the page.",
                  "error"
                );
              }
              return;

            case "auditor":
              // ChainGPT AI Smart Contract Auditor
              console.log("[DEBUG] Auditor command detected:", args[1]);
              console.log(
                "[DEBUG] ChainGPTSmartContractAuditorCommands available:",
                !!window.ChainGPTSmartContractAuditorCommands
              );
              console.log(
                "[DEBUG] ChainGPT auditor function available:",
                !!(
                  window.ChainGPTSmartContractAuditorCommands &&
                  window.ChainGPTSmartContractAuditorCommands.auditor
                )
              );

              if (
                window.ChainGPTSmartContractAuditorCommands &&
                window.ChainGPTSmartContractAuditorCommands.auditor
              ) {
                console.log(
                  "[DEBUG] Routing to ChainGPT Smart Contract Auditor commands"
                );
                await window.ChainGPTSmartContractAuditorCommands.auditor(
                  this,
                  args.slice(1)
                );
              } else {
                console.log(
                  "[DEBUG] ChainGPT Smart Contract Auditor commands not found"
                );
                this.log(
                  "❌ Smart Contract Auditor commands not loaded. Please refresh the page.",
                  "error"
                );
              }
              return;

            case "nft":
            case "opensea":
              // Check if it's a ChainGPT AI NFT command
              const nftSubcommand = args[1]?.toLowerCase();
              const chainGptCommands = [
                "init",
                "generate",
                "enhance",
                "mint",
                "models",
                "styles",
                "chains",
                "status",
                "test",
                "gallery",
                "help",
              ];
              console.log("[DEBUG] NFT command detected:", nftSubcommand);
              console.log(
                "[DEBUG] ChainGPTCommands available:",
                !!window.ChainGPTCommands
              );
              console.log(
                "[DEBUG] ChainGPT nft function available:",
                !!(window.ChainGPTCommands && window.ChainGPTCommands.nft)
              );

              if (
                chainGptCommands.includes(nftSubcommand) &&
                window.ChainGPTCommands &&
                window.ChainGPTCommands.nft
              ) {
                // ChainGPT AI NFT Generator commands
                console.log(
                  "[DEBUG] Routing to ChainGPT NFT commands:",
                  nftSubcommand
                );
                // Pass args without the 'nft' prefix since ChainGPT module expects subcommand as args[0]
                await window.ChainGPTCommands.nft(this, args.slice(1));
                return;
              } else if (
                nftSubcommand === "collection" ||
                nftSubcommand === "view" ||
                nftSubcommand === "list"
              ) {
                // NFT Minting commands
                if (window.handleNFTMintCommand) {
                  window.handleNFTMintCommand(args.slice(1));
                } else {
                  this.log(
                    "❌ NFT Minter not loaded. Please refresh.",
                    "error"
                  );
                }
              } else {
                // OpenSea trading commands
                if (typeof this.handleNFTCommand === "function") {
                  await this.handleNFTCommand(args);
                } else {
                  this.log(
                    "❌ Enhanced NFT functionality not loaded. Please refresh the page.",
                    "error"
                  );
                  this.log(
                    "💡 AI NFT: nft init | nft generate | nft enhance",
                    "info"
                  );
                  this.log(
                    "💡 Trading: nft setup | nft search | nft assets | nft buy | nft bid",
                    "info"
                  );
                  this.log(
                    "💡 ChainGPT Minting: nft mint <collection-id> | nft collection | nft view <#>",
                    "info"
                  );
                }
              }
              return;

            case "chatter":
              // Terminal Chatter Mode (Telegram-like chat)
              if (window.handleChatCommand) {
                window.handleChatCommand(args.slice(1));
              } else {
                this.log("💬 Terminal Chatter", "info");
                this.log("🚀 Telegram-like community chat", "info");
                this.log(
                  "💡 Commands: chat open | chat settings | chat help",
                  "info"
                );
              }
              return;

            case "pgt":
              // PGT Portfolio Tracking Integration
              if (window.handlePGTCommand) {
                window.handlePGTCommand(args.slice(1));
              } else {
                this.log("🎯 PGT Portfolio Tracking", "info");
                this.log(
                  "📊 Multi-chain wallet tracking and portfolio management",
                  "info"
                );
                this.log(
                  "💡 Commands: pgt track | pgt portfolio | pgt wallets | pgt help",
                  "info"
                );
                this.log(
                  '⚠️ Note: Use "pgt-demo" for local testing (CORS-free)',
                  "warning"
                );
              }
              return;

            case "pgt-demo":
              // PGT Demo Mode (CORS-free local testing)
              if (window.handlePGTDemoCommand) {
                window.handlePGTDemoCommand(args.slice(1));
              } else {
                this.log("🎮 PGT Demo Mode", "info");
                this.log("📊 CORS-free local testing for PGT commands", "info");
                this.log(
                  "💡 Commands: pgt-demo track | pgt-demo portfolio",
                  "info"
                );
              }
              return;

            case "terminal":
              // Simple Terminal Builder System
              if (
                window.simpleTerminalBuilder &&
                typeof window.handleSimpleTerminalCommand === "function"
              ) {
                window.handleSimpleTerminalCommand(args.slice(1));
              } else {
                this.log("🏗️ Simple Terminal Builder", "info");
                this.log("📝 Create custom terminals with custom URLs", "info");
                this.log(
                  "💡 Commands: terminal create | terminal list | terminal launch",
                  "info"
                );
                if (!window.simpleTerminalBuilder) {
                  this.log(
                    "❌ Terminal builder not loaded. Please refresh.",
                    "error"
                  );
                }
              }
              return;

            case "mint":
              // Shortcut for nft mint
              if (window.handleNFTMintCommand) {
                window.handleNFTMintCommand(["mint"]);
              } else {
                this.log("❌ NFT Minter not loaded. Please refresh.", "error");
              }
              return;

            case "omega":
              // Omega Network commands
              if (args.length < 2) {
                this.log("🏛️ OMEGA NETWORK COMMANDS", "info");
                this.log("═══════════════════════════", "info");
                this.log("", "info");
                this.log("📋 AVAILABLE COMMANDS:", "info");
                this.log(
                  "  omega mint       Mint NFT on Omega Network with UI",
                  "output"
                );
                this.log(
                  "  omega collection View your Omega Network NFT collection",
                  "output"
                );
                this.log("  omega help       Show this help message", "output");
                this.log("", "info");
                this.log("🎯 EXAMPLES:", "info");
                this.log(
                  "  omega mint       # Open Omega Network NFT minting UI",
                  "info"
                );
                this.log("  omega collection # View your minted NFTs", "info");
                this.log("", "info");
                this.log(
                  "💡 Omega Network is a Layer 1 blockchain for NFTs!",
                  "success"
                );
                return;
              }

              const omegaSubcommand = args[1]?.toLowerCase();

              switch (omegaSubcommand) {
                case "mint":
                  // Open Omega Network NFT minting UI
                  if (window.handleNFTMintCommand) {
                    window.handleNFTMintCommand(["mint"]);
                  } else {
                    this.log(
                      "❌ Omega NFT Minter not loaded. Please refresh.",
                      "error"
                    );
                  }
                  break;

                case "collection":
                case "list":
                  // Show Omega Network NFT collection
                  if (window.handleNFTMintCommand) {
                    window.handleNFTMintCommand(["collection"]);
                  } else {
                    this.log(
                      "❌ Omega NFT Minter not loaded. Please refresh.",
                      "error"
                    );
                  }
                  break;

                case "help":
                  this.log("🏛️ OMEGA NETWORK NFT HELP", "info");
                  this.log("═══════════════════════════", "info");
                  this.log("", "info");
                  this.log("📋 COMMANDS:", "info");
                  this.log(
                    "  omega mint       Mint NFT on Omega Network with UI",
                    "output"
                  );
                  this.log(
                    "  omega collection View your Omega Network NFT collection",
                    "output"
                  );
                  this.log("", "info");
                  this.log("🎯 EXAMPLES:", "info");
                  this.log("  omega mint       # Open NFT minting UI", "info");
                  this.log(
                    "  omega collection # View your minted NFTs",
                    "info"
                  );
                  this.log("", "info");
                  this.log(
                    "💡 Upload image, add metadata, and mint on Omega Network!",
                    "info"
                  );
                  break;

                default:
                  this.log(
                    `❌ Unknown Omega command: ${omegaSubcommand}`,
                    "error"
                  );
                  this.log('Type "omega help" for available commands', "info");
              }
              return;

            case "hyperliquid":
              if (args[1] === "-help" || args[1] === "help") {
                let html = `<b>Hyperliquid Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>hyperliquid perps</b> — List all perps with mark price and open interest</li>`;
                html += `<li><b>hyperliquid perp &lt;COIN&gt;</b> — Show detailed info for a single perp (mark price, OI, funding, leverage, recent trades)</li>`;
                html += `<li><b>hyperliquid funding &lt;COIN&gt;</b> — Show current and historical funding rates for a perp</li>`;
                html += `<li><b>hyperliquid positions &lt;ADDRESS&gt;</b> — Show all open perp positions for a given address</li>`;
                html += `<li><b>hyperliquid orderbook &lt;COIN&gt;</b> — Show top bids/asks for a perp</li>`;
                html += `<li><b>hyperliquid trades &lt;COIN&gt;</b> — Show recent trades for a perp</li>`;
                html += `<li><b>hyperliquid oi-cap</b> — Show perps at open interest cap</li>`;
                html += `</ul>`;
                this.logHtml(html, "output");
                return;
              }
              // 0. hyperliquid perps
              if (args[1] === "perps") {
                this.log("Fetching Hyperliquid perps...", "info");
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                  });
                  const data = await res.json();
                  if (
                    Array.isArray(data) &&
                    data.length === 2 &&
                    Array.isArray(data[0].universe) &&
                    Array.isArray(data[1])
                  ) {
                    const universe = data[0].universe;
                    const ctxs = data[1];
                    let html = `<b>Hyperliquid Perps</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Mark Price</th><th>Open Interest</th><th>24h Volume</th><th>Funding</th></tr>`;
                    for (let i = 0; i < universe.length; ++i) {
                      const meta = universe[i];
                      const ctx = ctxs[i];
                      html += `<tr><td><b>${meta.name}</b></td><td>${ctx.markPx}</td><td>${ctx.openInterest}</td><td>${ctx.dayNtlVlm}</td><td>${ctx.funding}</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log(
                      "Failed to parse Hyperliquid perps data.",
                      "error"
                    );
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch Hyperliquid perps: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 1. hyperliquid perp <COIN>
              if (args[1] === "perp" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid perp info for ${coin}...`,
                  "info"
                );
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                  });
                  const data = await res.json();
                  if (
                    Array.isArray(data) &&
                    data.length === 2 &&
                    Array.isArray(data[0].universe) &&
                    Array.isArray(data[1])
                  ) {
                    const universe = data[0].universe;
                    const ctxs = data[1];
                    const idx = universe.findIndex(
                      (x) => x.name.toUpperCase() === coin
                    );
                    if (idx === -1) {
                      this.log(`Perp ${coin} not found.`, "error");
                      return;
                    }
                    const meta = universe[idx];
                    const ctx = ctxs[idx];
                    let html = `<b>${coin} Perp</b><br>`;
                    html += `Mark Price: <b>${ctx.markPx}</b><br>`;
                    html += `Open Interest: <b>${ctx.openInterest}</b><br>`;
                    html += `Funding: <b>${ctx.funding}</b><br>`;
                    html += `Max Leverage: <b>${meta.maxLeverage}</b><br>`;
                    html += `Size Decimals: <b>${meta.szDecimals}</b><br>`;
                    html += `24h Volume: <b>${ctx.dayNtlVlm}</b><br>`;
                    html += `Prev Day Price: <b>${ctx.prevDayPx}</b><br>`;
                    html += `Premium: <b>${ctx.premium}</b><br>`;
                    html += `<hr>`;
                    // Recent trades
                    html += `<b>Recent Trades:</b><br>`;
                    const tradesRes = await fetch(
                      "https://api.hyperliquid.xyz/info",
                      {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ type: "recentTrades", coin }),
                      }
                    );
                    if (!tradesRes.ok) {
                      const text = await tradesRes.text();
                      this.log(
                        `Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`,
                        "error"
                      );
                      return;
                    }
                    const trades = await tradesRes.json();
                    if (Array.isArray(trades) && trades.length > 0) {
                      html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                      for (let i = 0; i < Math.min(trades.length, 10); ++i) {
                        const t = trades[i];
                        html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${
                          t.side
                        }</td><td>${new Date(
                          t.time
                        ).toLocaleTimeString()}</td></tr>`;
                      }
                      html += `</table>`;
                    } else {
                      html += "No recent trades.";
                    }
                    this.logHtml(html, "output");
                  } else {
                    this.log("Failed to parse Hyperliquid perp data.", "error");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch Hyperliquid perp info: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 2. hyperliquid funding <COIN>
              if (args[1] === "funding" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid funding rates for ${coin}...`,
                  "info"
                );
                try {
                  const now = Date.now();
                  const weekAgo = now - 7 * 24 * 60 * 60 * 1000;
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      type: "fundingHistory",
                      coin,
                      startTime: weekAgo,
                      endTime: now,
                    }),
                  });
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    let html = `<b>${coin} Funding Rates (last 7d):</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Time</th><th>Funding Rate</th><th>Premium</th></tr>`;
                    for (let i = 0; i < Math.min(data.length, 20); ++i) {
                      const f = data[i];
                      html += `<tr><td>${new Date(
                        f.time
                      ).toLocaleString()}</td><td>${f.fundingRate}</td><td>${
                        f.premium
                      }</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No funding history found.", "warning");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch funding history: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 3. hyperliquid positions <ADDRESS>
              if (args[1] === "positions" && args[2]) {
                const user = args[2];
                this.log(
                  `Fetching Hyperliquid perp positions for ${user}...`,
                  "info"
                );
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "clearinghouseState", user }),
                  });
                  const data = await res.json();
                  if (
                    data &&
                    Array.isArray(data.assetPositions) &&
                    data.assetPositions.length > 0
                  ) {
                    let html = `<b>Perp Positions for ${user}:</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Coin</th><th>Sz</th><th>Entry Px</th><th>Leverage</th><th>Unrealized PnL</th><th>ROE</th></tr>`;
                    for (const pos of data.assetPositions) {
                      const p = pos.position;
                      html += `<tr><td>${p.coin}</td><td>${p.szi}</td><td>${
                        p.entryPx
                      }</td><td>${p.leverage.value}x</td><td>${
                        p.unrealizedPnl
                      }</td><td>${(parseFloat(p.returnOnEquity) * 100).toFixed(
                        2
                      )}%</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No open perp positions found.", "warning");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch perp positions: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // 4. hyperliquid orderbook <COIN>
              if (args[1] === "orderbook" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(
                  `Fetching Hyperliquid orderbook for ${coin}...`,
                  "info"
                );
                try {
                  const metaRes = await fetch(
                    "https://api.hyperliquid.xyz/info",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({ type: "metaAndAssetCtxs" }),
                    }
                  );
                  const metaData = await metaRes.json();
                  if (
                    Array.isArray(metaData) &&
                    metaData.length === 2 &&
                    Array.isArray(metaData[0].universe)
                  ) {
                    const universe = metaData[0].universe;
                    const idx = universe.findIndex(
                      (x) => x.name.toUpperCase() === coin
                    );
                    if (idx === -1) {
                      this.log(`Perp ${coin} not found.`, "error");
                      return;
                    }
                    const orderbookRes = await fetch(
                      "https://api.hyperliquid.xyz/v1/orderbook",
                      {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ coin }),
                      }
                    );
                    const ob = await orderbookRes.json();
                    if (ob && ob.bids && ob.asks) {
                      let html = `<b>${coin} Orderbook</b><br>`;
                      html += `<table style='width:100%;font-size:0.95em;'><tr><th>Bid Px</th><th>Bid Sz</th><th>Ask Px</th><th>Ask Sz</th></tr>`;
                      for (
                        let i = 0;
                        i < Math.max(ob.bids.length, ob.asks.length, 10);
                        ++i
                      ) {
                        const bid = ob.bids[i] || ["", ""];
                        const ask = ob.asks[i] || ["", ""];
                        html += `<tr><td>${bid[0]}</td><td>${bid[1]}</td><td>${ask[0]}</td><td>${ask[1]}</td></tr>`;
                      }
                      html += `</table>`;
                      this.logHtml(html, "output");
                    } else {
                      this.log("No orderbook data found.", "warning");
                    }
                  } else {
                    this.log("Failed to fetch meta for orderbook.", "error");
                  }
                } catch (e) {
                  this.log("Failed to fetch orderbook: " + e.message, "error");
                }
                return;
              }
              // 5. hyperliquid trades <COIN>
              if (args[1] === "trades" && args[2]) {
                const coin = args[2].toUpperCase();
                this.log(`Fetching Hyperliquid trades for ${coin}...`, "info");
                try {
                  const tradesRes = await fetch(
                    "https://api.hyperliquid.xyz/info",
                    {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({ type: "recentTrades", coin }),
                    }
                  );
                  if (!tradesRes.ok) {
                    const text = await tradesRes.text();
                    this.log(
                      `Failed to fetch trades: HTTP ${tradesRes.status} - ${text}`,
                      "error"
                    );
                    return;
                  }
                  const trades = await tradesRes.json();
                  if (Array.isArray(trades) && trades.length > 0) {
                    let html = `<b>Recent Trades for ${coin}:</b><br>`;
                    html += `<table style='width:100%;font-size:0.95em;'><tr><th>Px</th><th>Sz</th><th>Side</th><th>Time</th></tr>`;
                    for (let i = 0; i < Math.min(trades.length, 20); ++i) {
                      const t = trades[i];
                      html += `<tr><td>${t.px}</td><td>${t.sz}</td><td>${
                        t.side
                      }</td><td>${new Date(
                        t.time
                      ).toLocaleTimeString()}</td></tr>`;
                    }
                    html += `</table>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("No recent trades found.", "warning");
                  }
                } catch (e) {
                  this.log("Failed to fetch trades: " + e.message, "error");
                }
                return;
              }
              // 6. hyperliquid oi-cap
              if (args[1] === "oi-cap") {
                this.log("Fetching perps at open interest cap...", "info");
                try {
                  const res = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "perpsAtOpenInterestCap" }),
                  });
                  const data = await res.json();
                  if (Array.isArray(data) && data.length > 0) {
                    this.logHtml(
                      `<b>Perps at Open Interest Cap:</b> ${data.join(", ")}`,
                      "output"
                    );
                  } else {
                    this.log("No perps at open interest cap.", "info");
                  }
                } catch (e) {
                  this.log(
                    "Failed to fetch perps at open interest cap: " + e.message,
                    "error"
                  );
                }
                return;
              }
              // hyperliquid gen-wallet
              if (args[1] === "gen-wallet") {
                const array = new Uint8Array(32);
                window.crypto.getRandomValues(array);
                const privHex = Array.from(array)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");
                let address = "";
                try {
                  if (window.ethers) {
                    const wallet = new window.ethers.Wallet("0x" + privHex);
                    address = wallet.address;
                  } else {
                    this.log(
                      "Ethers.js not loaded. Cannot generate address.",
                      "error"
                    );
                    return;
                  }
                } catch (e) {
                  this.log("Failed to generate wallet: " + e.message, "error");
                  return;
                }
                window.hyperliquidApiWallet = { privHex, address };
                let html = `<b>New Hyperliquid API Wallet Generated!</b><br>`;
                html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can trade on your behalf!</span><br>`;
                html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${address}')">${address}</span><br>`;
                html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privHex}')">${privHex}</span><br>`;
                html += `<button onclick="(() => { const blob = new Blob(['${privHex}'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'hyperliquid-api-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Private Key</button><br>`;
                html += `<br>Register this address as an API wallet in your Hyperliquid account.<br>`;
                this.logHtml(html, "output");
                return;
              }
              // hyperliquid wallet-info
              if (args[1] === "wallet-info") {
                if (
                  window.hyperliquidApiWallet &&
                  window.hyperliquidApiWallet.address
                ) {
                  let html = `<b>Current Hyperliquid API Wallet:</b><br>`;
                  html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.address}')">${window.hyperliquidApiWallet.address}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.hyperliquidApiWallet.privHex}')">${window.hyperliquidApiWallet.privHex}</span><br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Hyperliquid API wallet generated in this session. Use: hyperliquid gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse gen-wallet
              if (args[1] === "gen-wallet") {
                if (!window.solanaWeb3) {
                  this.log(
                    "Solana Web3 library not loaded. Cannot generate Eclipse wallet.",
                    "error"
                  );
                  return;
                }

                try {
                  // Generate Solana keypair
                  const keypair = window.solanaWeb3.Keypair.generate();
                  const publicKey = keypair.publicKey.toString();
                  const privateKey = Array.from(keypair.secretKey)
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");

                  // Store in session
                  window.eclipseWallet = {
                    publicKey,
                    privateKey,
                    keypair,
                    network: "Eclipse (SVM)",
                    rpcUrl: "https://mainnetbeta-rpc.eclipse.xyz",
                  };

                  let html = `<b>New Eclipse (SVM) Wallet Generated!</b><br>`;
                  html += `<span style='color:#ff3333'>SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${publicKey}')">${publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${privateKey}')">${privateKey}</span><br>`;
                  html += `<b>Network:</b> Eclipse (SVM)<br>`;
                  html += `<b>RPC URL:</b> https://mainnetbeta-rpc.eclipse.xyz<br>`;
                  html += `<button onclick="(() => { const blob = new Blob(['Public Key: ${publicKey}\\nPrivate Key: ${privateKey}\\nNetwork: Eclipse (SVM)\\nRPC URL: https://mainnetbeta-rpc.eclipse.xyz'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'eclipse-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); })()">Download Wallet Info</button><br>`;
                  html += `<br>💡 Use this wallet with Backpack, Phantom, or any Solana wallet that supports Eclipse network.<br>`;
                  this.logHtml(html, "output");
                  return;
                } catch (e) {
                  this.log(
                    "Failed to generate Eclipse wallet: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // eclipse wallet-info
              if (args[1] === "wallet-info") {
                if (window.eclipseWallet && window.eclipseWallet.publicKey) {
                  let html = `<b>Current Eclipse (SVM) Wallet:</b><br>`;
                  html += `<b>Public Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.privateKey}')">${window.eclipseWallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> ${window.eclipseWallet.network}<br>`;
                  html += `<b>RPC URL:</b> ${window.eclipseWallet.rpcUrl}<br>`;
                  this.logHtml(html, "output");
                } else {
                  this.log(
                    "No Eclipse wallet generated in this session. Use: eclipse gen-wallet",
                    "warning"
                  );
                }
                return;
              }

              // eclipse balance
              if (args[1] === "balance") {
                if (!window.eclipseWallet) {
                  this.log(
                    "No Eclipse wallet generated. Use: eclipse gen-wallet",
                    "warning"
                  );
                  return;
                }

                try {
                  const connection = new window.solanaWeb3.Connection(
                    window.eclipseWallet.rpcUrl,
                    "confirmed"
                  );
                  const publicKey = new window.solanaWeb3.PublicKey(
                    window.eclipseWallet.publicKey
                  );
                  const balance = await connection.getBalance(publicKey);
                  const balanceInSol =
                    balance / window.solanaWeb3.LAMPORTS_PER_SOL;

                  this.logHtml(`<b>Eclipse Wallet Balance:</b>`, "output");
                  this.logHtml(
                    `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.eclipseWallet.publicKey}')">${window.eclipseWallet.publicKey}</span>`,
                    "output"
                  );
                  this.logHtml(
                    `<b>Balance:</b> <b>${balanceInSol.toFixed(9)} SOL</b>`,
                    "output"
                  );
                  this.logHtml(`<b>Network:</b> Eclipse (SVM)`, "output");
                } catch (e) {
                  this.log(
                    "Failed to fetch Eclipse wallet balance: " + e.message,
                    "error"
                  );
                }
                return;
              }

              this.log(
                'Unknown Hyperliquid command. Type "hyperliquid help" for available commands.',
                "error"
              );
              return;
            case "magiceden":
            case "me":
              if (args[1] === "help") {
                this.log("=== Magic Eden NFT Marketplace ===", "info");
                this.log("magiceden help - Show this help", "output");
                this.log(
                  "magiceden collections - Get all collections",
                  "output"
                );
                this.log(
                  "magiceden popular - Get popular collections",
                  "output"
                );
                this.log(
                  "magiceden activities <symbol> - Get collection activities",
                  "output"
                );
                this.log("", "output");
                this.log("Examples:", "output");
                this.log("magiceden collections", "output");
                this.log("magiceden popular", "output");
                this.log("magiceden activities okay_bears", "output");
                return;
              }

              if (args[1] === "collections") {
                await this.getMagicEdenCollections();
                return;
              }

              if (args[1] === "popular") {
                await this.getMagicEdenPopularCollections();
                return;
              }

              if (args[1] === "activities" && args.length >= 3) {
                const symbol = args[2];
                await this.getMagicEdenCollectionActivities(symbol);
                return;
              }

              this.log(
                'Unknown Magic Eden command. Type "magiceden help" for available commands.',
                "error"
              );
              return;

            case "fns":
              // FNS (FAIR Name Service) Commands
              const fnsContract = "0x2d06d9568ae99f61f421ea99a46969878986fc2d";

              if (!args[1] || args[1] === "help") {
                let html = `<b>📛 FNS (FAIR Name Service) Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>fns register &lt;name&gt;</b> — Register a FNS name to your address</li>`;
                html += `<li><b>fns resolve &lt;name&gt;</b> — Get address for a FNS name</li>`;
                html += `<li><b>fns lookup &lt;address&gt;</b> — Get FNS name for an address</li>`;
                html += `<li><b>fns transfer &lt;name&gt; &lt;address&gt;</b> — Transfer name ownership</li>`;
                html += `<li><b>fns search &lt;term&gt;</b> — Search for FNS names</li>`;
                html += `<li><b>fns help</b> — Show this help</li>`;
                html += `</ul>`;
                html += `<br><b>FNS Contract:</b> ${fnsContract}<br>`;
                html += `<br>💡 Use FNS names anywhere! Send tokens with: <b>fair send 100 myname.fns</b><br>`;
                this.logHtml(html, "output");
                return;
              }

              // fns register
              if (args[1] === "register" && args[2]) {
                try {
                  const name = args[2].toLowerCase().replace(/\.fns$/, "");

                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  let signer;
                  if (window.fairWallet) {
                    const provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                  }

                  this.log(`📝 Registering FNS name: ${name}...`, "info");

                  const fnsABI = [
                    "function register(string memory name) public",
                    "function resolve(string memory name) public view returns (address)",
                    "function getNameByAddress(address owner) public view returns (string memory)",
                    "function transfer(string memory name, address newOwner) public",
                    "function isAvailable(string memory name) public view returns (bool)",
                    "function getAllNames() public view returns (string[] memory)",
                  ];

                  const fns = new this.ethers.Contract(
                    fnsContract,
                    fnsABI,
                    signer
                  );

                  // Check if available
                  const available = await fns.isAvailable(name);
                  if (!available) {
                    this.log(
                      `❌ Name "${name}" is already registered`,
                      "error"
                    );
                    this.log(
                      "💡 Try a different name or use: fns search " + name,
                      "info"
                    );
                    return;
                  }

                  const tx = await fns.register(name);
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  await tx.wait();

                  this.log("", "info");
                  this.log(`✅ FNS name registered: ${name}.fns`, "success");
                  const address = await signer.getAddress();
                  this.log(`📍 Resolves to: ${address}`, "output");
                  this.log("", "info");
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );
                  this.log(
                    "💡 Anyone can now send tokens to: " + name + ".fns",
                    "info"
                  );

                  return;
                } catch (e) {
                  this.log("❌ Registration failed: " + e.message, "error");
                  return;
                }
              }

              // fns resolve
              if (args[1] === "resolve" && args[2]) {
                try {
                  const name = args[2].toLowerCase().replace(/\.fns$/, "");
                  const provider = new this.ethers.providers.JsonRpcProvider(
                    "https://testnet-rpc.fair.cloud"
                  );

                  const fnsABI = [
                    "function resolve(string memory name) public view returns (address)",
                  ];
                  const fns = new this.ethers.Contract(
                    fnsContract,
                    fnsABI,
                    provider
                  );

                  this.log(`🔍 Resolving ${name}.fns...`, "info");
                  const address = await fns.resolve(name);

                  if (
                    address === "0x0000000000000000000000000000000000000000"
                  ) {
                    this.log(`❌ Name "${name}.fns" not found`, "error");
                    this.log(
                      "💡 Register it with: fns register " + name,
                      "info"
                    );
                  } else {
                    this.log("", "info");
                    this.log(`✅ ${name}.fns resolves to:`, "success");
                    this.log(`📍 ${address}`, "output");
                    this.log("", "info");
                  }

                  return;
                } catch (e) {
                  this.log("❌ Failed to resolve: " + e.message, "error");
                  return;
                }
              }

              // fns lookup (reverse lookup)
              if (args[1] === "lookup" && args[2]) {
                try {
                  const address = args[2];
                  const provider = new this.ethers.providers.JsonRpcProvider(
                    "https://testnet-rpc.fair.cloud"
                  );

                  const fnsABI = [
                    "function getNameByAddress(address owner) public view returns (string memory)",
                  ];
                  const fns = new this.ethers.Contract(
                    fnsContract,
                    fnsABI,
                    provider
                  );

                  this.log(`🔍 Looking up address...`, "info");
                  const name = await fns.getNameByAddress(address);

                  if (!name || name === "") {
                    this.log(`❌ No FNS name found for ${address}`, "info");
                  } else {
                    this.log("", "info");
                    this.log(`✅ Primary name: ${name}.fns`, "success");
                    this.log(`📍 Address: ${address}`, "output");
                    this.log("", "info");
                  }

                  return;
                } catch (e) {
                  this.log("❌ Failed to lookup: " + e.message, "error");
                  return;
                }
              }

              // fns transfer
              if (args[1] === "transfer" && args[2] && args[3]) {
                try {
                  const name = args[2].toLowerCase().replace(/\.fns$/, "");
                  const newOwner = args[3];

                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  let signer;
                  if (window.fairWallet) {
                    const provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                  }

                  this.log(
                    `📤 Transferring ${name}.fns to ${newOwner}...`,
                    "info"
                  );

                  const fnsABI = [
                    "function transfer(string memory name, address newOwner) public",
                  ];
                  const fns = new this.ethers.Contract(
                    fnsContract,
                    fnsABI,
                    signer
                  );

                  const tx = await fns.transfer(name, newOwner);
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  await tx.wait();

                  this.log("", "info");
                  this.log(
                    `✅ ${name}.fns transferred to ${newOwner}`,
                    "success"
                  );
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );

                  return;
                } catch (e) {
                  this.log("❌ Transfer failed: " + e.message, "error");
                  if (e.message.includes("Not the owner")) {
                    this.log(
                      "💡 You must own this name to transfer it",
                      "info"
                    );
                  }
                  return;
                }
              }

              // fns search
              if (args[1] === "search" && args[2]) {
                try {
                  const searchTerm = args[2]
                    .toLowerCase()
                    .replace(/\.fns$/, "");
                  const provider = new this.ethers.providers.JsonRpcProvider(
                    "https://testnet-rpc.fair.cloud"
                  );

                  const fnsABI = [
                    "function getAllNames() public view returns (string[] memory)",
                  ];
                  const fns = new this.ethers.Contract(
                    fnsContract,
                    fnsABI,
                    provider
                  );

                  this.log(
                    `🔍 Searching for names containing "${searchTerm}"...`,
                    "info"
                  );
                  const allNames = await fns.getAllNames();

                  const matches = allNames.filter((name) =>
                    name.toLowerCase().includes(searchTerm)
                  );

                  if (matches.length === 0) {
                    this.log(
                      `❌ No names found containing "${searchTerm}"`,
                      "info"
                    );
                    this.log(
                      "💡 Register it with: fns register " + searchTerm,
                      "info"
                    );
                  } else {
                    this.log("", "info");
                    this.log(`✅ Found ${matches.length} name(s):`, "success");
                    this.log("", "info");
                    matches.slice(0, 20).forEach((name, i) => {
                      this.log(`  ${i + 1}. ${name}.fns`, "output");
                    });
                    if (matches.length > 20) {
                      this.log(`  ... and ${matches.length - 20} more`, "info");
                    }
                    this.log("", "info");
                  }

                  return;
                } catch (e) {
                  this.log("❌ Search failed: " + e.message, "error");
                  return;
                }
              }

              this.log(
                '❌ Unknown FNS command. Type "fns help" for available commands.',
                "error"
              );
              return;

            case "fair":
              if (args[1] === "help" || args[1] === "-help" || !args[1]) {
                let html = `<b>🔗 FAIR Blockchain Commands:</b><br>`;
                html += `<ul style='margin-left:1em;'>`;
                html += `<li><b>fair generate</b> — Generate a new FAIR wallet</li>`;
                html += `<li><b>fair connect</b> — Connect MetaMask to FAIR network</li>`;
                html += `<li><b>fair wallet</b> — Show current FAIR wallet details</li>`;
                html += `<li><b>fair balance</b> — Check FAIR balance</li>`;
                html += `<li><b>fair faucet</b> — Get testnet FAIR tokens (auto-copies address)</li>`;
                html += `<li><b>fair send &lt;amount&gt; &lt;address|fns&gt;</b> — Send FAIR tokens</li>`;
                html += `<li><b>fair send-token &lt;token&gt; &lt;amount&gt; &lt;address|fns&gt;</b> — Send ERC20 tokens</li>`;
                html += `<li><b>fair create-token</b> — Create a custom ERC20 token (interactive)</li>`;
                html += `<li><b>fair my-tokens</b> — List your created tokens</li>`;
                html += `<li><b>fair token-info &lt;address&gt;</b> — Get token details</li>`;
                html += `<li><b>fair mint-nft</b> — Mint a FAIR NFT (interactive)</li>`;
                html += `<li><b>fair my-nfts</b> — View your NFTs</li>`;
                html += `<li><b>fair nft-info &lt;tokenId&gt;</b> — Get NFT details</li>`;
                html += `<li><b>fair transfer-nft &lt;tokenId&gt; &lt;address|fns&gt;</b> — Transfer NFT</li>`;
                html += `<li><b>fair help</b> — Show this help</li>`;
                html += `</ul>`;
                html += `<br><b>Network Info:</b><br>`;
                html += `Chain ID: 935<br>`;
                html += `RPC: https://testnet-rpc.fair.cloud<br>`;
                html += `Explorer: https://testnet-explorer.fair.cloud<br>`;
                html += `Token Factory: 0x30a399891f44c2ee07134e248d0393e53286f5f4<br>`;
                html += `NFT Contract: 0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e<br>`;
                html += `FNS Contract: 0x2d06d9568ae99f61f421ea99a46969878986fc2d<br>`;
                html += `<br>💡 Use <b>fair generate</b> to create a new wallet or <b>fair connect</b> to use MetaMask<br>`;
                html += `💡 Get testnet tokens with <b>fair faucet</b> (copies your address automatically!)<br>`;
                html += `💡 Register FNS names with <b>fns register myname</b> - then use <b>fair send 10 myname.fns</b>!<br>`;
                html += `💡 Create your own token with <b>fair create-token</b> or mint NFTs with <b>fair mint-nft</b>!<br>`;
                this.logHtml(html, "output");
                return;
              }

              // fair generate
              if (args[1] === "generate" || args[1] === "gen") {
                try {
                  const wallet = this.ethers.Wallet.createRandom();

                  // Store in session
                  window.fairWallet = {
                    address: wallet.address,
                    privateKey: wallet.privateKey,
                    wallet: wallet,
                    network: "FAIR Testnet",
                    chainId: 935,
                    rpcUrl: "https://testnet-rpc.fair.cloud",
                  };

                  let html = `<b>✅ New FAIR Wallet Generated!</b><br>`;
                  html += `<span style='color:#ff3333'>⚠️ SECURITY WARNING: Save your private key securely. Anyone with this key can access your funds!</span><br><br>`;
                  html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${wallet.address}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${wallet.address}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${wallet.privateKey}').then(() => window.terminal.log('✅ Private key copied!', 'success'))">${wallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> FAIR Testnet Beta<br>`;
                  html += `<b>Chain ID:</b> 935<br>`;
                  html += `<b>RPC URL:</b> https://testnet-rpc.fair.cloud<br>`;
                  html += `<b>Explorer:</b> <a href="https://testnet-explorer.fair.cloud" target="_blank" style="color:#00ff80;">testnet-explorer.fair.cloud</a><br>`;
                  html += `<br><button onclick="(() => { const blob = new Blob(['Address: ${wallet.address}\\nPrivate Key: ${wallet.privateKey}\\nNetwork: FAIR Testnet Beta\\nChain ID: 935\\nRPC URL: https://testnet-rpc.fair.cloud'], {type: 'text/plain'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'fair-wallet.txt'; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000); window.terminal.log('✅ Wallet info downloaded!', 'success'); })()">💾 Download Wallet Info</button><br>`;
                  html += `<br>💡 Get testnet FAIR from the <a href="https://testnet-faucet.fair.cloud" target="_blank" style="color:#00ff80;">FAIR Faucet</a><br>`;
                  html += `💡 Use <b>fair balance</b> to check your balance<br>`;
                  this.logHtml(html, "output");
                  this.log("", "info");
                  return;
                } catch (e) {
                  this.log(
                    "❌ Failed to generate FAIR wallet: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // fair wallet
              if (args[1] === "wallet" || args[1] === "info") {
                if (window.fairWallet) {
                  let html = `<b>Current FAIR Wallet:</b><br>`;
                  html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.fairWallet.address}')">${window.fairWallet.address}</span><br>`;
                  html += `<b>Private Key:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${window.fairWallet.privateKey}')">${window.fairWallet.privateKey}</span><br>`;
                  html += `<b>Network:</b> ${window.fairWallet.network}<br>`;
                  html += `<b>Chain ID:</b> ${window.fairWallet.chainId}<br>`;
                  html += `<b>RPC URL:</b> ${window.fairWallet.rpcUrl}<br>`;
                  this.logHtml(html, "output");
                } else if (this.signer) {
                  const address = await this.signer.getAddress();
                  this.log("Connected with MetaMask:", "info");
                  this.log(`Address: ${address}`, "output");
                  this.log("Network: FAIR Testnet Beta", "output");
                } else {
                  this.log(
                    "No FAIR wallet generated or connected. Use: fair generate",
                    "warning"
                  );
                }
                return;
              }

              // fair balance
              if (args[1] === "balance" || args[1] === "bal") {
                try {
                  let address;
                  let provider;

                  if (window.fairWallet) {
                    address = window.fairWallet.address;
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                  } else if (this.signer) {
                    address = await this.signer.getAddress();
                    provider = this.provider;
                  } else {
                    this.log(
                      "No FAIR wallet found. Use: fair generate",
                      "warning"
                    );
                    return;
                  }

                  this.log("🔍 Checking FAIR balance...", "info");

                  // Play balance/wealth sound effect
                  if (
                    window.OmegaSoundEffects &&
                    window.OmegaSoundEffects.isSoundEnabled()
                  ) {
                    window.OmegaSoundEffects.playBalanceWealthSound();
                  }
                  const balance = await provider.getBalance(address);
                  const fairBalance = this.ethers.utils.formatEther(balance);

                  this.log("", "info");
                  this.log(`💰 FAIR Balance: ${fairBalance} FAIR`, "success");
                  this.log(`📍 Address: ${address}`, "output");
                  this.log("", "info");
                  return;
                } catch (e) {
                  this.log("❌ Failed to check balance: " + e.message, "error");
                  return;
                }
              }

              // fair create-token (Interactive Flow)
              if (args[1] === "create-token" || args[1] === "create") {
                try {
                  // Check wallet first
                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet found. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  this.log("🏭 FAIR Token Creator", "success");
                  this.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "info");
                  this.log("", "info");

                  // Prompt for token name
                  this.log('Enter token name (e.g., "My Fair Token"):', "info");
                  const name = await this.promptUser();
                  if (!name || !name.trim()) {
                    this.log("❌ Token name is required", "error");
                    return;
                  }

                  // Prompt for symbol
                  this.log('Enter token symbol (e.g., "MFT"):', "info");
                  const symbol = await this.promptUser();
                  if (!symbol || !symbol.trim()) {
                    this.log("❌ Token symbol is required", "error");
                    return;
                  }

                  // Prompt for supply
                  this.log("Enter total supply (e.g., 1000000):", "info");
                  const supply = await this.promptUser();
                  if (!supply || isNaN(supply)) {
                    this.log("❌ Invalid supply. Must be a number", "error");
                    return;
                  }

                  // Prompt for burnable
                  this.log(
                    "Enable burning? (yes/no) - Allows holders to burn tokens:",
                    "info"
                  );
                  const burnableInput = (await this.promptUser()).toLowerCase();
                  const burnable =
                    burnableInput === "yes" || burnableInput === "y";

                  // Prompt for mintable
                  this.log(
                    "Enable minting? (yes/no) - Allows owner to mint new tokens:",
                    "info"
                  );
                  const mintableInput = (await this.promptUser()).toLowerCase();
                  const mintable =
                    mintableInput === "yes" || mintableInput === "y";

                  // Prompt for pausable
                  this.log(
                    "Enable pausing? (yes/no) - Allows owner to pause transfers:",
                    "info"
                  );
                  const pausableInput = (await this.promptUser()).toLowerCase();
                  const pausable =
                    pausableInput === "yes" || pausableInput === "y";

                  this.log("", "info");
                  this.log("📋 Token Configuration:", "success");
                  this.log(`  Name: ${name}`, "output");
                  this.log(`  Symbol: ${symbol}`, "output");
                  this.log(`  Supply: ${supply}`, "output");
                  this.log(`  Burnable: ${burnable ? "✅" : "❌"}`, "output");
                  this.log(`  Mintable: ${mintable ? "✅" : "❌"}`, "output");
                  this.log(`  Pausable: ${pausable ? "✅" : "❌"}`, "output");
                  this.log("", "info");

                  // Get signer (MetaMask or generated wallet)
                  let signer;
                  let provider;
                  if (window.fairWallet) {
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else if (this.signer) {
                    signer = this.signer;
                  }

                  this.log(
                    `🏭 Creating token "${name}" (${symbol})...`,
                    "info"
                  );

                  // Advanced FAIR Token Factory ABI
                  const factoryABI = [
                    "function createToken(string memory _name, string memory _symbol, uint256 _supply, bool _burnable, bool _mintable, bool _pausable) public returns (address)",
                    "function getUserTokens(address _user) public view returns (address[] memory)",
                    "function getTotalTokens() public view returns (uint256)",
                    "event TokenCreated(address indexed tokenAddress, address indexed owner, string name, string symbol, uint256 totalSupply, bool burnable, bool mintable, bool pausable)",
                  ];

                  const factoryAddress =
                    "0x30a399891f44c2ee07134e248d0393e53286f5f4";
                  const factory = new this.ethers.Contract(
                    factoryAddress,
                    factoryABI,
                    signer
                  );

                  const tx = await factory.createToken(
                    name.trim(),
                    symbol.trim(),
                    supply,
                    burnable,
                    mintable,
                    pausable
                  );
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  const receipt = await tx.wait();

                  // Find TokenCreated event in logs
                  const tokenCreatedEvent = receipt.logs.find((log) => {
                    try {
                      const parsed = factory.interface.parseLog(log);
                      return parsed.name === "TokenCreated";
                    } catch (e) {
                      return false;
                    }
                  });

                  if (tokenCreatedEvent) {
                    const parsed =
                      factory.interface.parseLog(tokenCreatedEvent);
                    const tokenAddress = parsed.args.tokenAddress;

                    let html = `<b>✅ Token Created Successfully!</b><br><br>`;
                    html += `<b>Token Name:</b> ${name}<br>`;
                    html += `<b>Symbol:</b> ${symbol}<br>`;
                    html += `<b>Total Supply:</b> ${supply}<br>`;
                    html += `<b>Features:</b> ${
                      burnable ? "🔥 Burnable " : ""
                    }${mintable ? "⚡ Mintable " : ""}${
                      pausable ? "⏸️ Pausable" : ""
                    }${
                      !burnable && !mintable && !pausable
                        ? "Standard ERC20"
                        : ""
                    }<br>`;
                    html += `<b>Token Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${tokenAddress}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${tokenAddress}</span><br>`;
                    html += `<b>Transaction:</b> <a href="https://testnet-explorer.fair.cloud/tx/${
                      tx.hash
                    }" target="_blank" style="color:#00ff80;">${tx.hash.substring(
                      0,
                      20
                    )}...</a><br>`;
                    html += `<br>💡 Use <b>fair my-tokens</b> to see all your tokens<br>`;
                    html += `💡 View on explorer: <a href="https://testnet-explorer.fair.cloud/address/${tokenAddress}" target="_blank" style="color:#00ff80;">View Token</a><br>`;
                    this.logHtml(html, "output");
                  } else {
                    this.log("✅ Token created successfully!", "success");
                    this.log(`Transaction: ${tx.hash}`, "output");
                  }

                  return;
                } catch (e) {
                  this.log("❌ Failed to create token: " + e.message, "error");
                  if (e.reason) this.log(`Reason: ${e.reason}`, "error");
                  return;
                }
              }

              // fair my-tokens
              if (args[1] === "my-tokens" || args[1] === "tokens") {
                try {
                  let address;
                  let provider;

                  if (window.fairWallet) {
                    address = window.fairWallet.address;
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                  } else if (this.signer) {
                    address = await this.signer.getAddress();
                    provider = this.provider;
                  } else {
                    this.log(
                      "❌ No wallet found. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  this.log("🔍 Fetching your tokens...", "info");

                  const factoryABI = [
                    "function getUserTokens(address _user) public view returns (address[] memory)",
                  ];

                  const tokenABI = [
                    "function name() public view returns (string memory)",
                    "function symbol() public view returns (string memory)",
                    "function totalSupply() public view returns (uint256)",
                    "function decimals() public view returns (uint8)",
                  ];

                  const factoryAddress =
                    "0x30a399891f44c2ee07134e248d0393e53286f5f4";
                  const factory = new this.ethers.Contract(
                    factoryAddress,
                    factoryABI,
                    provider
                  );

                  const tokens = await factory.getUserTokens(address);

                  if (tokens.length === 0) {
                    this.log("📋 You haven't created any tokens yet.", "info");
                    this.log(
                      '💡 Create one with: fair create-token "My Token" MTK 1000000',
                      "info"
                    );
                    return;
                  }

                  this.log("", "info");
                  this.log(`📋 Your Tokens (${tokens.length}):`, "success");
                  this.log("", "info");

                  for (let i = 0; i < tokens.length; i++) {
                    const tokenContract = new this.ethers.Contract(
                      tokens[i],
                      tokenABI,
                      provider
                    );
                    try {
                      const name = await tokenContract.name();
                      const symbol = await tokenContract.symbol();
                      const totalSupply = await tokenContract.totalSupply();
                      const decimals = await tokenContract.decimals();
                      const formattedSupply = this.ethers.utils.formatUnits(
                        totalSupply,
                        decimals
                      );

                      let html = `<b>${i + 1}. ${name} (${symbol})</b><br>`;
                      html += `Address: <span class='copyable' onclick="navigator.clipboard.writeText('${tokens[i]}')">${tokens[i]}</span><br>`;
                      html += `Supply: ${formattedSupply}<br>`;
                      html += `Explorer: <a href="https://testnet-explorer.fair.cloud/address/${tokens[i]}" target="_blank" style="color:#00ff80;">View</a><br>`;
                      this.logHtml(html, "output");
                    } catch (e) {
                      this.log(`${i + 1}. ${tokens[i]}`, "output");
                    }
                  }

                  return;
                } catch (e) {
                  this.log("❌ Failed to fetch tokens: " + e.message, "error");
                  return;
                }
              }

              // fair token-info
              if (args[1] === "token-info" || args[1] === "info-token") {
                if (!args[2]) {
                  this.log("Usage: fair token-info <token-address>", "info");
                  return;
                }

                try {
                  const tokenAddress = args[2];
                  const provider = new this.ethers.providers.JsonRpcProvider(
                    "https://testnet-rpc.fair.cloud"
                  );

                  this.log(
                    `🔍 Getting token info for ${tokenAddress}...`,
                    "info"
                  );

                  const tokenABI = [
                    "function name() public view returns (string memory)",
                    "function symbol() public view returns (string memory)",
                    "function totalSupply() public view returns (uint256)",
                    "function decimals() public view returns (uint8)",
                    "function owner() public view returns (address)",
                    "function balanceOf(address) public view returns (uint256)",
                  ];

                  const token = new this.ethers.Contract(
                    tokenAddress,
                    tokenABI,
                    provider
                  );

                  const name = await token.name();
                  const symbol = await token.symbol();
                  const totalSupply = await token.totalSupply();
                  const decimals = await token.decimals();
                  const owner = await token.owner();
                  const formattedSupply = this.ethers.utils.formatUnits(
                    totalSupply,
                    decimals
                  );

                  this.log("", "info");
                  let html = `<b>📊 Token Information:</b><br><br>`;
                  html += `<b>Name:</b> ${name}<br>`;
                  html += `<b>Symbol:</b> ${symbol}<br>`;
                  html += `<b>Decimals:</b> ${decimals}<br>`;
                  html += `<b>Total Supply:</b> ${formattedSupply}<br>`;
                  html += `<b>Owner:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${owner}')">${owner}</span><br>`;
                  html += `<b>Address:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${tokenAddress}')">${tokenAddress}</span><br>`;
                  html += `<br><b>Explorer:</b> <a href="https://testnet-explorer.fair.cloud/address/${tokenAddress}" target="_blank" style="color:#00ff80;">View on FAIR Explorer</a><br>`;
                  this.logHtml(html, "output");

                  return;
                } catch (e) {
                  this.log(
                    "❌ Failed to get token info: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // fair send (send FAIR tokens)
              if (args[1] === "send" && args[2] && args[3]) {
                try {
                  const amount = args[2];
                  let recipientInput = args[3];

                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  let signer;
                  let provider;
                  if (window.fairWallet) {
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                    provider = this.provider;
                  }

                  // Check if recipient is FNS name
                  let recipient = recipientInput;
                  let fnsName = null;
                  if (
                    recipientInput.endsWith(".fns") ||
                    !recipientInput.startsWith("0x")
                  ) {
                    fnsName = recipientInput.replace(/\.fns$/, "");
                    this.log(
                      `🔍 Resolving FNS name: ${fnsName}.fns...`,
                      "info"
                    );

                    const fnsABI = [
                      "function resolve(string memory name) public view returns (address)",
                    ];
                    const fns = new this.ethers.Contract(
                      "0x2d06d9568ae99f61f421ea99a46969878986fc2d",
                      fnsABI,
                      provider
                    );
                    recipient = await fns.resolve(fnsName);

                    if (
                      recipient === "0x0000000000000000000000000000000000000000"
                    ) {
                      this.log(
                        `❌ FNS name "${fnsName}.fns" not found`,
                        "error"
                      );
                      this.log("💡 Use: fns search " + fnsName, "info");
                      return;
                    }
                    this.log(`✅ Resolved to: ${recipient}`, "success");
                  }

                  this.log(
                    `💸 Sending ${amount} FAIR to ${
                      fnsName ? fnsName + ".fns" : recipient
                    }...`,
                    "info"
                  );

                  const tx = await signer.sendTransaction({
                    to: recipient,
                    value: this.ethers.utils.parseEther(amount),
                  });

                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  await tx.wait();

                  this.log("", "info");
                  this.log(`✅ Sent ${amount} FAIR!`, "success");
                  this.log(
                    `📍 To: ${
                      fnsName ? fnsName + ".fns (" + recipient + ")" : recipient
                    }`,
                    "output"
                  );
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to send: " + e.message, "error");
                  if (e.message.includes("insufficient funds")) {
                    this.log("💡 Get tokens with: fair faucet", "info");
                  }
                  return;
                }
              }

              // fair send-token (send ERC20 tokens)
              if (args[1] === "send-token" && args[2] && args[3] && args[4]) {
                try {
                  const tokenAddress = args[2];
                  const amount = args[3];
                  let recipientInput = args[4];

                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  let signer;
                  let provider;
                  if (window.fairWallet) {
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                    provider = this.provider;
                  }

                  // Check if recipient is FNS name
                  let recipient = recipientInput;
                  let fnsName = null;
                  if (
                    recipientInput.endsWith(".fns") ||
                    !recipientInput.startsWith("0x")
                  ) {
                    fnsName = recipientInput.replace(/\.fns$/, "");
                    this.log(
                      `🔍 Resolving FNS name: ${fnsName}.fns...`,
                      "info"
                    );

                    const fnsABI = [
                      "function resolve(string memory name) public view returns (address)",
                    ];
                    const fns = new this.ethers.Contract(
                      "0x2d06d9568ae99f61f421ea99a46969878986fc2d",
                      fnsABI,
                      provider
                    );
                    recipient = await fns.resolve(fnsName);

                    if (
                      recipient === "0x0000000000000000000000000000000000000000"
                    ) {
                      this.log(
                        `❌ FNS name "${fnsName}.fns" not found`,
                        "error"
                      );
                      return;
                    }
                    this.log(`✅ Resolved to: ${recipient}`, "success");
                  }

                  // Get token info
                  const tokenABI = [
                    "function name() public view returns (string memory)",
                    "function symbol() public view returns (string memory)",
                    "function decimals() public view returns (uint8)",
                    "function transfer(address to, uint256 amount) public returns (bool)",
                  ];

                  const token = new this.ethers.Contract(
                    tokenAddress,
                    tokenABI,
                    signer
                  );
                  const symbol = await token.symbol();
                  const decimals = await token.decimals();

                  this.log(
                    `💸 Sending ${amount} ${symbol} to ${
                      fnsName ? fnsName + ".fns" : recipient
                    }...`,
                    "info"
                  );

                  const tx = await token.transfer(
                    recipient,
                    this.ethers.utils.parseUnits(amount, decimals)
                  );
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  await tx.wait();

                  this.log("", "info");
                  this.log(`✅ Sent ${amount} ${symbol}!`, "success");
                  this.log(
                    `📍 To: ${
                      fnsName ? fnsName + ".fns (" + recipient + ")" : recipient
                    }`,
                    "output"
                  );
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to send token: " + e.message, "error");
                  return;
                }
              }

              // fair faucet
              if (args[1] === "faucet") {
                try {
                  let address;
                  if (window.fairWallet) {
                    address = window.fairWallet.address;
                  } else if (this.signer) {
                    address = await this.signer.getAddress();
                  } else {
                    this.log(
                      "❌ No wallet found. Use: fair generate or fair connect",
                      "error"
                    );
                    this.log(
                      "💡 Or you can visit the faucet manually: https://testnet-faucet.fair.cloud",
                      "info"
                    );
                    return;
                  }

                  // Copy address to clipboard
                  await navigator.clipboard.writeText(address);

                  // Open faucet in new window
                  window.open(
                    "https://testnet-faucet.fair.cloud",
                    "_blank",
                    "width=800,height=900"
                  );

                  this.log("", "info");
                  this.log("🚰 Opening FAIR Faucet...", "success");
                  this.log("", "info");
                  this.log(
                    "✅ Your address has been copied to clipboard!",
                    "success"
                  );
                  this.log(`📍 Address: ${address}`, "output");
                  this.log("", "info");
                  this.log("📋 Instructions:", "info");
                  this.log(
                    "  1. Paste your address (Ctrl+V) in the faucet",
                    "output"
                  );
                  this.log('  2. Click "Claim"', "output");
                  this.log("  3. Wait 24 hours between claims", "output");
                  this.log(
                    '  4. Use "fair balance" to check your balance',
                    "output"
                  );
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to open faucet: " + e.message, "error");
                  this.log(
                    "💡 Visit manually: https://testnet-faucet.fair.cloud",
                    "info"
                  );
                  return;
                }
              }

              // fair connect
              if (args[1] === "connect") {
                try {
                  if (!window.ethereum) {
                    this.log(
                      "❌ MetaMask not detected. Please install MetaMask.",
                      "error"
                    );
                    return;
                  }

                  this.log("🔗 Connecting to FAIR network...", "info");

                  // Try to switch to FAIR network
                  try {
                    await window.ethereum.request({
                      method: "wallet_switchEthereumChain",
                      params: [{ chainId: "0x3A7" }], // 935 in hex
                    });
                  } catch (switchError) {
                    // If network doesn't exist, add it
                    if (switchError.code === 4902) {
                      await window.ethereum.request({
                        method: "wallet_addEthereumChain",
                        params: [
                          {
                            chainId: "0x3A7",
                            chainName: "FAIR Testnet Beta",
                            nativeCurrency: {
                              name: "FAIR",
                              symbol: "FAIR",
                              decimals: 18,
                            },
                            rpcUrls: ["https://testnet-rpc.fair.cloud"],
                            blockExplorerUrls: [
                              "https://testnet-explorer.fair.cloud",
                            ],
                          },
                        ],
                      });
                    } else {
                      throw switchError;
                    }
                  }

                  // Connect wallet
                  const accounts = await window.ethereum.request({
                    method: "eth_requestAccounts",
                  });
                  this.provider = new this.ethers.providers.Web3Provider(
                    window.ethereum
                  );
                  this.signer = this.provider.getSigner();
                  const address = accounts[0];

                  this.log("", "info");
                  this.log(
                    "✅ Successfully connected to FAIR network!",
                    "success"
                  );
                  this.log(`📍 Address: ${address}`, "output");
                  this.log(
                    "⛓️ Network: FAIR Testnet Beta (Chain ID: 935)",
                    "output"
                  );
                  this.log("", "info");
                  return;
                } catch (e) {
                  this.log(
                    "❌ Failed to connect to FAIR: " + e.message,
                    "error"
                  );
                  return;
                }
              }

              // fair mint-nft (Interactive NFT Minting with Image Upload)
              if (args[1] === "mint-nft" || args[1] === "mint") {
                try {
                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  this.log("🎨 FAIR NFT Minter", "success");
                  this.log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━", "info");
                  this.log("", "info");

                  // Prompt for NFT name
                  this.log("Enter NFT name:", "info");
                  const nftName = await this.promptUser();
                  if (!nftName || !nftName.trim()) {
                    this.log("❌ NFT name is required", "error");
                    return;
                  }

                  // Prompt for description
                  this.log("Enter NFT description:", "info");
                  const description = await this.promptUser();

                  // Create file input for image upload
                  this.log("📸 Click to select an image to upload...", "info");
                  const file = await new Promise((resolve) => {
                    const input = document.createElement("input");
                    input.type = "file";
                    input.accept = "image/*";
                    input.onchange = (e) => {
                      const file = e.target.files[0];
                      if (file) {
                        resolve(file);
                      } else {
                        resolve(null);
                      }
                    };
                    input.click();
                  });

                  if (!file) {
                    this.log("❌ No image selected", "error");
                    return;
                  }

                  this.log(
                    `✅ Selected: ${file.name} (${(
                      file.size /
                      1024 /
                      1024
                    ).toFixed(2)} MB)`,
                    "success"
                  );
                  this.log("☁️ Uploading image to IPFS via Pinata...", "info");

                  // Upload image to Pinata
                  const formData = new FormData();
                  formData.append("file", file);

                  const imageResponse = await fetch(
                    "https://api.pinata.cloud/pinning/pinFileToIPFS",
                    {
                      method: "POST",
                      headers: {
                        pinata_api_key: "c717314daa6072cf4111",
                        pinata_secret_api_key:
                          "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
                      },
                      body: formData,
                    }
                  );

                  if (!imageResponse.ok) {
                    throw new Error("Failed to upload image to IPFS");
                  }

                  const imageResult = await imageResponse.json();
                  const imageUrl = `https://gateway.pinata.cloud/ipfs/${imageResult.IpfsHash}`;

                  this.log(
                    `✅ Image uploaded to IPFS: ${imageResult.IpfsHash}`,
                    "success"
                  );

                  // Create metadata
                  const metadata = {
                    name: nftName.trim(),
                    description: description.trim() || "A FAIR NFT",
                    image: imageUrl,
                    attributes: [
                      { trait_type: "Network", value: "FAIR" },
                      { trait_type: "Blockchain", value: "FAIR Testnet" },
                    ],
                  };

                  this.log("☁️ Uploading metadata to IPFS...", "info");

                  // Upload metadata to Pinata
                  const metadataResponse = await fetch(
                    "https://api.pinata.cloud/pinning/pinJSONToIPFS",
                    {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        pinata_api_key: "c717314daa6072cf4111",
                        pinata_secret_api_key:
                          "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
                      },
                      body: JSON.stringify({
                        pinataContent: metadata,
                        pinataMetadata: {
                          name: `fair-nft-${nftName
                            .replace(/\s+/g, "-")
                            .toLowerCase()}.json`,
                        },
                      }),
                    }
                  );

                  if (!metadataResponse.ok) {
                    throw new Error("Failed to upload metadata to IPFS");
                  }

                  const metadataResult = await metadataResponse.json();
                  const metadataUri = `https://gateway.pinata.cloud/ipfs/${metadataResult.IpfsHash}`;

                  this.log(
                    `✅ Metadata uploaded to IPFS: ${metadataResult.IpfsHash}`,
                    "success"
                  );

                  this.log("", "info");
                  this.log("📋 NFT Details:", "success");
                  this.log(`  Name: ${nftName}`, "output");
                  this.log(
                    `  Description: ${description || "A FAIR NFT"}`,
                    "output"
                  );
                  this.log(`  Image: ${imageUrl}`, "output");
                  this.log(`  Metadata: ${metadataUri}`, "output");
                  this.log("", "info");

                  let signer;
                  if (window.fairWallet) {
                    const provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                  }

                  this.log("🎨 Minting NFT...", "info");

                  const nftABI = [
                    "function mint(address to, string memory uri) public returns (uint256)",
                    "function totalSupply() public view returns (uint256)",
                  ];

                  const nftContract = new this.ethers.Contract(
                    "0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e",
                    nftABI,
                    signer
                  );
                  const address = await signer.getAddress();

                  const tx = await nftContract.mint(address, metadataUri);
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  const receipt = await tx.wait();

                  // Get token ID from current supply
                  const totalSupply = await nftContract.totalSupply();
                  const tokenId = totalSupply.sub(1).toString();

                  this.log("", "info");
                  this.log(`✅ NFT Minted Successfully!`, "success");
                  this.log(`🎨 Token ID: #${tokenId}`, "output");
                  this.log(`📍 Owner: ${address}`, "output");
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );
                  this.log("💡 Use: fair my-nfts to see all your NFTs", "info");
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to mint NFT: " + e.message, "error");
                  return;
                }
              }

              // fair my-nfts
              if (args[1] === "my-nfts" || args[1] === "nfts") {
                try {
                  let address;
                  let provider;

                  if (window.fairWallet) {
                    address = window.fairWallet.address;
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                  } else if (this.signer) {
                    address = await this.signer.getAddress();
                    provider = this.provider;
                  } else {
                    this.log(
                      "❌ No wallet found. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  this.log("🔍 Fetching your NFTs...", "info");

                  const nftABI = [
                    "function tokensOfOwner(address owner) public view returns (uint256[] memory)",
                    "function tokenURI(uint256 tokenId) public view returns (string memory)",
                  ];

                  const nftContract = new this.ethers.Contract(
                    "0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e",
                    nftABI,
                    provider
                  );
                  const tokens = await nftContract.tokensOfOwner(address);

                  if (tokens.length === 0) {
                    this.log("📋 You don't own any FAIR NFTs yet.", "info");
                    this.log("💡 Mint one with: fair mint-nft", "info");
                    return;
                  }

                  this.log("", "info");
                  this.log(`🎨 Your FAIR NFTs (${tokens.length}):`, "success");
                  this.log("", "info");

                  for (let i = 0; i < Math.min(tokens.length, 10); i++) {
                    const tokenId = tokens[i].toString();
                    try {
                      const uri = await nftContract.tokenURI(tokens[i]);

                      // Parse metadata - handle both base64 and IPFS URLs
                      let metadata = {};
                      if (uri.startsWith("data:application/json;base64,")) {
                        const base64Data = uri.split(",")[1];
                        const jsonStr = atob(base64Data);
                        metadata = JSON.parse(jsonStr);
                      } else if (
                        uri.startsWith("http://") ||
                        uri.startsWith("https://")
                      ) {
                        // Fetch metadata from IPFS
                        try {
                          const metadataResponse = await fetch(uri);
                          metadata = await metadataResponse.json();
                        } catch (e) {
                          console.error("Failed to fetch metadata:", e);
                        }
                      }

                      let html = `<b>🎨 Token #${tokenId}</b>`;
                      if (metadata.name) html += ` - ${metadata.name}`;
                      html += `<br>`;
                      if (metadata.description)
                        html += `Description: ${metadata.description}<br>`;
                      if (metadata.image)
                        html += `Image: <a href="${metadata.image}" target="_blank" style="color:#00ff80;">View</a><br>`;
                      html += `Explorer: <a href="https://testnet-explorer.fair.cloud/token/0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e?a=${tokenId}" target="_blank" style="color:#00ff80;">View NFT</a><br>`;
                      this.logHtml(html, "output");
                    } catch (e) {
                      this.log(`🎨 Token #${tokenId}`, "output");
                    }
                  }

                  if (tokens.length > 10) {
                    this.log(`... and ${tokens.length - 10} more`, "info");
                  }
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to fetch NFTs: " + e.message, "error");
                  return;
                }
              }

              // fair nft-info
              if (args[1] === "nft-info" && args[2]) {
                try {
                  const tokenId = args[2];
                  const provider = new this.ethers.providers.JsonRpcProvider(
                    "https://testnet-rpc.fair.cloud"
                  );

                  this.log(`🔍 Getting info for NFT #${tokenId}...`, "info");

                  const nftABI = [
                    "function ownerOf(uint256 tokenId) public view returns (address)",
                    "function tokenURI(uint256 tokenId) public view returns (string memory)",
                  ];

                  const nftContract = new this.ethers.Contract(
                    "0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e",
                    nftABI,
                    provider
                  );

                  const owner = await nftContract.ownerOf(tokenId);
                  const uri = await nftContract.tokenURI(tokenId);

                  // Parse metadata - handle both base64 and IPFS URLs
                  let metadata = {};
                  if (uri.startsWith("data:application/json;base64,")) {
                    const base64Data = uri.split(",")[1];
                    const jsonStr = atob(base64Data);
                    metadata = JSON.parse(jsonStr);
                  } else if (
                    uri.startsWith("http://") ||
                    uri.startsWith("https://")
                  ) {
                    // Fetch metadata from IPFS
                    try {
                      const metadataResponse = await fetch(uri);
                      metadata = await metadataResponse.json();
                    } catch (e) {
                      console.error("Failed to fetch metadata:", e);
                    }
                  }

                  this.log("", "info");
                  let html = `<b>🎨 FAIR NFT #${tokenId}</b><br><br>`;
                  if (metadata.name)
                    html += `<b>Name:</b> ${metadata.name}<br>`;
                  if (metadata.description)
                    html += `<b>Description:</b> ${metadata.description}<br>`;
                  html += `<b>Owner:</b> <span class='copyable' onclick="navigator.clipboard.writeText('${owner}')">${owner}</span><br>`;
                  if (metadata.image)
                    html += `<b>Image:</b> <a href="${metadata.image}" target="_blank" style="color:#00ff80;">View Image</a><br>`;
                  if (metadata.attributes && metadata.attributes.length > 0) {
                    html += `<br><b>Attributes:</b><br>`;
                    metadata.attributes.forEach((attr) => {
                      html += `  • ${attr.trait_type}: ${attr.value}<br>`;
                    });
                  }
                  html += `<br><b>Explorer:</b> <a href="https://testnet-explorer.fair.cloud/token/0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e?a=${tokenId}" target="_blank" style="color:#00ff80;">View on FAIR Explorer</a><br>`;
                  this.logHtml(html, "output");

                  return;
                } catch (e) {
                  this.log("❌ Failed to get NFT info: " + e.message, "error");
                  if (e.message.includes("owner query")) {
                    this.log("💡 This token may not exist yet", "info");
                  }
                  return;
                }
              }

              // fair transfer-nft (with FNS support!)
              if (args[1] === "transfer-nft" && args[2] && args[3]) {
                try {
                  const tokenId = args[2];
                  let recipientInput = args[3];

                  if (!window.fairWallet && !this.signer) {
                    this.log(
                      "❌ No wallet connected. Use: fair generate or fair connect",
                      "error"
                    );
                    return;
                  }

                  let signer;
                  let provider;
                  if (window.fairWallet) {
                    provider = new this.ethers.providers.JsonRpcProvider(
                      "https://testnet-rpc.fair.cloud"
                    );
                    signer = new this.ethers.Wallet(
                      window.fairWallet.privateKey,
                      provider
                    );
                  } else {
                    signer = this.signer;
                    provider = this.provider;
                  }

                  // Check if recipient is FNS name
                  let recipient = recipientInput;
                  let fnsName = null;
                  if (
                    recipientInput.endsWith(".fns") ||
                    !recipientInput.startsWith("0x")
                  ) {
                    fnsName = recipientInput.replace(/\.fns$/, "");
                    this.log(
                      `🔍 Resolving FNS name: ${fnsName}.fns...`,
                      "info"
                    );

                    const fnsABI = [
                      "function resolve(string memory name) public view returns (address)",
                    ];
                    const fns = new this.ethers.Contract(
                      "0x2d06d9568ae99f61f421ea99a46969878986fc2d",
                      fnsABI,
                      provider
                    );
                    recipient = await fns.resolve(fnsName);

                    if (
                      recipient === "0x0000000000000000000000000000000000000000"
                    ) {
                      this.log(
                        `❌ FNS name "${fnsName}.fns" not found`,
                        "error"
                      );
                      return;
                    }
                    this.log(`✅ Resolved to: ${recipient}`, "success");
                  }

                  this.log(
                    `🎨 Transferring NFT #${tokenId} to ${
                      fnsName ? fnsName + ".fns" : recipient
                    }...`,
                    "info"
                  );

                  const nftABI = [
                    "function transferFrom(address from, address to, uint256 tokenId) public",
                  ];
                  const nftContract = new this.ethers.Contract(
                    "0xe133cb4df4834c7e0b4aea5181ab40477c9fa30e",
                    nftABI,
                    signer
                  );
                  const from = await signer.getAddress();

                  const tx = await nftContract.transferFrom(
                    from,
                    recipient,
                    tokenId
                  );
                  this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
                  this.log("⏳ Waiting for confirmation...", "info");

                  await tx.wait();

                  this.log("", "info");
                  this.log(`✅ NFT #${tokenId} transferred!`, "success");
                  this.log(
                    `📍 To: ${
                      fnsName ? fnsName + ".fns (" + recipient + ")" : recipient
                    }`,
                    "output"
                  );
                  this.log(
                    `🔍 View on explorer: https://testnet-explorer.fair.cloud/tx/${tx.hash}`,
                    "info"
                  );
                  this.log("", "info");

                  return;
                } catch (e) {
                  this.log("❌ Failed to transfer NFT: " + e.message, "error");
                  if (e.message.includes("Not authorized")) {
                    this.log("💡 You must own this NFT to transfer it", "info");
                  }
                  return;
                }
              }

              this.log(
                'Unknown FAIR command. Type "fair help" for available commands.',
                "error"
              );
              return;

            case "ambassador":
              await this.handleAmbassadorCommand(args);
              break;
            case "profile":
              // Check for API key management subcommands first
              if (
                args[1] === "apikeys" ||
                args[1] === "api-keys" ||
                args[1] === "keys"
              ) {
                await this.handleProfileApiKeys(args.slice(2));
                return;
              }
              // Enhanced Profile System (ENS, Address Book, Chat, Fullscreen)
              if (window.handleEnhancedProfileCommand) {
                window.handleEnhancedProfileCommand(args.slice(1));
              } else if (window.openEnhancedProfile) {
                // Direct fallback to open profile
                window.openEnhancedProfile();
              } else {
                this.log("👤 Enhanced Profile System", "info");
                this.log("🔗 Omega ENS registration & management", "info");
                this.log("📇 Address book for contacts", "info");
                this.log("💬 Terminal Chatter (Telegram-like)", "info");
                this.log("🖥️ Fullscreen profile mode", "info");
                this.log(
                  "💡 Commands: profile open | profile help | profile apikeys",
                  "info"
                );
              }
              return;
            case "gui":
              this.handleGuiCommand(args);
              break;
            case "rome":
              this.handleRomeCommand(args);
              break;
            case "monad":
              this.handleMonadCommand(args);
              break;
            case "kalshi":
              // Use the kalshi.js implementation
              if (window.handleKalshiCommand) {
                await window.handleKalshiCommand(args.slice(1), this);
              } else {
                this.log("❌ Kalshi integration not loaded", "error");
                this.log("💡 Make sure kalshi.js is included", "info");
              }
              break;
            case "polymarket":
            case "poly":
              await this.handlePolymarketCommand(args);
              break;
            case "perp":
            case "perps":
              this.handlePerpCommand(args);
              break;
            case "ai":
              this.toggleAIMode();
              break;
            default:
              if (cmd) {
                // If AI mode is on and this is direct user input, send to AI instead of showing error
                if (
                  this.isAIModeOn &&
                  !this.executingAICommands &&
                  (!arguments[1] || arguments[1] !== true)
                ) {
                  console.log(
                    "Default case: Sending unhandled command to AI:",
                    cmd
                  );
                  this.logHtml(
                    `<span style='color:#99ccff'>🤖 Processing</span>`,
                    "info"
                  );
                  const url = "https://ai.omeganetwork.co/chat";
                  const evm = this.userAddress || null;
                  const solana = this.solanaAddress || null;

                  try {
                    const res = await fetch(url, {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify({
                        question: command,
                        evm,
                        solana,
                        chatHistory: this.chatHistory,
                        ...(this.aiProvider && this.aiProvider !== "off"
                          ? { provider: this.aiProvider }
                          : {}),
                      }),
                    });
                    const data = await res.json();
                    if (data && data.data) {
                      const d = data.data;
                      if (d.additionalInfoRequired) {
                        this.chatHistory.push({
                          type: "ai",
                          message: d.additionalInfo,
                        });
                        this.log(d.additionalInfo, "info");
                      }
                      if (Array.isArray(d.commands) && d.commands.length > 0) {
                        console.log("AI returned commands array:", d.commands);
                        this.chatHistory.push({
                          type: "command",
                          command: d.commands,
                        });

                        try {
                          this.executingAICommands = true;
                          for (let i = 0; i < d.commands.length; i++) {
                            const cmd = d.commands[i];
                            console.log(
                              `Executing AI command ${i + 1}/${
                                d.commands.length
                              }: "${cmd}"`
                            );
                            if (typeof cmd === "string") {
                              await this.executeCommand(cmd, true);
                            }
                          }
                        } catch (error) {
                          console.error("Error executing AI commands:", error);
                          this.log(
                            `AI command execution failed: ${error.message}`,
                            "error"
                          );
                        } finally {
                          this.executingAICommands = false;
                        }
                      } else if (!d.additionalInfoRequired) {
                        this.log("Can't perform this action", "error");
                      }
                    } else {
                      this.log("AI agent error: Invalid response.", "error");
                    }
                  } catch (err) {
                    this.log("AI agent error: " + err.message, "error");
                  }
                } else {
                  // Check if this looks like a question and ChainGPT is initialized
                  if (
                    this.isQuestionLike(command) &&
                    window.ChainGPTChatCommands &&
                    window.ChainGPTChat.isInitialized()
                  ) {
                    console.log(
                      "[DEBUG] Detected question-like input, routing to ChainGPT chat"
                    );
                    this.log(
                      "🤖 Detected a question! Routing to ChainGPT AI...",
                      "info"
                    );
                    await window.ChainGPTChatCommands.chat(this, [
                      "ask",
                      command,
                    ]);
                    return;
                  }

                  // AI mode is off or this is an AI-executed command, show normal error
                  this.log(`Command not found: ${command}`, "error");
                  this.log('Type "help" for available commands', "info");
                }
              }
          }
          // --- End command parsing ---
        }

        // Solana swap helper methods
        async executeSolanaSwap(amount, fromMint, toMint) {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }

          try {
            const res = await fetch(`${RELAYER_URL}/jupiter/swap`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                inputMint: fromMint,
                outputMint: toMint,
                amount,
                userPublicKey: this.solanaAddress,
              }),
            });
            const data = await res.json();
            if (data && (data.swapTransaction || data.transaction)) {
              // Ask Phantom to sign and send the transaction
              if (window.solana && window.solana.isPhantom) {
                try {
                  // Convert base64 transaction to Uint8Array
                  const transactionBase64 =
                    data.swapTransaction || data.transaction;
                  const transactionBuffer = Uint8Array.from(
                    atob(transactionBase64),
                    (c) => c.charCodeAt(0)
                  );

                  // Create a VersionedTransaction from the buffer
                  const transaction =
                    solanaWeb3.VersionedTransaction.deserialize(
                      transactionBuffer
                    );

                  // Sign the transaction with Phantom
                  const signedTx = await window.solana.signTransaction(
                    transaction
                  );

                  // Send the signed transaction using Helius RPC endpoint
                  const connection = new solanaWeb3.Connection(
                    "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082"
                  );
                  const signature = await connection.sendRawTransaction(
                    signedTx.serialize(),
                    {
                      maxRetries: 3,
                      skipPreflight: false,
                    }
                  );

                  // Wait for confirmation
                  this.log(
                    "Transaction sent! Waiting for confirmation...",
                    "info"
                  );

                  try {
                    const confirmation = await connection.confirmTransaction(
                      signature,
                      "confirmed"
                    );

                    if (confirmation.value.err) {
                      this.log(
                        `Transaction failed: ${JSON.stringify(
                          confirmation.value.err
                        )}`,
                        "error"
                      );
                    } else {
                      this.logHtml(
                        `<b>Swap transaction successful!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`,
                        "success"
                      );
                      this.logHtml(
                        `<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`,
                        "success"
                      );
                    }
                  } catch (confirmError) {
                    this.log(
                      `Transaction sent but confirmation failed: ${confirmError.message}`,
                      "warning"
                    );
                    this.logHtml(
                      `<b>Transaction sent!</b> Signature: <span class='copyable' onclick="navigator.clipboard.writeText('${signature}')">${signature}</span>`,
                      "success"
                    );
                    this.logHtml(
                      `<a href="https://solscan.io/tx/${signature}" target="_blank">View on Solscan</a>`,
                      "success"
                    );
                  }
                } catch (e) {
                  this.log(
                    "User rejected or failed to sign the swap transaction: " +
                      e.message,
                    "error"
                  );
                }
              } else {
                this.log("Phantom wallet not available for signing.", "error");
              }
            } else if (data && data.error) {
              this.logHtml(
                `<span style='color:#ff3333'>${data.error}</span>`,
                "error"
              );
            } else {
              this.logHtml(
                '<span style="color:#ff3333">Swap failed: No transaction received from relayer.</span>',
                "error"
              );
            }
          } catch (e) {
            this.log("Solana swap failed: " + e.message, "error");
          }
        }

        async updateSolanaQuote() {
          const fromToken = document.getElementById("solanaFromToken");
          const toToken = document.getElementById("solanaToToken");
          const amountInput = document.getElementById("solanaAmount");
          const quoteDisplay = document.getElementById("solanaQuoteDisplay");
          const quoteAmount = document.getElementById("solanaQuoteAmount");
          const quotePrice = document.getElementById("solanaQuotePrice");

          if (
            !fromToken ||
            !toToken ||
            !amountInput ||
            !quoteDisplay ||
            !quoteAmount ||
            !quotePrice
          ) {
            return;
          }

          const fromMint = fromToken.value;
          const toMint = toToken.value;
          const amount = parseFloat(amountInput.value);

          if (!fromMint || !toMint || isNaN(amount) || amount <= 0) {
            quoteDisplay.style.display = "none";
            return;
          }

          // Convert amount to lamports for SOL
          let amountLamports;
          if (fromMint === "So11111111111111111111111111111111111111112") {
            amountLamports = Math.floor(amount * 1000000000).toString();
          } else {
            // For other tokens, assume 6 decimals (like USDC)
            amountLamports = Math.floor(amount * 1000000).toString();
          }

          try {
            const res = await fetch(`${RELAYER_URL}/jupiter/quote`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                inputMint: fromMint,
                outputMint: toMint,
                amount: amountLamports,
                slippageBps: 50,
              }),
            });

            const data = await res.json();

            if (data && data.outAmount) {
              // Convert output amount to human readable
              let outputAmount;
              let outputSymbol;

              if (toMint === "So11111111111111111111111111111111111111112") {
                outputAmount = (parseInt(data.outAmount) / 1000000000).toFixed(
                  6
                );
                outputSymbol = "SOL";
              } else {
                outputAmount = (parseInt(data.outAmount) / 1000000).toFixed(6);
                outputSymbol =
                  toMint === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
                    ? "USDC"
                    : toMint === "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
                    ? "USDT"
                    : "Token";
              }

              quoteAmount.textContent = `${outputAmount} ${outputSymbol}`;

              // Calculate and show price impact if available
              if (data.priceImpactPct) {
                const priceImpact = parseFloat(data.priceImpactPct);
                if (priceImpact > 0.1) {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#ff6b6b";
                } else {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#51cf66";
                }
              } else {
                quotePrice.textContent = "";
              }

              quoteDisplay.style.display = "block";
            } else {
              quoteDisplay.style.display = "none";
            }
          } catch (e) {
            quoteDisplay.style.display = "none";
          }
        }

        async promptCustomSwap(tokenMint, tokenSymbol) {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }
          this.customSwapTokenMint = tokenMint;
          this.customSwapTokenSymbol = tokenSymbol;
          this.awaitingCustomSwapDirection = true;
          this.log(`Custom Swap: Choose direction:`, "info");
          this.log("1) SOL → " + tokenSymbol, "info");
          this.log("2) " + tokenSymbol + " → SOL", "info");
          this.log("Type 1 or 2:", "info");
        }

        async showSolanaSwapInterface() {
          this.log("🟣 Solana Swap Interface", "info");
          this.log("Loading popular tokens...", "info");

          try {
            // Create swap interface with searchable dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🟣 Solana Swap</h3>`;

            // From token selection with searchable dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="solanaFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="solanaFromTokenDisplay">🟣 SOL (Native)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="solanaFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
            html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
            html += `<input type="text" id="solanaFromSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;
            html += `<div id="solanaFromTokenList">`;
            // Default tokens
            html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>`;
            html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>`;
            html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>`;
            html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="solanaFromToken" value="So11111111111111111111111111111111111111112">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with searchable dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="solanaToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="solanaToTokenDisplay">💙 USDC (USD Coin)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="solanaToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 300px; overflow-y: auto; z-index: 1000;">`;
            html += `<div style="padding: 8px; border-bottom: 1px solid #333;">`;
            html += `<input type="text" id="solanaToSearch" placeholder="Search tokens..." style="width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;
            html += `<div id="solanaToTokenList">`;
            // Default tokens
            html += `<div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>`;
            html += `<div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>`;
            html += `<div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>`;
            html += `<div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>`;
            html += `</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="solanaToToken" value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="solanaAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Swap button
            html += `<button id="solanaSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #9945ff, #7c3aed); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🟣 Execute Solana Swap</button>`;

            // Quote display section
            html += `<div id="solanaQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
            html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
            html += `<div id="solanaQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
            html += `<div id="solanaQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupSolanaDropdowns();
              const swapBtn = document.getElementById("solanaSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeSolanaSwapFromInterface()
                );
              }

              // Fix input event handling and add quote functionality
              const amountInput = document.getElementById("solanaAmount");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) => {
                  e.stopPropagation();
                  this.updateSolanaQuote();
                });
              }

              // Add quote update on token changes
              const fromToken = document.getElementById("solanaFromToken");
              const toToken = document.getElementById("solanaToToken");
              if (fromToken)
                fromToken.addEventListener("change", () =>
                  this.updateSolanaQuote()
                );
              if (toToken)
                toToken.addEventListener("change", () =>
                  this.updateSolanaQuote()
                );
            }, 100);
          } catch (e) {
            this.log(
              `Failed to load Solana swap interface: ${e.message}`,
              "error"
            );
          }
        }

        async handleCustomSwapInput(amount, toMint) {
          this.awaitingCustomSwap = false;
          await this.executeSolanaSwap(amount, this.customSwapFromMint, toMint);
          this.customSwapFromMint = null;
          this.customSwapSymbol = null;
        }

        async handleDexScreenerCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: dexscreener <search|trending|pair> [query]",
              "info"
            );
            return;
          }
          const sub = args[1];
          if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching DexScreener for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (Array.isArray(data) && data.length > 0) {
                data.forEach((item, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${item.symbol || ""} (${
                      item.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(`Name: <b>${item.name || ""}</b>`, "output");
                  this.logHtml(
                    `Price: <b>${item.priceUsd || item.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      item.tokenAddress || ""
                    }')">${item.tokenAddress || ""}</span>`,
                    "output"
                  );
                  if (item.url)
                    this.logHtml(
                      `<a href="${item.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else if (data.pairs && Array.isArray(data.pairs)) {
                data.pairs.forEach((pair, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.baseToken?.symbol || ""} (${
                      pair.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Name: <b>${pair.baseToken?.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${pair.priceUsd || pair.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      pair.baseToken?.address || ""
                    }')">${pair.baseToken?.address || ""}</span>`,
                    "output"
                  );
                  if (pair.url)
                    this.logHtml(
                      `<a href="${pair.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("DexScreener search failed: " + e.message, "error");
            }
          } else if (sub === "trending") {
            this.log("Fetching DexScreener trending tokens...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/dex/trending`);
              const data = await res.json();
              if (Array.isArray(data) && data.length > 0) {
                data.forEach((item, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${item.symbol || ""} (${
                      item.chainId || ""
                    })</b>`,
                    "output"
                  );
                  this.logHtml(`Name: <b>${item.name || ""}</b>`, "output");
                  this.logHtml(
                    `Price: <b>${item.priceUsd || item.price || "N/A"}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${
                      item.tokenAddress || ""
                    }')">${item.tokenAddress || ""}</span>`,
                    "output"
                  );
                  if (item.url)
                    this.logHtml(
                      `<a href="${item.url}" target="_blank">View on DexScreener</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trending tokens found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("DexScreener trending failed: " + e.message, "error");
            }
          } else {
            this.log(
              "Usage: dexscreener <search|trending|pair> [query]",
              "info"
            );
          }
        }

        async handleGeckoTerminalCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: geckoterminal <search|trending|token> [network] [query]",
              "info"
            );
            return;
          }
          // Define show404Suggestion at the top so it is always in scope
          const show404Suggestion = (data) => {
            if (data && data.errors && Array.isArray(data.errors)) {
              const is404 = data.errors.some(
                (e) => e.status === "404" || e.title === "Not Found"
              );
              if (is404) {
                this.logHtml(
                  '<span style="color:#ff3333">Not Found. Try <b>cg networks</b> to see available networks and use the correct slug.</span>',
                  "error"
                );
              }
            }
          };
          const sub = args[1];
          if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching GeckoTerminal for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                data.data.forEach((item, idx) => {
                  const pair = item.attributes;
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `DEX: <b>${pair.dex_name || ""}</b> | Network: <b>${
                      pair.network || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Base: <b>${pair.base_token_symbol || ""}</b> | Quote: <b>${
                      pair.quote_token_symbol || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${
                      pair.price_usd || "N/A"
                    }</b> | Volume 24h: <b>${pair.volume_usd_24h || "N/A"}</b>`,
                    "output"
                  );
                  if (pair.gecko_terminal_url)
                    this.logHtml(
                      `<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
                this.logHtml(
                  '<span style="color:#cccccc">Tip: GeckoTerminal search only returns results for exact or popular pair names.</span>',
                  "info"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log("GeckoTerminal search failed: " + e.message, "error");
            }
          } else if (sub === "trending" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal trending tokens for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/trending`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                data.data.forEach((item, idx) => {
                  const pair = item.attributes;
                  this.logHtml(
                    `<b>${idx + 1}. ${pair.name || ""}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `DEX: <b>${pair.dex_name || ""}</b> | Network: <b>${
                      pair.network || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Base: <b>${pair.base_token_symbol || ""}</b> | Quote: <b>${
                      pair.quote_token_symbol || ""
                    }</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Price: <b>${
                      pair.price_usd || "N/A"
                    }</b> | Volume 24h: <b>${pair.volume_usd_24h || "N/A"}</b>`,
                    "output"
                  );
                  if (pair.gecko_terminal_url)
                    this.logHtml(
                      `<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                      "output"
                    );
                  this.logHtml("<hr>", "output");
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trending tokens found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log("GeckoTerminal trending failed: " + e.message, "error");
            }
          } else if (sub === "networks") {
            this.log("Fetching GeckoTerminal networks...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/gecko/networks`);
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml("<b>Available Networks:</b>", "output");
                data.data.forEach((item) => {
                  const net = item.attributes;
                  const id = item.id;
                  const cg = net.coingecko_asset_platform_id
                    ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>`
                    : "";
                  this.logHtml(
                    `<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No networks found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log(
                "GeckoTerminal networks fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "dexes" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal dexes for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/dexes`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>DEXes for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const dex = item.attributes;
                  const id = item.id;
                  this.logHtml(
                    `<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No DEXes found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal dexes fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "pools" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal pools for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>Pools for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal pools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "token" && args[2] && args[3]) {
            const network = args[2];
            const address = args[3];
            this.log(
              `Fetching GeckoTerminal token info for network: ${network}, address: ${address}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const token = data.data.attributes;
                this.logHtml(
                  `<b>${token.name} (${token.symbol})</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${token.price_usd || "N/A"}</b> | TVL: <b>${
                    token.tvl_usd || "N/A"
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `DEX Count: <b>${
                    token.dex_count || "N/A"
                  }</b> | Pool Count: <b>${token.pool_count || "N/A"}</b>`,
                  "output"
                );
                if (token.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No token info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal token fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "tokenpools" && args[2] && args[3]) {
            const network = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Pools for token ${tokenAddress} on ${network}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found for this token.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal tokenpools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "poolinfo" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const pool = data.data.attributes;
                this.logHtml(
                  `<b>${pool.name}</b> | DEX: <b>${
                    pool.dex_name
                  }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                  "output"
                );
                this.logHtml(
                  `Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${pool.price_usd || "N/A"}</b> | Volume 24h: <b>${
                    pool.volume_usd_24h || "N/A"
                  }</b>`,
                  "output"
                );
                if (pool.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pool info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal poolinfo fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "ohlcv" && args[2] && args[3] && args[4]) {
            const network = args[2];
            const poolAddress = args[3];
            const timeframe = args[4];
            this.log(
              `Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  this.logHtml(
                    `<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No OHLCV data found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal ohlcv fetch failed: " + e.message,
                "error"
              );
            }
          } else if (sub === "trades" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Recent trades for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.slice(0, 10).forEach((item) => {
                  const trade = item.attributes;
                  this.logHtml(
                    `<b>${trade.timestamp}</b>: <b>${
                      trade.amount_usd || "N/A"
                    } USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${
                      trade.price_usd || "N/A"
                    }</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trades found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal trades fetch failed: " + e.message,
                "error"
              );
            }
          } else {
            this.log(
              "Usage: geckoterminal <search|trending|token> [network] [query]",
              "info"
            );
          }
        }

        async handleStockCommand(args) {
          if (!args[1]) {
            this.log(
              "Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]",
              "info"
            );
            return;
          }
          const sub = args[1];
          if (sub === "quote" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching stock quote for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/quote/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data.price) {
                this.logHtml(`<b>${symbol} Stock Quote</b>`, "output");
                this.logHtml(`Price: <b>${data.price}</b>`, "output");
                this.logHtml(
                  `Change: <b>${data.change}</b> (${data.changePercent})`,
                  "output"
                );
                this.logHtml(
                  `Open: <b>${data["02. open"] || ""}</b> | High: <b>${
                    data["03. high"] || ""
                  }</b> | Low: <b>${data["04. low"] || ""}</b>`,
                  "output"
                );
                this.logHtml(
                  `Volume: <b>${
                    data["06. volume"] || ""
                  }</b> | Previous Close: <b>${
                    data["08. previous close"] || ""
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `Latest Trading Day: <b>${
                    data["07. latest trading day"] || ""
                  }</b>`,
                  "output"
                );
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No quote found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock quote failed: " + e.message, "error");
            }
          } else if (sub === "search" && args[2]) {
            const q = args.slice(2).join(" ");
            this.log(`Searching stocks for: ${q}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/search?q=${encodeURIComponent(q)}`
              );
              const data = await res.json();
              if (
                data &&
                data.bestMatches &&
                Array.isArray(data.bestMatches) &&
                data.bestMatches.length > 0
              ) {
                data.bestMatches.forEach((match, idx) => {
                  this.logHtml(
                    `<b>${idx + 1}. ${match["2. name"]} (${
                      match["1. symbol"]
                    })</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Type: <b>${match["3. type"]}</b> | Region: <b>${match["4. region"]}</b>`,
                    "output"
                  );
                  this.logHtml(
                    `Currency: <b>${match["8. currency"]}</b> | Match Score: <b>${match["9. matchScore"]}</b>`,
                    "output"
                  );
                  this.logHtml("<hr>", "output");
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No results found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock search failed: " + e.message, "error");
            }
          } else if (sub === "daily" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching daily stock data for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/daily/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data["Time Series (Daily)"]) {
                const series = data["Time Series (Daily)"];
                const dates = Object.keys(series).slice(0, 5); // Show last 5 days
                this.logHtml(`<b>${symbol} - Last 5 Days</b>`, "output");
                dates.forEach((date) => {
                  const d = series[date];
                  this.logHtml(
                    `<b>${date}</b>: Open: <b>${d["1. open"]}</b>, High: <b>${d["2. high"]}</b>, Low: <b>${d["3. low"]}</b>, Close: <b>${d["4. close"]}</b>, Volume: <b>${d["5. volume"]}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No daily data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock daily failed: " + e.message, "error");
            }
          } else if (sub === "overview" && args[2]) {
            const symbol = args[2];
            this.log(`Fetching stock overview for: ${symbol}`, "info");
            try {
              const res = await fetch(
                `${RELAYER_URL}/stock/overview/${encodeURIComponent(symbol)}`
              );
              const data = await res.json();
              if (data && data.Symbol) {
                this.logHtml(`<b>${data.Name} (${data.Symbol})</b>`, "output");
                this.logHtml(
                  `Sector: <b>${data.Sector}</b> | Industry: <b>${data.Industry}</b>`,
                  "output"
                );
                this.logHtml(
                  `Market Cap: <b>${data.MarketCapitalization}</b> | EPS: <b>${data.EPS}</b>`,
                  "output"
                );
                this.logHtml(
                  `PE Ratio: <b>${data.PERatio}</b> | Dividend Yield: <b>${data.DividendYield}</b>`,
                  "output"
                );
                this.logHtml(
                  `Description: <span style='color:#cccccc'>${data.Description}</span>`,
                  "output"
                );
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No overview found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Stock overview failed: " + e.message, "error");
            }
          } else if (sub === "inflation") {
            this.log("Fetching US inflation data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/inflation`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US Inflation (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No inflation data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("Inflation fetch failed: " + e.message, "error");
            }
          } else if (sub === "cpi") {
            this.log("Fetching US CPI data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/cpi`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US CPI (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No CPI data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("CPI fetch failed: " + e.message, "error");
            }
          } else if (sub === "gdp") {
            this.log("Fetching US GDP data...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/stock/gdp`);
              const data = await res.json();
              if (data && data.data && Array.isArray(data.data)) {
                this.logHtml("<b>US Real GDP (last 5 years):</b>", "output");
                data.data.slice(-5).forEach((item) => {
                  this.logHtml(
                    `<b>${item.date}</b>: <b>${item.value}</b>`,
                    "output"
                  );
                });
              } else if (data && data.error) {
                this.logHtml(
                  `<span style='color:#ff3333'>${data.error}</span>`,
                  "error"
                );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No GDP data found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log("GDP fetch failed: " + e.message, "error");
            }
          } else {
            this.log(
              "Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]",
              "info"
            );
          }
        }

        async handleAlphaKeyCommand(args) {
          this.log(
            "Alpha Vantage API key is managed by the relayer. No action needed.",
            "info"
          );
        }

        async showUnifiedHelp() {
          this.logHtml(
            '<span style="color:#33bbff">=== Ω Terminal v2.0.1 Commands ===</span>',
            "info"
          );

          // NEW FEATURES SECTION (Highlighted)
          this.log("🆕 --- NEW FEATURES (v2.0.1) ----", "success");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#FF6B6B">🍎 Modern UI:</span><br>' +
              '<span style="color:#99ccff">modern ui | modern-dark</span><br>' +
              '<span style="color:#888888">Apple-style glass-morphism</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#4ECDC4">📊 DexScreener Analytics:</span><br>' +
              '<span style="color:#99ccff">dexscreener search | analytics | portfolio | watchlist</span><br>' +
              '<span style="color:#888888">Complete token analysis suite</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#45B7D1">🦙 DeFi Llama:</span><br>' +
              '<span style="color:#99ccff">defillama tvl | protocols | price | chains</span><br>' +
              '<span style="color:#888888">TVL & price data</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#FF9500">🎮 Games & Fun:</span><br>' +
              '<span style="color:#99ccff">games | arcade | flappy | mystery-box</span><br>' +
              '<span style="color:#888888">Entertainment & challenges</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:33%;padding-right:16px;">' +
              '<span style="color:#FF6B35">🎯 PGT Portfolio:</span><br>' +
              '<span style="color:#99ccff">pgt track &lt;address&gt; | pgt portfolio | pgt wallets</span><br>' +
              '<span style="color:#888888">Auto-detect network, real-time tracking</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;padding-right:16px;">' +
              '<span style="color:#8B5CF6">🏗️ Terminal Builder:</span><br>' +
              '<span style="color:#99ccff">terminal create | list | launch</span><br>' +
              '<span style="color:#888888">Create custom terminals with URLs</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;">' +
              '<span style="color:#F59E0B">🎮 Games:</span><br>' +
              '<span style="color:#99ccff">game list | play snake | play pacman</span><br>' +
              '<span style="color:#888888">Interactive popup games</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:50%;padding-right:16px;">' +
              '<span style="color:#96CEB4">🔵 NEAR Wallet:</span><br>' +
              '<span style="color:#99ccff">near connect | balance | swap</span><br>' +
              '<span style="color:#888888">NEAR ecosystem integration</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:50%;">' +
              '<span style="color:#FF6B6B">🍎 Modern UI:</span><br>' +
              '<span style="color:#99ccff">modern ui | modern-dark</span><br>' +
              '<span style="color:#888888">Apple-style glass-morphism</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#8A2BE2">🌊 OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search | collection | floor | trending | portfolio</span><br>' +
              '<span style="color:#888888">Professional NFT analytics & trading</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">• Search collections • Floor price tracking • Portfolio management</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#FF6B35">🏛️ Omega Network:</span><br>' +
              '<span style="color:#99ccff">omega mint | omega collection</span><br>' +
              '<span style="color:#888888">Mint NFTs on Omega Network</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">• Upload images • Add metadata • Mint on Omega Network</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // CORE FUNCTIONALITY
          this.log("--- Core Wallet Functions ----", "output");
          this.logHtml(
            '<span style="color:#33bbff">Commands: connect | disconnect | balance | faucet | send | network | forceadd | rpccheck</span>',
            "info"
          );
          this.log("--- AI Assistant ----", "output");
          this.logHtml(
            '<span style="color:#33bbff">AI Mode: ai</span> - Toggle AI assistant to answer questions and execute commands naturally',
            "info"
          );
          this.log("--- Mining & Rewards ---", "output");
          this.logHtml(
            '<span style="color:#33bbff">Commands: mine | claim | status | stats</span>',
            "info"
          );

          // THEME SYSTEM (Updated)
          this.log("🎨 --- Themes & Interface ----", "output");
          this.logHtml(
            '<span style="color:#33bbff">Themes: modern ui | modern-dark | dark | matrix | retro | bitcoin | ethereum | solana | pepe</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#33bbff">GUI Modes: gui [ios, chatgpt, discord, aol, windows95, limewire]</span>',
            "info"
          );

          // ANALYTICS & DATA
          this.log("📊 --- Analytics & Data ----", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">DexScreener:</span><br>' +
              '<span style="color:#99ccff">dexscreener search BONK</span><br>' +
              '<span style="color:#99ccff">dexscreener analytics ETH</span><br>' +
              '<span style="color:#99ccff">dexscreener portfolio</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">DeFi Llama:</span><br>' +
              '<span style="color:#99ccff">defillama tvl</span><br>' +
              '<span style="color:#99ccff">defillama price ethereum</span><br>' +
              '<span style="color:#99ccff">defillama protocols</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:12px;">' +
              '<span style="color:#33bbff">OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search azuki</span><br>' +
              '<span style="color:#99ccff">nft floor bayc</span><br>' +
              '<span style="color:#99ccff">nft trending</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#33bbff">GeckoTerminal:</span><br>' +
              '<span style="color:#99ccff">cg help</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // BLOCKCHAIN INTEGRATIONS
          this.log("--- Blockchain Networks ---", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Solana:</span><br>' +
              '<span style="color:#99ccff">solana help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Eclipse:</span><br>' +
              '<span style="color:#99ccff">eclipse help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">NEAR:</span><br>' +
              '<span style="color:#99ccff">near connect | near help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;padding-right:16px;">' +
              '<span style="color:#33bbff">Hyperliquid:</span><br>' +
              '<span style="color:#99ccff">hyperliquid help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:20%;">' +
              '<span style="color:#33bbff">OpenSea NFTs:</span><br>' +
              '<span style="color:#99ccff">nft search | nft trending | nft portfolio</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // ADVANCED FEATURES
          this.log("--- Advanced Features ---", "output");
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Mixer (Privacy):</span><br>' +
              '<span style="color:#99ccff">mixer help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Ambassador:</span><br>' +
              '<span style="color:#99ccff">ambassador help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Polymarket:</span><br>' +
              '<span style="color:#99ccff">polymarket help</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:25%;">' +
              '<span style="color:#9B59B6">🎮 Games:</span><br>' +
              '<span style="color:#99ccff">game list | play <game></span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );
          this.logHtml(
            '<table style="width:100%;border:none;"><tr>' +
              '<td style="vertical-align:top;width:25%;padding-right:16px;">' +
              '<span style="color:#33bbff">Email:</span><br>' +
              '<span style="color:#99ccff">email | inbox</span>' +
              "</td>" +
              '<td style="vertical-align:top;width:75%;">' +
              '<span style="color:#888888">Encrypted messaging system</span>' +
              "</td>" +
              "</tr></table>",
            "output"
          );

          // QUICK START GUIDE
          this.log("🚀 --- Quick Start Guide ----", "info");
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#FF6B6B">modern ui</span> for beautiful Apple-style interface</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#4ECDC4">dexscreener search BONK</span> for token analysis</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#45B7D1">defillama tvl</span> for DeFi data</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#8A2BE2">nft trending</span> for hot NFT collections</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#FF6B35">pgt portfolio</span> for multi-chain portfolio tracking</span>',
            "info"
          );
          this.logHtml(
            '<span style="color:#FFE66D">💡 Try: <span style="color:#9B59B6">game list</span> for interactive games</span>',
            "info"
          );

          this.log("--- Economy & Trading ---", "output");
          this.logHtml(
            '<span style="color:#33bbff">alpha help</span> <span style="color:#888888">stocks & economy data</span>',
            "info"
          );
          this.log("---", "output");

          // Footer with version
          this.logHtml(
            '<span style="color:#888888">Ω Terminal v2.0.1 - Modern Apple UI • Enhanced Analytics • DeFi Integration • NFT Trading</span>',
            "info"
          );
        }

        async mine() {
          if (this.isMining) {
            this.log(
              'Mining is already running. Use "stop" to end mining.',
              "warning"
            );
            return;
          }
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          this.isMining = true;
          this.log(
            '⛏️ Automated mining started! Use "stop" to end mining.',
            "info"
          );
          this.log(
            "💰 IMPROVED REWARDS: 80% chance of earning OMEGA tokens!",
            "success"
          );
          this.log(
            "🎯 Possible rewards: 0.001-1.0 OMEGA per successful mine",
            "info"
          );
          const miningAnimationFrames = ["⛏️", "🔨", "🪓", "⛏️", "🔨", "🪓"];
          let frame = 0;
          const mineLoop = async () => {
            if (!this.isMining) return;
            try {
              const address = await this.signer.getAddress();
              // Show mining animation with cool steps
              let animSteps = [
                { icon: "🔍", text: "Verifying nonce..." },
                { icon: "🔗", text: "Connecting to Omega miners..." },
                { icon: "💾", text: "Loading mining algorithm..." },
                {
                  icon: "🔒",
                  text: () => {
                    const lockFrames = ["/", "-", "\\", "|"];
                    let lockFrame =
                      lockFrames[Math.floor(Math.random() * lockFrames.length)];
                    const fakeHash =
                      this.generateFakeHash().slice(0, 32) + "...";
                    return `[${lockFrame}] Hash: ${fakeHash}`;
                  },
                },
                { icon: "⚡", text: "Crunching numbers..." },
                { icon: "🧮", text: "Calculating reward probability..." },
              ];
              for (let step of animSteps) {
                let line = document.createElement("div");
                line.className = "output info";
                line.textContent =
                  typeof step.text === "function"
                    ? `${step.icon} ${step.text()}`
                    : `${step.icon} ${step.text}`;
                document.getElementById("terminalContent").appendChild(line);
                document.getElementById("terminalContent").scrollTop =
                  document.getElementById("terminalContent").scrollHeight;
                await new Promise((r) => setTimeout(r, 200));
              }
              // Send mining request
              this.log("⛏️ Sending mining request to network...", "info");
              const res = await fetch(RELAYER_URL + "/mine", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ address }),
              });
              const data = await res.json();
              if (!data.success) {
                this.log("⛏️  Block mined (no reward this time)", "output");
              } else {
                this.logHtml(
                  `📤 Mining tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`,
                  "info"
                );
                if (data.reward && data.reward > 0) {
                  this.totalEarned += parseFloat(data.reward);
                  this.log(
                    `💰 Mining reward: +${data.reward} OMEGA`,
                    "success"
                  );
                  this.log(
                    `🏆 Session total: ${this.totalEarned.toFixed(4)} OMEGA`,
                    "info"
                  );
                  this.log(
                    '💡 Use "claim" to withdraw your rewards!',
                    "success"
                  );
                } else {
                  this.log("⛏️  Block mined (no reward this time)", "output");
                }
              }
            } catch (error) {
              // Handle mining failures gracefully - just show no block mined
              this.log("⛏️  Block mined (no reward this time)", "output");
            }
            if (this.isMining) {
              setTimeout(mineLoop, 8000); // Faster mining - 8 seconds instead of 15
            }
          };
          mineLoop();
        }

        async startAutomatedMiningLoop() {
          const mineNextBlock = async () => {
            if (!this.isMining) return;

            try {
              this.mineCount++;
              const nonce = this.miningNonce;
              this.miningNonce++;
              const solution = this.generateRandomSolution();
              this.log(`⛏️  Mining block #${this.mineCount}...`, "info");
              this.log(`🎯 Nonce: ${nonce}`, "output");
              // --- Begin hashing animation ---
              const spinnerFrames = ["|", "/", "-", "\\"];
              let spinnerIndex = 0;
              for (let i = 0; i < 6; i++) {
                // Reduced from 10 to 6 iterations
                await new Promise((resolve) => setTimeout(resolve, 50)); // Faster animation - 50ms instead of 80ms
                this.log(
                  `🔒 [${
                    spinnerFrames[spinnerIndex]
                  }] Hashing: ${this.generateFakeHash()}`,
                  "output"
                );
                spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
              }
              // --- End hashing animation ---
              this.log(`🔑 Solution: ${solution.slice(0, 16)}...`, "output");
              const tx = await this.contract
                .connect(this.miningWallet)
                .mineBlock(nonce, solution, {
                  gasLimit: 200000,
                  gasPrice: await this.provider.getGasPrice(),
                });
              this.logHtml(
                `📤 Transaction sent: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))">${tx.hash}</span>`,
                "info"
              );
              const receipt = await tx.wait();
              if (receipt.status === 1) {
                try {
                  const minerInfo = await this.contract.getMinerInfo(
                    this.miningWallet.address
                  );
                  const pendingRewards = minerInfo[2];
                  const rewardInWei = pendingRewards;
                  const rewardInEther =
                    this.ethers.utils.formatEther(rewardInWei);
                  if (rewardInWei.gt(0)) {
                    this.totalEarned += parseFloat(rewardInEther);
                    this.log(
                      `💰 Mining reward: +${rewardInEther} OMEGA`,
                      "success"
                    );
                    this.log(
                      `💳 Total earned this session: ${this.totalEarned.toFixed(
                        6
                      )} OMEGA`,
                      "info"
                    );
                  } else {
                    this.log(`⛏️  Block mined (no reward this time)`, "output");
                  }
                } catch (error) {
                  this.log(
                    `⚠️ Could not fetch reward info: ${error.message}`,
                    "warning"
                  );
                  const simulatedReward = this.calculateMiningReward();
                  if (simulatedReward > 0) {
                    this.totalEarned += simulatedReward;
                    this.log(
                      `💰 Mining reward: +${simulatedReward.toFixed(
                        6
                      )} OMEGA (simulated)`,
                      "success"
                    );
                    this.log(
                      `💳 Total earned this session: ${this.totalEarned.toFixed(
                        6
                      )} OMEGA`,
                      "info"
                    );
                  } else {
                    this.log(`⛏️  Block mined (no reward this time)`, "output");
                  }
                }
              } else {
                this.log(`⛏️  Block mined (no reward this time)`, "output");
              }
            } catch (error) {
              // Handle mining failures gracefully - just show no block mined
              this.log("⛏️  Block mined (no reward this time)", "output");

              // Still handle nonce issues silently
              if (
                error.message &&
                (error.message.includes("nonce") ||
                  error.message.includes("replacement"))
              ) {
                this.miningNonce = await this.provider.getTransactionCount(
                  this.miningWallet.address,
                  "latest"
                );
              }
            }
            if (this.isMining) setTimeout(mineNextBlock, 8000); // Faster mining - 8 seconds instead of 15
          };
          mineNextBlock();
        }

        generateRandomSolution() {
          const chars = "0123456789abcdef";
          let solution = "0x";
          for (let i = 0; i < 64; i++) {
            solution += chars[Math.floor(Math.random() * chars.length)];
          }
          return solution;
        }

        calculateMiningReward() {
          const random = Math.random();

          // IMPROVED: Much better reward distribution for user engagement
          // 5% chance for big reward (0.5-1.0 OMEGA)
          if (random < 0.05) {
            return parseFloat((Math.random() * 0.5 + 0.5).toFixed(4));
          }
          // 15% chance for good reward (0.1-0.5 OMEGA)
          else if (random < 0.2) {
            return parseFloat((Math.random() * 0.4 + 0.1).toFixed(4));
          }
          // 25% chance for medium reward (0.01-0.1 OMEGA)
          else if (random < 0.45) {
            return parseFloat((Math.random() * 0.09 + 0.01).toFixed(4));
          }
          // 35% chance for small reward (0.001-0.01 OMEGA)
          else if (random < 0.8) {
            return parseFloat((Math.random() * 0.009 + 0.001).toFixed(4));
          }
          // 20% chance for no reward (reduced from 60%)
          else {
            return 0;
          }
        }

        generateFakeHash() {
          const chars = "0123456789abcdef";
          let hash = "0x";
          for (let i = 0; i < 64; i++) {
            hash += chars[Math.floor(Math.random() * chars.length)];
          }
          return hash;
        }

        // Add missing methods that are referenced in the code
        logCommand(command) {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = "terminal-line";
          line.innerHTML = `<span class="prompt">Ω Terminal:~$</span><span class="command"> ${command}</span>`;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab) tab.history.push({ type: "command", content: command });
        }

        log(message, type = "output") {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = `output ${type}`;
          line.textContent = message;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab)
            tab.history.push({
              type: "output",
              content: message,
              logType: type,
            });
        }

        logHtml(html, type = "output") {
          const terminalContent = document.getElementById("terminalContent");
          const line = document.createElement("div");
          line.className = `terminal-line ${type}`;
          line.innerHTML = html;
          terminalContent.appendChild(line);
          terminalContent.scrollTop = terminalContent.scrollHeight;
          // Store in tab history
          const tab = this.tabs[this.activeTab];
          if (tab)
            tab.history.push({ type: "output", content: html, logType: type });
          // Also push to chatHistory for AI context (clean text only)
          if (this.chatHistory) {
            // Remove HTML tags for chatHistory output
            const cleanText = html
              .replace(/<[^>]*>/g, "")
              .replace(/\s+/g, " ")
              .trim();
            this.chatHistory.push({
              type: "result",
              output: cleanText,
              logType: type,
            });
          }
        }

        getTextWidth(text, font) {
          const canvas =
            this.canvas || (this.canvas = document.createElement("canvas"));
          const context = canvas.getContext("2d");
          context.font = font;
          const metrics = context.measureText(text);
          return metrics.width;
        }

        clearTerminal() {
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
        }

        updateConnectionStatus(status) {
          const statusElement = document.getElementById("connectionStatus");
          if (statusElement) {
            statusElement.textContent = status;
          }
        }

        // Replace old showHelp with unified version
        showHelp() {
          this.log("╔════════════════════════════════════════╗", "info");
          this.log("║     OMEGA TERMINAL - COMMAND LIST     ║", "success");
          this.log("╚════════════════════════════════════════╝", "info");
          this.log("", "output");

          this.log("🎯 PREDICTION MARKETS", "info");
          this.log(
            "  polymarket | poly      Polymarket prediction markets",
            "output"
          );
          this.log(
            "  kalshi                 Kalshi prediction markets",
            "output"
          );
          this.log("", "output");

          this.log("💼 PORTFOLIO & WALLETS", "info");
          this.log(
            "  pgt                    Track wallet portfolios",
            "output"
          );
          this.log("  wallet                 Wallet management", "output");
          this.log("  connect                Connect wallets", "output");
          this.log("", "output");

          this.log("🎮 FEATURES & TOOLS", "info");
          this.log(
            "  profile                User profile & API keys",
            "output"
          );
          this.log(
            "  perps                  Perpetuals trading data",
            "output"
          );
          this.log("  news                   Crypto news feed", "output");
          this.log("  nft                    NFT marketplace data", "output");
          this.log("  game                   Play terminal games", "output");
          this.log("  spotify                Spotify player", "output");
          this.log("  youtube | yt           YouTube player", "output");
          this.log("", "output");

          this.log("🔗 NETWORKS & CHAINS", "info");
          this.log("  rome | romechain       Rome Protocol", "output");
          this.log("  monad                  Monad network", "output");
          this.log("  near                   NEAR Protocol", "output");
          this.log("  eclipse                Eclipse network", "output");
          this.log("", "output");

          this.log("📊 DATA & ANALYTICS", "info");
          this.log("  dex | dexscreener      DEX analytics", "output");
          this.log("  defillama | llama      DeFi analytics", "output");
          this.log("  crypto                 Crypto data", "output");
          this.log("", "output");

          this.log("⚙️  SYSTEM", "info");
          this.log("  clear | cls            Clear terminal", "output");
          this.log("  theme                  Change theme", "output");
          this.log("  gui                    Switch to GUI mode", "output");
          this.log("  help | ?               Show this help", "output");
          this.log("", "output");

          this.log("💡 TIP: Type any command name for detailed help", "info");
        }

        detectNetworkFromAddress(address) {
          // Auto-detect network from address format
          if (address.startsWith("0x") && address.length === 42) {
            return "ethereum";
          } else if (
            address.length >= 32 &&
            address.length <= 44 &&
            /^[1-9A-HJ-NP-Za-km-z]+$/.test(address)
          ) {
            return "solana";
          } else if (
            address.includes(".near") ||
            (address.length >= 2 &&
              address.length <= 64 &&
              /^[a-z0-9_-]+$/.test(address))
          ) {
            return "near";
          } else if (address.startsWith("bnb") || address.startsWith("0x")) {
            return "bsc";
          }
          return "ethereum"; // Default
        }

        async handlePGTCommand(args) {
          console.log("🔍 handlePGTCommand called with args:", args);
          console.log("🔍 window.PGT exists:", !!window.PGT);
          console.log("🔍 window.PGT.ready:", window.PGT?.ready);

          if (!window.PGT) {
            this.log(
              "⚠️ PGT integration is loading... Please wait a moment and try again.",
              "warning"
            );
            return;
          }

          if (!window.PGT.ready) {
            this.log(
              "⚠️ PGT API is initializing... Please wait a few seconds.",
              "warning"
            );
            return;
          }

          // args[0] is the main command "pgt", args[1] is the subcommand
          const subCmd = args[1] ? args[1].toLowerCase() : "help";

          console.log("🎯 PGT Command Debug:");
          console.log("   Full args:", args);
          console.log("   SubCommand (args[1]):", subCmd);
          console.log("   Address (args[2]):", args[2]);
          console.log("   Network (args[3]):", args[3]);

          try {
            switch (subCmd) {
              case "track":
              case "add":
                // args[2] is the address, args[3] is optional network
                const trackAddr = args[2];
                let trackNet = args[3];

                if (!trackAddr) {
                  this.log("Usage: pgt track <address> [network]", "error");
                  this.log(
                    "Example: pgt track 0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6",
                    "info"
                  );
                  this.log(
                    "Network is auto-detected from address format",
                    "info"
                  );
                  return;
                }

                // Auto-detect network if not provided
                if (!trackNet) {
                  trackNet = this.detectNetworkFromAddress(trackAddr);
                  this.log(`🔍 Auto-detected network: ${trackNet}`, "info");
                }

                this.log(
                  `📡 Tracking wallet: ${trackAddr.slice(0, 10)}...`,
                  "info"
                );
                this.log(`⏳ Fetching blockchain data...`, "info");

                const result = await window.PGT.addWallet(trackAddr, trackNet);

                if (result.success) {
                  this.log("═══════════════════════════════════════", "info");
                  this.log(`✅ Wallet tracked successfully!`, "success");
                  this.log(`Address: ${trackAddr}`, "info");
                  this.log(`Network: ${trackNet}`, "info");

                  // Show wallet value from response
                  if (result.data && result.data.wallet) {
                    const wallet = result.data.wallet;

                    this.log("", "info");
                    this.log("📊 Wallet Data:", "info");

                    if (
                      wallet.totalValue !== undefined &&
                      wallet.totalValue > 0
                    ) {
                      const valueFormatted = wallet.totalValue.toLocaleString(
                        "en-US",
                        {
                          style: "currency",
                          currency: "USD",
                          minimumFractionDigits: 2,
                        }
                      );
                      this.log(
                        `   Portfolio Value: ${valueFormatted}`,
                        "success"
                      );

                      if (wallet.change24hPercent !== undefined) {
                        const changeText = `${
                          wallet.change24hPercent >= 0 ? "+" : ""
                        }${wallet.change24hPercent.toFixed(2)}%`;
                        this.log(
                          `   24h Change: ${changeText}`,
                          wallet.change24hPercent >= 0 ? "success" : "error"
                        );
                      }

                      // Show detailed token breakdown
                      if (wallet.tokens && wallet.tokens.length > 0) {
                        this.log("", "info");
                        this.log("   💎 Assets Held:", "info");
                        wallet.tokens.forEach((token) => {
                          const tokenBalance = token.balance || 0;
                          const tokenValue = token.value || 0;
                          const tokenPrice = token.price || 0;

                          if (tokenValue > 0.01) {
                            // Only show valuable assets
                            const balanceStr = tokenBalance.toFixed(4);
                            const valueStr = tokenValue.toLocaleString(
                              "en-US",
                              {
                                style: "currency",
                                currency: "USD",
                                minimumFractionDigits: 2,
                              }
                            );
                            const priceStr = tokenPrice.toLocaleString(
                              "en-US",
                              {
                                style: "currency",
                                currency: "USD",
                                minimumFractionDigits: 2,
                              }
                            );

                            this.log(
                              `      • ${token.symbol}: ${balanceStr} tokens`,
                              "info"
                            );
                            this.log(
                              `        Value: ${valueStr} (@ ${priceStr} each)`,
                              "info"
                            );
                          }
                        });
                      }
                    } else {
                      this.log(
                        `   Value: $0.00 (Empty wallet or blockchain fetch failed)`,
                        "warning"
                      );
                    }
                  }

                  this.log("═══════════════════════════════════════", "info");
                  this.log(
                    "💡 Tip: Use 'pgt portfolio' to see full details",
                    "info"
                  );
                  this.log(
                    "💡 Right panel updates automatically every 30 seconds",
                    "info"
                  );
                } else {
                  this.log(`❌ Error: ${result.error}`, "error");
                }
                break;

              case "portfolio":
              case "p":
                this.log("📊 Fetching portfolio data...", "info");
                const portfolio = await window.PGT.getPortfolio();

                if (portfolio.success && portfolio.data) {
                  const {
                    totalValue,
                    totalChange24hPercent,
                    walletCount,
                    wallets,
                  } = portfolio.data;

                  if (walletCount === 0) {
                    this.log("═══════════════════════════════════════", "info");
                    this.log("No wallets tracked yet.", "warning");
                    this.log("═══════════════════════════════════════", "info");
                    this.log("", "info");
                    this.log("💡 To start tracking:", "info");
                    this.log("   pgt track <address>", "info");
                    this.log("", "info");
                    this.log("Example:", "info");
                    this.log(
                      "   pgt track 0xBB07d617cF64A64F96b29f3f3B65cd741C2C51FC",
                      "info"
                    );
                    this.log("", "info");
                    this.log(
                      "Network is automatically detected! 🎯",
                      "success"
                    );
                    return;
                  }

                  this.log("╔═══════════════════════════════════════╗", "info");
                  this.log(
                    "║        PGT PORTFOLIO SUMMARY          ║",
                    "success"
                  );
                  this.log("╚═══════════════════════════════════════╝", "info");
                  this.log("", "info");
                  this.log(
                    `Total Value: $${totalValue.toLocaleString("en-US", {
                      minimumFractionDigits: 2,
                    })}`,
                    "info"
                  );
                  this.log(
                    `24h Change: ${
                      totalChange24hPercent >= 0 ? "+" : ""
                    }${totalChange24hPercent.toFixed(2)}%`,
                    totalChange24hPercent >= 0 ? "success" : "error"
                  );
                  this.log(`Wallets: ${walletCount}`, "info");
                  this.log("", "info");

                  if (wallets && wallets.length > 0) {
                    this.log("", "info");
                    this.log("═══════════════════════════════════════", "info");
                    this.log("TRACKED WALLETS", "success");
                    this.log("═══════════════════════════════════════", "info");

                    wallets.forEach((w, i) => {
                      this.log("", "info");
                      this.log(
                        `${i + 1}. ${
                          w.label || w.address.slice(0, 10) + "..."
                        }`,
                        "info"
                      );
                      this.log(
                        `   Network: ${w.network.toUpperCase()}`,
                        "info"
                      );
                      this.log(`   Address: ${w.address}`, "info");
                      this.log(
                        `   Portfolio Value: $${w.totalValue.toLocaleString(
                          "en-US",
                          { minimumFractionDigits: 2 }
                        )}`,
                        "success"
                      );
                      this.log(
                        `   24h Change: ${
                          w.change24hPercent >= 0 ? "+" : ""
                        }${w.change24hPercent.toFixed(2)}%`,
                        w.change24hPercent >= 0 ? "success" : "error"
                      );

                      // Show token breakdown if available
                      if (w.tokens && w.tokens.length > 0) {
                        this.log("   Assets:", "info");
                        w.tokens.forEach((token) => {
                          const tokenValue = token.value || 0;
                          const tokenBalance = token.balance || 0;
                          if (tokenValue > 0.01) {
                            // Only show tokens worth more than $0.01
                            this.log(
                              `      • ${token.symbol}: ${tokenBalance.toFixed(
                                4
                              )} ($${tokenValue.toLocaleString("en-US", {
                                minimumFractionDigits: 2,
                              })})`,
                              "info"
                            );
                          }
                        });
                      }

                      this.log(
                        `   Last Updated: ${new Date(
                          w.lastUpdated
                        ).toLocaleTimeString()}`,
                        "info"
                      );
                    });

                    this.log("", "info");
                    this.log("═══════════════════════════════════════", "info");
                  }
                } else {
                  this.log(
                    `❌ Error: ${
                      portfolio.error || "Failed to fetch portfolio"
                    }`,
                    "error"
                  );
                  this.log("", "info");
                  this.log("💡 Try tracking a wallet first:", "info");
                  this.log(
                    "   pgt track 0xBB07d617cF64A64F96b29f3f3B65cd741C2C51FC",
                    "info"
                  );
                }
                break;

              case "refresh":
                this.log("🔄 Refreshing portfolio data...", "info");
                await window.PGT.refreshPortfolioStats();
                this.log(
                  "✅ Portfolio stats refreshed! Check the right panel.",
                  "success"
                );
                break;

              case "wallets":
              case "list":
                const walletsList = await window.PGT.getWallets();

                if (
                  walletsList.success &&
                  walletsList.data &&
                  walletsList.data.length > 0
                ) {
                  this.log("═══════════════════════════════════════", "info");
                  this.log("Tracked Wallets:", "success");
                  this.log("═══════════════════════════════════════", "info");
                  walletsList.data.forEach((w, i) => {
                    this.log(`${i + 1}. ${w.label || w.address}`, "info");
                    this.log(`   Network: ${w.network}`, "info");
                    this.log(`   Address: ${w.address}`, "info");
                    this.log("", "info");
                  });
                } else if (
                  walletsList.success &&
                  walletsList.data &&
                  walletsList.data.length === 0
                ) {
                  this.log("No wallets tracked yet.", "warning");
                  this.log("Use: pgt track <address>", "info");
                  this.log(
                    "Network is automatically detected from address format",
                    "info"
                  );
                } else {
                  this.log(
                    `❌ Error: ${
                      walletsList.error || "Failed to fetch wallets"
                    }`,
                    "error"
                  );
                }
                break;

              case "remove":
              case "untrack":
                const removeAddr = args[2];
                let removeNet = args[3];

                if (!removeAddr) {
                  this.log("Usage: pgt remove <address> [network]", "error");
                  this.log("Network is auto-detected if not provided", "info");
                  return;
                }

                // Auto-detect network if not provided
                if (!removeNet) {
                  removeNet = this.detectNetworkFromAddress(removeAddr);
                  this.log(`🔍 Auto-detected network: ${removeNet}`, "info");
                }

                const removeResult = await window.PGT.removeWallet(
                  removeAddr,
                  removeNet
                );
                if (removeResult.success) {
                  this.log(`✅ Wallet removed: ${removeAddr}`, "success");
                } else {
                  this.log(`❌ Error: ${removeResult.error}`, "error");
                }
                break;

              case "help":
              default:
                this.log("╔═══════════════════════════════════════╗", "info");
                this.log(
                  "║          PGT WALLET TRACKING          ║",
                  "success"
                );
                this.log("╚═══════════════════════════════════════╝", "info");
                this.log("", "info");
                this.log("pgt track <address>", "info");
                this.log("  Track any wallet (network auto-detected)", "info");
                this.log(
                  "  Example: pgt track 0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6",
                  "info"
                );
                this.log(
                  "  Example: pgt track 13Fhmm27TGQL7b5tDrumcDvWXhK5DxjmdzyMRT12z4ea",
                  "info"
                );
                this.log("", "info");
                this.log("pgt portfolio", "info");
                this.log(
                  "  Show portfolio summary with all tracked wallets",
                  "info"
                );
                this.log("", "info");
                this.log("pgt wallets", "info");
                this.log("  List all tracked wallets", "info");
                this.log("", "info");
                this.log("pgt refresh", "info");
                this.log(
                  "  Manually refresh portfolio data in stats panel",
                  "info"
                );
                this.log("", "info");
                this.log("pgt remove <address>", "info");
                this.log("  Remove a wallet from tracking", "info");
                this.log("", "info");
                this.log("💡 Network auto-detection:", "info");
                this.log("  0x... (42 chars) → Ethereum/Polygon/BSC", "info");
                this.log("  Base58 (32-44 chars) → Solana", "info");
                this.log("  .near or alphanumeric → NEAR", "info");
                break;
            }
          } catch (error) {
            this.log(`❌ Error: ${error.message}`, "error");
            console.error("PGT command error:", error);
          }
        }

        async checkNetwork() {
          this.log("🔍 Checking network configuration...", "info");

          // Check if wallet is connected
          if (!this.provider) {
            this.log("❌ No wallet provider available", "error");
            this.log("💡 Connect your wallet first using: connect", "info");
            return;
          }

          try {
            // Get current network from provider
            const network = await this.provider.getNetwork();
            this.log(`📡 Current Network:`, "info");
            this.log(
              `   Chain ID: ${network.chainId} (0x${network.chainId.toString(
                16
              )})`,
              "info"
            );
            this.log(`   Name: ${network.name || "Unknown"}`, "info");

            // Check if we're on the correct network
            const expectedChainId = 1313161768; // 0x4e454228
            if (network.chainId === expectedChainId) {
              this.log("✅ Connected to Omega Network!", "success");
            } else {
              this.log("❌ Not connected to Omega Network", "error");
              this.log(
                `💡 Expected Chain ID: ${expectedChainId} (0x4e454228)`,
                "info"
              );
              this.log(
                `💡 Current Chain ID: ${
                  network.chainId
                } (0x${network.chainId.toString(16)})`,
                "info"
              );
              this.log('💡 Use "connect" to switch to Omega Network', "info");
            }

            // Show network configuration that would be sent to MetaMask
            this.log("🔧 Network Configuration (for MetaMask):", "info");
            this.log(
              `   Chain ID: 0x4e454228 (${parseInt("0x4e454228", 16)} decimal)`,
              "info"
            );
            this.log(
              `   RPC URL: https://0x4e454228.rpc.aurora-cloud.dev`,
              "info"
            );
            this.log(
              `   Explorer: https://0x4e454228.explorer.aurora-cloud.dev/`,
              "info"
            );

            // Check what the RPC endpoint actually returns
            this.log("🔍 Checking RPC endpoint chain ID...", "info");
            try {
              const rpcResponse = await fetch(
                "https://0x4e454228.rpc.aurora-cloud.dev",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    jsonrpc: "2.0",
                    method: "eth_chainId",
                    params: [],
                    id: 1,
                  }),
                }
              );
              const rpcData = await rpcResponse.json();
              if (rpcData.result) {
                const rpcChainId = parseInt(rpcData.result, 16);
                this.log(
                  `📡 RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`,
                  "info"
                );

                if (rpcChainId === 1313161768) {
                  this.log(
                    "✅ RPC endpoint returns correct chain ID",
                    "success"
                  );
                } else {
                  this.log(
                    "❌ RPC endpoint returns different chain ID than expected",
                    "error"
                  );
                  this.log(
                    `💡 This explains the MetaMask mismatch warning`,
                    "info"
                  );
                }
              } else {
                this.log(
                  "❌ Could not get chain ID from RPC endpoint",
                  "error"
                );
              }
            } catch (rpcError) {
              this.log(
                `❌ Error checking RPC endpoint: ${rpcError.message}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`❌ Error checking network: ${error.message}`, "error");
          }
        }

        async forceAddNetwork() {
          this.log(
            "🔄 Force adding Omega Network with correct configuration...",
            "info"
          );

          if (!this.provider) {
            this.log("❌ No wallet provider available", "error");
            this.log("💡 Connect your wallet first using: connect", "info");
            return;
          }

          try {
            // First, try to remove any existing Omega network
            // Note: Removed old chain ID 0x330 reference to prevent conflicts
            this.log(
              "ℹ️ Skipping old network removal (0x330) to prevent conflicts",
              "info"
            );

            try {
              await this.provider.request({
                method: "wallet_removeEthereumChain",
                params: [{ chainId: "0x4e454228" }], // New chain ID
              });
              this.log(
                "🗑️ Removed existing Omega network configuration",
                "info"
              );
            } catch (removeError) {
              // Ignore errors if network doesn't exist
              this.log("ℹ️ No existing network to remove", "info");
            }

            // Now add the correct network configuration
            const networkConfig = {
              chainId: "0x4e454228",
              chainName: "Omega Network",
              nativeCurrency: { name: "OMEGA", symbol: "OMEGA", decimals: 18 },
              rpcUrls: ["https://0x4e454228.rpc.aurora-cloud.dev"],
              blockExplorerUrls: [
                "https://0x4e454228.explorer.aurora-cloud.dev/",
              ],
            };

            this.log("🔧 Adding network with correct configuration:", "info");
            this.log(
              `   Chain ID: ${networkConfig.chainId} (${parseInt(
                networkConfig.chainId,
                16
              )} decimal)`,
              "info"
            );
            this.log(`   RPC URL: ${networkConfig.rpcUrls[0]}`, "info");
            this.log(
              `   Explorer: ${networkConfig.blockExplorerUrls[0]}`,
              "info"
            );

            await this.provider.request({
              method: "wallet_addEthereumChain",
              params: [networkConfig],
            });

            this.log(
              "✅ Successfully added Omega network with correct configuration!",
              "success"
            );
            this.log(
              "💡 You may need to manually switch to the network in MetaMask",
              "info"
            );
          } catch (error) {
            this.log(
              `❌ Failed to force add network: ${error.message}`,
              "error"
            );
            this.log(
              "💡 Try manually removing the Omega network from MetaMask and reconnecting",
              "info"
            );
          }
        }

        async checkRpcChainId() {
          this.log("🔍 Checking RPC endpoint chain ID directly...", "info");

          try {
            const rpcResponse = await fetch(
              "https://0x4e454228.rpc.aurora-cloud.dev",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  method: "eth_chainId",
                  params: [],
                  id: 1,
                }),
              }
            );

            const rpcData = await rpcResponse.json();
            this.log("📡 RPC Response:", "info");
            this.log(`   Raw response: ${JSON.stringify(rpcData)}`, "info");

            if (rpcData.result) {
              const rpcChainId = parseInt(rpcData.result, 16);
              this.log(
                `📡 RPC Endpoint Chain ID: ${rpcChainId} (${rpcData.result})`,
                "info"
              );

              const expectedChainId = 1313161768; // 0x4e454228
              if (rpcChainId === expectedChainId) {
                this.log("✅ RPC endpoint returns correct chain ID", "success");
              } else {
                this.log(
                  "❌ RPC endpoint returns different chain ID than expected",
                  "error"
                );
                this.log(
                  `💡 Expected: ${expectedChainId} (0x4e454228)`,
                  "info"
                );
                this.log(
                  `💡 Actual: ${rpcChainId} (${rpcData.result})`,
                  "info"
                );
                this.log(
                  `💡 This mismatch explains the MetaMask warning`,
                  "info"
                );
              }
            } else {
              this.log("❌ Could not get chain ID from RPC endpoint", "error");
              this.log(
                `💡 Error: ${rpcData.error || "Unknown error"}`,
                "error"
              );
            }
          } catch (rpcError) {
            this.log(
              `❌ Error checking RPC endpoint: ${rpcError.message}`,
              "error"
            );
          }
        }

        async showBalance() {
          this.logHtml("<b>Wallets:</b>", "output");

          // Omega Wallet
          this.logHtml("<b>Omega Wallet:</b>", "output");
          if (this.signer) {
            try {
              const address = await this.signer.getAddress();
              const balance = await this.provider.getBalance(address);
              const formattedBalance = this.ethers.utils.formatEther(balance);
              this.logHtml(
                `  Balance: <b>${formattedBalance} OMEGA</b>`,
                "output"
              );
              this.logHtml(
                `  Address: <span style="color:#99ccff">${address}</span>`,
                "output"
              );

              // Show claimable OMEGA from relayer
              try {
                const claimableRes = await fetch(RELAYER_URL + "/claimable", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ address }),
                });
                const claimableData = await claimableRes.json();
                if (claimableData.success && claimableData.amount > 0) {
                  this.logHtml(
                    `  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>${claimableData.amount} OMEGA</b>`,
                    "output"
                  );
                } else {
                  this.logHtml(
                    `  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>0 OMEGA</b>`,
                    "output"
                  );
                }
              } catch (err) {
                this.logHtml(
                  `  🪙 <span style='color:#ffcc00'>Claimable OMEGA (Network):</span> <b>N/A</b> (Error: ${err.message})`,
                  "output"
                );
              }
            } catch (error) {
              this.logHtml("  Balance: <b>N/A OMEGA</b>", "output");
              this.logHtml(
                '  Address: <span style="color:#ff3333">N/A</span>',
                "output"
              );
              this.logHtml(
                "  [Error fetching OMEGA balance: " +
                  (error && error.message ? error.message : error) +
                  "]",
                "error"
              );
            }
          } else {
            this.logHtml("  Balance: <b>N/A OMEGA</b>", "output");
            this.logHtml(
              '  Address: <span style="color:#ff3333">Not connected</span>',
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Solana Wallet
          this.logHtml("<b>Solana Wallet:</b>", "output");
          if (this.solanaAddress) {
            try {
              const body = {
                jsonrpc: "2.0",
                id: 1,
                method: "getBalance",
                params: [this.solanaAddress],
              };
              const res = await fetch(
                "https://mainnet.helius-rpc.com/?api-key=94a04704-448e-45a8-82e5-8f4c63b25082",
                {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(body),
                }
              );
              const data = await res.json();
              let sol = "N/A";
              if (
                data &&
                data.result &&
                typeof data.result.value === "number"
              ) {
                sol = data.result.value / 1e9;
              }
              this.logHtml(`  Balance: <b>${sol} SOL</b>`, "output");
            } catch (err) {
              this.logHtml("  Balance: <b>N/A (Failed to fetch)</b>", "output");
            }
            this.logHtml(
              `  Address: <span style="color:#99ccff">${this.solanaAddress}</span>`,
              "output"
            );
          } else {
            this.logHtml("  Balance: <b>N/A SOL</b>", "output");
            this.logHtml(
              '  Address: <span style="color:#ff3333">Not connected</span>',
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Hyperliquid Wallet
          this.logHtml("<b>Hyperliquid Wallet:</b>", "output");
          if (
            window.hyperliquidApiWallet &&
            window.hyperliquidApiWallet.address
          ) {
            this.logHtml(
              `  Address: <span style='color:#99ccff'>${window.hyperliquidApiWallet.address}</span>`,
              "output"
            );
            this.logHtml(
              `  Private Key: <span style='color:#ff3333'>${window.hyperliquidApiWallet.privHex}</span>`,
              "output"
            );
          } else {
            this.logHtml(
              "  No Hyperliquid API wallet generated in this session.",
              "output"
            );
            this.logHtml(
              "  To generate a wallet, type: <b>hyperliquid gen-wallet</b>",
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Fair Wallet
          this.logHtml("<b>Fair Wallet:</b>", "output");
          if (window.fairWallet && window.fairWallet.address) {
            try {
              const fairProvider = new this.ethers.providers.JsonRpcProvider(
                "https://testnet-rpc.fair.cloud"
              );
              const fairBalance = await fairProvider.getBalance(
                window.fairWallet.address
              );
              const fairBalanceFormatted =
                this.ethers.utils.formatEther(fairBalance);
              this.logHtml(
                `  Balance: <b>${fairBalanceFormatted} FAIR</b>`,
                "output"
              );
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.fairWallet.address}</span>`,
                "output"
              );
            } catch (err) {
              this.logHtml("  Balance: <b>N/A FAIR</b>", "output");
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.fairWallet.address}</span>`,
                "output"
              );
              this.logHtml(
                "  [Error fetching FAIR balance: " +
                  (err && err.message ? err.message : err) +
                  "]",
                "error"
              );
            }
          } else {
            this.logHtml("  Balance: <b>N/A FAIR</b>", "output");
            this.logHtml(
              '  Address: <span style="color:#ff3333">Not connected</span>',
              "output"
            );
            this.logHtml(
              "  To generate a wallet, type: <b>fair generate</b>",
              "output"
            );
          }

          this.logHtml("&nbsp;", "output");

          // Eclipse Wallet
          this.logHtml("<b>Eclipse Wallet:</b>", "output");
          if (window.eclipseWallet && window.eclipseWallet.publicKey) {
            try {
              const connection = new window.solanaWeb3.Connection(
                window.eclipseWallet.rpcUrl,
                "confirmed"
              );
              const publicKey = new window.solanaWeb3.PublicKey(
                window.eclipseWallet.publicKey
              );
              const balance = await connection.getBalance(publicKey);
              const balanceInSol = (balance / 1e9).toLocaleString(undefined, {
                minimumFractionDigits: 4,
                maximumFractionDigits: 8,
              });
              this.logHtml(`  Balance: <b>${balanceInSol} SOL</b>`, "output");
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`,
                "output"
              );
            } catch (err) {
              this.logHtml("  Balance: <b>N/A SOL</b>", "output");
              this.logHtml(
                `  Address: <span style="color:#99ccff">${window.eclipseWallet.publicKey}</span>`,
                "output"
              );
              this.logHtml(
                "  [Error fetching Eclipse balance: " +
                  (err && err.message ? err.message : err) +
                  "]",
                "error"
              );
            }
          } else {
            this.logHtml(
              "  No Eclipse API wallet generated in this session.",
              "output"
            );
            this.logHtml(
              "  To generate a wallet, type: <b>eclipse gen-wallet</b>",
              "output"
            );
          }
        }

        async showStatus() {
          if (!this.signer) {
            this.log("❌ Wallet not connected", "error");
            return;
          }

          try {
            const address = await this.signer.getAddress();
            this.log(`✅ Wallet: ${address}`, "success");
            this.log(
              `⛏️  Mining: ${this.isMining ? "Active" : "Inactive"}`,
              "info"
            );
            this.log(
              `💰 Pending: ${this.totalEarned.toFixed(6)} OMEGA`,
              "info"
            );
            this.log(`📊 Blocks Mined: ${this.mineCount || 0}`, "info");
          } catch (error) {
            this.log("❌ Failed to get status: " + error.message, "error");
          }
        }

        async showStats() {
          this.log("📊 Mining Statistics:", "info");
          this.log(`⛏️  Total Blocks: ${this.mineCount || 0}`, "output");
          this.log(
            `👻 Ghost Transactions: ${this.ghostTransactionCount || 0}`,
            "output"
          );
          this.log(
            `💰 Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`,
            "output"
          );
          this.log(
            `⏱️  Session Time: ${
              this.startTime
                ? Math.floor((Date.now() - this.startTime) / 1000)
                : 0
            }s`,
            "output"
          );
          this.log(`🎯 Reward Structure: Avg 0.0001 | Max 1.0 OMEGA`, "output");
        }

        stopAll() {
          let stoppedActivities = [];

          // Stop mining
          if (this.isMining) {
            this.isMining = false;
            stoppedActivities.push("mining");
            this.log("⏹️  Mining stopped.", "info");
          }

          // Stop stress testing
          if (this.isStressTesting) {
            this.isStressTesting = false;
            if (this.stressTestInterval) {
              clearInterval(this.stressTestInterval);
              this.stressTestInterval = null;
            }
            stoppedActivities.push("stress testing");
          }

          // Also clear stress funding interval if running
          if (this.stressFundingInterval) {
            clearInterval(this.stressFundingInterval);
            this.stressFundingInterval = null;
          }

          if (stoppedActivities.length > 0) {
            this.log(`⏹️  Stopped: ${stoppedActivities.join(", ")}`, "success");
          } else {
            this.log("⏹️  No activities were running to stop", "info");
          }
        }

        async startMiningSession() {
          this.log("🚀 Starting mining session...", "info");
          await this.mine();
        }

        async faucetClaim() {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (this.sessionOmegaWallet) {
            const approved = await this.confirmOmegaTransaction();
            if (!approved) return;
          }
          try {
            this.log("🚰 Claiming from faucet...", "info");
            const faucetContract = new this.ethers.Contract(
              this.faucetAddress,
              this.faucetABI,
              this.signer
            );
            const tx = await faucetContract.claim({ gasLimit: 100000 });
            await tx.wait();
            this.log("✅ Faucet claim successful!", "success");
          } catch (error) {
            this.log("❌ Faucet claim failed: " + error.message, "error");
          }
        }

        async showPendingRewards() {
          const minerInfo = await this.contract.getMinerInfo(
            this.miningWallet.address
          );
          const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
          this.log(`💰 Pending Rewards: ${pendingRewards} OMEGA`, "info");
          if (parseFloat(pendingRewards) > 0) {
            this.log('💡 Use "claim" command to collect rewards', "info");
          }
        }

        async depositForMining() {
          this.log("💡 This feature is not yet implemented", "info");
        }

        async deployContract() {
          this.log("💡 Contract deployment is handled separately", "info");
        }

        async showContractInfo() {
          this.log(`📋 Mining Contract: ${this.contractAddress}`, "info");
          this.log(`🚰 Faucet Contract: ${this.faucetAddress}`, "info");
        }

        async startStressTest() {
          if (!this.ethers || !this.provider || !this.provider.getNetwork) {
            this.log(
              "Ethers library or provider not loaded. Please refresh the page and connect your wallet.",
              "error"
            );
            return;
          }
          const network = await this.provider.getNetwork();
          if (!network || !network.chainId || network.chainId === 0) {
            this.log(
              "⚠️ No valid network detected - stress test will not send real transactions.",
              "warning"
            );
            return;
          }
          if (this.isStressTesting) {
            this.log(
              'Stress test already running. Use "stopstress" to stop it.',
              "warning"
            );
            return;
          }

          // Generate a new wallet for the stress test
          this.stressWallet = this.ethers.Wallet.createRandom();
          this.log("🆕 Stress Test Wallet Generated:", "info");
          this.logHtml(
            'Address: <span class="copyable" onclick="navigator.clipboard.writeText(\'' +
              this.stressWallet.address +
              "').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))\">" +
              this.stressWallet.address +
              "</span>",
            "output"
          );
          this.logHtml(
            '💡 <span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundStressWallet(\'0.001\')">[Click here to fund with 0.001 OMEGA]</span>',
            "info"
          );

          // Connect wallet to provider
          this.stressWallet = this.stressWallet.connect(this.provider);

          // Wait for funding
          this.log("⏳ Waiting for funding to initiate stress test...", "info");
          this.isStressTesting = true;
          this.stressTestStats = {
            walletsCreated: 0,
            transactionsSent: 0,
            successfulTxs: 0,
            failedTxs: 0,
            startTime: Date.now(),
          };

          // Poll for funding every 5 seconds
          this.stressFundingInterval = setInterval(async () => {
            const balance = await this.provider.getBalance(
              this.stressWallet.address
            );
            if (!balance.isZero()) {
              clearInterval(this.stressFundingInterval);
              this.log(
                "✅ Funding detected! Starting stress test...",
                "success"
              );
              // Fetch and store the starting nonce
              this.localNonce = await this.provider.getTransactionCount(
                this.stressWallet.address,
                "latest"
              );
              this.startStressTestCycle();
            }
          }, 5000);
        }

        startStressTestCycle() {
          this.stressTestInterval = setInterval(() => {
            if (this.isStressTesting) {
              this.runStressTestCycle();
            }
          }, 3000);
          this.log("✅ Stress test will now begin!", "success");
        }

        async runStressTestCycle() {
          try {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            const newWallet = this.ethers.Wallet.createRandom();
            this.stressTestStats.walletsCreated++;
            const gasPrice = await this.provider.getGasPrice();

            // Log stress wallet address and balance before sending
            const stressAddress = this.stressWallet.address;
            const balance = await this.provider.getBalance(stressAddress);
            this.log(
              `[DEBUG] Stress wallet: ${stressAddress}, Balance: ${this.ethers.utils.formatEther(
                balance
              )} OMEGA`,
              "info"
            );
            this.log(
              `[DEBUG] Provider: ${
                this.provider.connection && this.provider.connection.url
                  ? this.provider.connection.url
                  : "unknown"
              }`,
              "info"
            );

            // Use and increment local nonce
            const nonce = this.localNonce;
            this.localNonce++;

            const txObj = {
              to: newWallet.address,
              value: 0,
              gasLimit: 21000,
              gasPrice: gasPrice,
              nonce: nonce,
            };
            this.log(`[DEBUG] Sending tx: ${JSON.stringify(txObj)}`, "info");

            const tx = await this.stressWallet.sendTransaction(txObj);

            this.stressTestStats.transactionsSent++;
            this.log(
              `📤 Sent empty tx to ${newWallet.address.slice(
                0,
                10
              )}... (hash: ${tx.hash})`,
              "info"
            );
            this.stressTestStats.successfulTxs++;
          } catch (err) {
            this.stressTestStats.failedTxs++;
            this.log(
              `[DEBUG] Error: ${err && err.stack ? err.stack : err}`,
              "error"
            );
            // If nonce error, re-sync local nonce
            if (
              err.message &&
              (err.message.includes("nonce") ||
                err.message.includes("replacement"))
            ) {
              this.log(
                "🔄 Nonce error detected, re-syncing nonce from network...",
                "warning"
              );
              this.localNonce = await this.provider.getTransactionCount(
                this.stressWallet.address,
                "latest"
              );
            } else if (
              err.message &&
              err.message.includes("Internal JSON-RPC error")
            ) {
              this.log(`⚠️ RPC overload - slowing down...`, "warning");
              await new Promise((resolve) => setTimeout(resolve, 2000));
            } else {
              this.log(`❌ Transaction failed: ${err.message}`, "error");
            }
          }
        }

        stopStressTest() {
          if (!this.isStressTesting) {
            this.log("No stress test running.", "warning");
            return;
          }

          if (this.stressTestInterval) {
            clearInterval(this.stressTestInterval);
          }
          if (this.stressFundingInterval) {
            clearInterval(this.stressFundingInterval);
          }

          this.isStressTesting = false;
          this.log("🛑 Stress test stopped.", "warning");
          this.showStressStats();
        }

        showStressStats() {
          if (!this.stressTestStats.startTime) {
            this.log("No stress test has been run yet.", "info");
            return;
          }

          const runtime = Math.floor(
            (Date.now() - this.stressTestStats.startTime) / 1000
          );
          const successRate =
            this.stressTestStats.transactionsSent > 0
              ? (
                  (this.stressTestStats.successfulTxs /
                    this.stressTestStats.transactionsSent) *
                  100
                ).toFixed(1)
              : 0;

          this.log("=== STRESS TEST STATISTICS ===", "info");
          this.log(`Runtime: ${runtime} seconds`, "output");
          this.log(
            `Wallets Created: ${this.stressTestStats.walletsCreated}`,
            "output"
          );
          this.log(
            `Transactions Sent: ${this.stressTestStats.transactionsSent}`,
            "output"
          );
          this.log(
            `Successful: ${this.stressTestStats.successfulTxs}`,
            "success"
          );
          this.log(`Failed: ${this.stressTestStats.failedTxs}`, "error");
          this.log(`Success Rate: ${successRate}%`, "output");
          this.log(
            `Status: ${this.isStressTesting ? "RUNNING" : "STOPPED"}`,
            this.isStressTesting ? "success" : "warning"
          );
        }

        async showMiningStats() {
          await this.showStats();
        }

        async rickroll() {
          this.log("🎵 Never gonna give you up...", "info");
          this.log("🎵 Never gonna let you down...", "info");
          this.log("🎵 Never gonna run around and desert you...", "info");
          this.log("🎵 Never gonna make you cry...", "info");
          this.log("🎵 Never gonna say goodbye...", "info");
          this.log("🎵 Never gonna tell a lie and hurt you...", "info");

          // Create and show Rickroll popup
          const modal = document.createElement("div");
          modal.id = "rickrollModal";
          modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;

          const videoContainer = document.createElement("div");
          videoContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 800px;
                    height: 60%;
                    max-height: 450px;
                `;

          const closeBtn = document.createElement("button");
          closeBtn.textContent = "×";
          closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
          closeBtn.onclick = () => {
            document.body.removeChild(modal);
          };

          const iframe = document.createElement("iframe");
          iframe.src = "https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1";
          iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                    border-radius: 10px;
                `;
          iframe.allow = "autoplay; encrypted-media";

          videoContainer.appendChild(closeBtn);
          videoContainer.appendChild(iframe);
          modal.appendChild(videoContainer);
          document.body.appendChild(modal);

          // Auto-close after 30 seconds
          setTimeout(() => {
            if (document.body.contains(modal)) {
              document.body.removeChild(modal);
            }
          }, 30000);
        }

        fortune() {
          const fortunes = [
            "A beautiful, smart, and loving person will be coming into your life.",
            "A dubious friend may be an enemy in camouflage.",
            "A faithful friend is a strong defense.",
            "A fresh start will put you on your way.",
            "A golden egg of opportunity falls into your lap this month.",
            "A lifetime friend shall soon be made.",
            "A light heart carries you through all the hard times.",
            "A new perspective will come with the new year.",
            "A pleasant surprise is waiting for you.",
            "A short pencil is usually better than a long memory any day.",
          ];
          const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
          this.log(`🔮 Fortune: ${fortune}`, "info");
        }

        async matrix() {
          this.log("🌐 Entering the Matrix...", "info");
          for (let i = 0; i < 5; i++) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            this.log("01010101010101010101010101010101", "output");
          }
          this.log("🌐 Matrix mode activated!", "success");
        }

        async hack() {
          this.log("💻 Hacker mode activated...", "info");
          this.log("🔓 Bypassing security protocols...", "output");
          this.log("🔓 Accessing mainframe...", "output");
          this.log("🔓 Downloading classified data...", "output");
          this.log("✅ Hack complete! You are now a l33t h4x0r!", "success");
        }

        async disco() {
          this.log("🕺 Disco mode activated!", "info");
          this.log("💃 Stayin' alive, stayin' alive...", "output");
          this.log(
            "🎵 Ah, ha, ha, ha, stayin' alive, stayin' alive...",
            "output"
          );
          this.log("✨ Disco fever!", "success");
        }

        sudoMine() {
          this.log("🔐 Sudo access granted!", "info");
          this.log("⚡ Super user mining mode activated!", "success");
          this.log("🚀 Mining with admin privileges...", "output");
          this.totalEarned += 0.1;
          this.log("💰 Admin bonus: +0.1 OMEGA", "success");
        }

        async fundMiningWallet(amount) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (!this.miningWallet) {
            this.log("No mining wallet found. Start mining first.", "error");
            return;
          }
          if (!amount || isNaN(amount) || Number(amount) <= 0) {
            this.log("Invalid amount. Usage: fund <amount>", "error");
            return;
          }
          try {
            this.log(
              `💰 Funding mining wallet with ${amount} OMEGA...`,
              "info"
            );
            const tx = await this.signer.sendTransaction({
              to: this.miningWallet.address,
              value: this.ethers.utils.parseEther(amount),
              gasLimit: 21000,
            });
            this.log(`📤 Funding transaction sent: ${tx.hash}`, "info");
            this.log(
              "⏳ Waiting for confirmation... (this may take a few seconds)",
              "info"
            );
            await tx.wait();
            this.log(
              `✅ Mining wallet funded with ${amount} OMEGA!`,
              "success"
            );
          } catch (error) {
            if (error.code === 4001) {
              this.log("❌ Transaction rejected by user.", "error");
            } else {
              this.log(
                "❌ Failed to fund mining wallet: " + error.message,
                "error"
              );
            }
          }
        }

        async fundStressWallet(amount) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          if (!this.stressWallet) {
            this.log(
              "No stress test wallet found. Start stress test first.",
              "error"
            );
            return;
          }
          if (!amount || isNaN(amount) || Number(amount) <= 0) {
            this.log("Invalid amount. Usage: fund <amount>", "error");
            return;
          }
          try {
            this.log(
              `💰 Funding stress test wallet with ${amount} OMEGA...`,
              "info"
            );
            const tx = await this.signer.sendTransaction({
              to: this.stressWallet.address,
              value: this.ethers.utils.parseEther(amount),
              gasLimit: 21000,
            });
            this.log(`📤 Funding transaction sent: ${tx.hash}`, "info");
            this.log(
              "⏳ Waiting for confirmation... (this may take a few seconds)",
              "info"
            );
            await tx.wait();
            this.log(
              `✅ Stress test wallet funded with ${amount} OMEGA!`,
              "success"
            );
          } catch (error) {
            if (error.code === 4001) {
              this.log("❌ Transaction rejected by user.", "error");
            } else {
              this.log(
                "❌ Failed to fund stress test wallet: " + error.message,
                "error"
              );
            }
          }
        }

        async setTheme(theme) {
          const validThemes = [
            "dark",
            "light",
            "matrix",
            "retro",
            "powershell",
            "executive",
          ];
          if (!validThemes.includes(theme)) {
            this.log(
              "Invalid theme. Available: dark, light, matrix, retro, powershell, executive",
              "error"
            );
            return;
          }
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro",
            "theme-powershell",
            "theme-executive"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro",
              "theme-powershell",
              "theme-executive"
            );
            terminal.classList.add("theme-" + theme);
          }
          localStorage.setItem("omega-terminal-theme", theme);
        }

        // Cycle AI provider via command or legacy toggle
        toggleAIMode() {
          // Cycle order: off -> near -> openai -> off
          const order = ["off", "near", "openai"];
          const currentIndex = order.indexOf(this.aiProvider || "off");
          const nextProvider = order[(currentIndex + 1) % order.length];
          this.setAIProvider(nextProvider);
        }

        // Set AI provider and persist, update UI
        setAIProvider(provider) {
          const valid = ["off", "near", "openai"];
          if (!valid.includes(provider)) provider = "off";
          this.aiProvider = provider;
          this.isAIModeOn = provider !== "off";
          localStorage.setItem("omega-ai-provider", provider);
          this.applyAIProviderUI();

          // Play AI toggle sound effect when AI is turned on
          if (
            window.OmegaSoundEffects &&
            window.OmegaSoundEffects.isSoundEnabled() &&
            provider !== "off"
          ) {
            window.OmegaSoundEffects.playAIToggleSound();
          }

          // Sync futuristic dashboard labels if available
          if (
            window.FuturisticDashboard &&
            typeof window.FuturisticDashboard.syncAIToggleState === "function"
          ) {
            window.FuturisticDashboard.syncAIToggleState();
          }
        }

        // Reflect provider choice in inputs and header select
        applyAIProviderUI() {
          const input = document.getElementById("commandInput");
          const sel = document.getElementById("aiProviderSelect");
          if (sel && sel.value !== (this.aiProvider || "off")) {
            try {
              sel.value = this.aiProvider || "off";
            } catch (e) {}
          }
          if (this.isAIModeOn) {
            if (input)
              input.placeholder = "Enter command or ask me anything...";
            const label =
              this.aiProvider === "near"
                ? "NEAR AI"
                : this.aiProvider === "openai"
                ? "OpenAI"
                : "AI";
            this.log(`🤖 AI Mode: ${label} enabled`, "info");
          } else {
            if (input) input.placeholder = "Enter command...";
          }
        }

        toggleTheme() {
          this.isDarkTheme = !this.isDarkTheme;
          this.applyTheme();
          localStorage.setItem(
            "omega-miner-theme",
            this.isDarkTheme ? "dark" : "light"
          );
        }

        applyTheme() {
          const theme = localStorage.getItem("omega-terminal-theme") || "dark";
          document.body.classList.remove(
            "theme-dark",
            "theme-light",
            "theme-matrix",
            "theme-retro",
            "theme-powershell"
          );
          document.body.classList.add("theme-" + theme);
          const terminal = document.getElementById("terminal");
          if (terminal) {
            terminal.classList.remove(
              "theme-dark",
              "theme-light",
              "theme-matrix",
              "theme-retro",
              "theme-powershell"
            );
            terminal.classList.add("theme-" + theme);
          }
          const themeToggle = document.querySelector(".theme-toggle");
          if (themeToggle) {
            if (theme === "dark") themeToggle.textContent = "☀️ Light";
            else if (theme === "light") themeToggle.textContent = "🌙 Dark";
            else if (theme === "matrix") themeToggle.textContent = "🟩 Matrix";
            else if (theme === "retro") themeToggle.textContent = "🟨 Retro";
            else if (theme === "powershell")
              themeToggle.textContent = "💻 PowerShell";
          }
        }

        async sendOmega(command) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          // Parse command: send <address_or_ens> <amount>
          const parts = command.trim().split(/\s+/);
          if (parts.length !== 3) {
            this.log("Usage: send <address_or_ens> <amount>", "warning");
            return;
          }
          let address = parts[1];
          const amountStr = parts[2];

          // First, try to resolve as ENS name if it's not a valid address
          if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            this.log(`🔍 Resolving ENS name: ${address}...`, "info");
            try {
              const ens = this.getENSContract();
              const resolvedAddress = await ens.resolve(address);
              if (
                resolvedAddress &&
                resolvedAddress !== "0x0000000000000000000000000000000000000000"
              ) {
                this.log(
                  `✅ Resolved ${address} to ${resolvedAddress}`,
                  "success"
                );
                address = resolvedAddress;
              } else {
                this.log(`❌ ENS name not found: ${address}`, "error");
                return;
              }
            } catch (err) {
              this.log(
                `❌ Failed to resolve ENS name: ${err.message}`,
                "error"
              );
              return;
            }
          }

          // Now validate the resolved address
          if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            this.log("Invalid address format.", "error");
            return;
          }

          let amount;
          try {
            amount = this.ethers.utils.parseEther(amountStr);
          } catch (e) {
            this.log("Invalid amount.", "error");
            return;
          }

          this.log(`🚀 Sending ${amountStr} OMEGA to ${address}...`, "info");
          try {
            const tx = await this.signer.sendTransaction({
              to: address,
              value: amount,
            });
            this.log("⏳ Waiting for confirmation...", "info");
            await tx.wait();
            this.log(`✅ Sent ${amountStr} OMEGA to ${address}!`, "success");
          } catch (error) {
            this.log("❌ Send failed: " + error.message, "error");
          }
        }

        async claim() {
          if (!this.signer) {
            this.log(
              'Please connect wallet first using "connect" command',
              "error"
            );
            return;
          }
          try {
            const address = await this.signer.getAddress();
            this.log("💸 Sending claim request to network...", "info");
            const res = await fetch(RELAYER_URL + "/claim", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ address }),
            });
            const data = await res.json();
            if (data.success) {
              this.log(
                `✅ Claimed ${data.amount} OMEGA to your wallet!`,
                "success"
              );
              if (data.txHash) {
                this.logHtml(
                  `📤 Claim tx sent: <span class="copyable" onclick="navigator.clipboard.writeText('${data.txHash}')">${data.txHash}</span>`,
                  "info"
                );
              }
            } else {
              this.log(
                "❌ Claim failed: " + (data.error || "Unknown error"),
                "error"
              );
            }
          } catch (error) {
            this.log("❌ Claim error: " + error.message, "error");
          }
        }

        // 1. Add ENS contract setup at the top of the class (after constructor or as a helper):
        getENSContract(signerOrProvider) {
          const abi = [
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
                {
                  indexed: true,
                  internalType: "address",
                  name: "owner",
                  type: "address",
                },
              ],
              name: "NameRegistered",
              type: "event",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
              ],
              name: "register",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
                { internalType: "address", name: "newOwner", type: "address" },
              ],
              name: "transfer",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "names",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "string", name: "name", type: "string" },
              ],
              name: "resolve",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          ];
          return new this.ethers.Contract(
            "0xd9ce49734db4f033362d2fd51d52f24cabeb87fa",
            abi,
            signerOrProvider || this.signer || this.provider
          );
        }

        // Chat functionality
        async sendDirectMessage(recipient, message) {
          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          // Resolve ENS if needed
          let toAddress = recipient;
          if (!/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
            try {
              const ens = this.getENSContract();
              const resolved = await ens.resolve(recipient);
              if (
                resolved &&
                resolved !== "0x0000000000000000000000000000000000000000"
              ) {
                toAddress = resolved;
              } else {
                this.log("❌ ENS name not found: " + recipient, "error");
                return;
              }
            } catch (err) {
              this.log("❌ Failed to resolve ENS: " + err.message, "error");
              return;
            }
          }
          // Send DM on-chain
          try {
            const dmABI = [
              {
                inputs: [
                  { internalType: "address", name: "to", type: "address" },
                  { internalType: "string", name: "ensName", type: "string" },
                  { internalType: "string", name: "message", type: "string" },
                ],
                name: "sendMessage",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "from",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "message",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                ],
                name: "DirectMessage",
                type: "event",
              },
            ];
            const dmContract = new this.ethers.Contract(
              "0x26e31516e5e7790f8aaa35278735970a93fee213",
              dmABI,
              this.signer
            );
            let tx;
            if (/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
              // It's an address
              tx = await dmContract.sendMessage(recipient, "", message);
            } else {
              // It's an ENS name
              tx = await dmContract.sendMessage(
                "0x0000000000000000000000000000000000000000",
                recipient,
                message
              );
            }
            this.log(
              "⏳ Sending Email on-chain... (tx: " + tx.hash + ")",
              "info"
            );
            await tx.wait();
            this.log("✅ Email sent!", "success");
          } catch (err) {
            this.log("❌ Failed to send DM: " + err.message, "error");
          }
        }

        async showInbox(showAll = false) {
          try {
            // Check if wallet is connected
            if (!this.signer) {
              this.log(
                "❌ Please connect your wallet first using: connect",
                "error"
              );
              return;
            }

            const dmABI = [
              {
                inputs: [
                  { internalType: "address", name: "to", type: "address" },
                  { internalType: "string", name: "ensName", type: "string" },
                  { internalType: "string", name: "message", type: "string" },
                ],
                name: "sendMessage",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "from",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "message",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                ],
                name: "DirectMessage",
                type: "event",
              },
            ];
            const dmContract = new this.ethers.Contract(
              "0x26e31516e5e7790f8aaa35278735970a93fee213",
              dmABI,
              this.provider
            );
            const myAddr = await this.signer.getAddress();
            const filter = dmContract.filters.DirectMessage(null, myAddr);

            // Fetch more historical messages - last 100k blocks (about 1-2 weeks)
            this.log(
              "Fetching inbox events from last 100,000 blocks...",
              "info"
            );
            const events = await dmContract.queryFilter(filter, -100000);

            if (!events.length) {
              this.log("No direct messages found.", "info");
              return;
            }

            this.log("=== Inbox ===", "info");
            this.log(`Found ${events.length} messages total`, "info");

            // Sort events by timestamp (newest first)
            const sortedEvents = events.sort(
              (a, b) => Number(b.args.timestamp) - Number(a.args.timestamp)
            );

            // Show messages based on parameter
            const messagesToShow = showAll
              ? sortedEvents
              : sortedEvents.slice(0, 25);

            for (let i = 0; i < messagesToShow.length; i++) {
              const ev = messagesToShow[i];
              let from = ev.args.from;
              let ensName = "";
              try {
                ensName = await this.provider.lookupAddress(from);
              } catch {}
              let fromDisplay = ensName ? `(${ensName}) | ${from}` : from;

              // Format date more nicely
              const date = new Date(Number(ev.args.timestamp) * 1000);
              const timeAgo = this.getTimeAgo(date);
              const formattedDate = date.toLocaleString();

              this.log("──────────────────────────────", "output");
              this.logHtml(
                `<span id="${ev.transactionHash}"><span style="color:#fff">📧</span> <span style="color:#99ccff">From:</span> <span style="color:#fff">${fromDisplay}</span><br><span style="color:#99ccff">Time:</span> <span style="color:#fff">${formattedDate} (${timeAgo})</span><br><span style="color:#99ccff">Message:</span> <span style="color:#fff">${ev.args.message}</span><br><span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="document.getElementById('${ev.transactionHash}').style.display='none'">Delete</span> | <span style="color:#00ccff;cursor:pointer;text-decoration:underline;" onclick="window.terminal.prefillOeMailRecipient('${from}')">Reply</span></span>`,
                "output"
              );
            }

            if (!showAll && events.length > 25) {
              this.log(
                `Showing 25 of ${events.length} messages. Use 'inbox all' to see all messages.`,
                "info"
              );
            } else if (showAll) {
              this.log(`Showing all ${events.length} messages.`, "info");
            }

            console.log("DM events:", events);
          } catch (err) {
            this.log("❌ Failed to fetch inbox: " + err.message, "error");
          }
        }

        prefillOeMailRecipient(address) {
          const input = document.getElementById("commandInput");
          if (input) {
            window.terminal.tempDMRecipient = address;
            window.terminal.awaitingDMRecipient = false;
            window.terminal.awaitingDMMessage = true;
            window.terminal.logHtml(
              '<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' +
                address +
                "</span>",
              "info"
            );
            window.terminal.log("Enter your message:", "info");
            input.value = "";
            input.focus();
          }
        }

        getTimeAgo(date) {
          const now = new Date();
          const diffInSeconds = Math.floor((now - date) / 1000);

          if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
          if (diffInSeconds < 3600)
            return `${Math.floor(diffInSeconds / 60)}m ago`;
          if (diffInSeconds < 86400)
            return `${Math.floor(diffInSeconds / 3600)}h ago`;
          if (diffInSeconds < 2592000)
            return `${Math.floor(diffInSeconds / 86400)}d ago`;
          if (diffInSeconds < 31536000)
            return `${Math.floor(diffInSeconds / 2592000)}mo ago`;
          return `${Math.floor(diffInSeconds / 31536000)}y ago`;
        }

        async showFaucetStatus() {
          // VERSION CHECK - If you see this message, the updated code is loaded
          this.log(
            "🔄 UPDATED CODE VERSION: Using direct RPC provider for faucet status",
            "info"
          );

          if (!this.signer) {
            this.log(
              "Please connect your wallet first using: connect",
              "error"
            );
            return;
          }
          try {
            const address = await this.signer.getAddress();

            // Use direct RPC provider to avoid MetaMask issues
            const OMEGA_RPC_URL = "https://0x4e454228.rpc.aurora-cloud.dev";
            const directProvider = new this.ethers.providers.JsonRpcProvider(
              OMEGA_RPC_URL
            );
            const faucetContract = new this.ethers.Contract(
              this.faucetAddress,
              this.faucetABI,
              directProvider
            );

            // Get faucet status using direct RPC
            const info = await faucetContract.getFaucetStatus(address);

            const canClaim = info.canClaimNow;
            const lastClaim = info.lastClaim;
            const timeUntil = info.timeUntilNextClaim;
            const claimAmount = info.claimAmount;
            const faucetBalance = info.faucetBalance;

            this.log("=== Faucet Status ===", "info");
            this.log(
              `Can claim now: ${canClaim ? "✅ Yes" : "❌ No"}`,
              canClaim ? "success" : "error"
            );
            if (!canClaim) {
              const mins = Math.floor(timeUntil / 60);
              const secs = timeUntil % 60;
              this.log(`Time until next claim: ${mins}m ${secs}s`, "warning");
            }
            this.log(
              `Faucet balance: ${this.ethers.utils.formatEther(
                faucetBalance
              )} OMEGA`,
              "info"
            );
            this.log(
              `Claim amount: ${this.ethers.utils.formatEther(
                claimAmount
              )} OMEGA`,
              "info"
            );
          } catch (error) {
            this.log(
              "❌ Failed to fetch faucet status: " + error.message,
              "error"
            );
          }
        }

        // Add this helper method to the class
        async isRealMetaMask() {
          if (
            typeof window.ethereum !== "undefined" &&
            window.ethereum.isMetaMask
          ) {
            try {
              await window.ethereum.request({ method: "eth_accounts" });
              return true;
            } catch (e) {
              return false;
            }
          }
          return false;
        }

        // Add this method to the OmegaMinerTerminal class
        promptTerminalInput() {
          this.awaitingPromptInput = true;
          // If there are queued AI prompt responses, use them
          if (this.aiPromptQueue && this.aiPromptQueue.length > 0) {
            const response = this.aiPromptQueue.shift();
            return Promise.resolve(response);
          }
          return new Promise((resolve) => {
            this.promptResolver = resolve;
            const input = document.getElementById("commandInput");
            input.focus();
          });
        }

        // Add a helper to confirm transactions for Omega Test Wallet
        async confirmOmegaTransaction() {
          if (this.sessionOmegaWallet) {
            this.log("Approve transaction? (yes / no)", "warning");
            while (true) {
              const input = await this.promptTerminalInput();
              if (input.toLowerCase() === "yes") return true;
              if (input.toLowerCase() === "no") {
                this.log("Transaction cancelled.", "error");
                return false;
              }
              this.log('Please type either "yes" or "no".', "warning");
            }
          }
          return true;
        }

        async handleDexScreenerAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">Dexscreener API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds trending</span> - Show trending tokens',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds search [query]</span> - Search for tokens',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pair [chainId] [pairId]</span> - Get pair info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools</span> - List all pools',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools [chainId] [tokenAddress]</span> - Get pools for a token',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds trending</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds search OMEGA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pair 1 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">ds pools 1 0x123...</span>',
              "output"
            );
            return;
          }
          // Map ds commands to relayer endpoints
          if (args[1] === "trending") {
            await this.handleDexScreenerCommand(["dexscreener", "trending"]);
          } else if (args[1] === "search" && args[2]) {
            await this.handleDexScreenerCommand([
              "dexscreener",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "pair" && args[2] && args[3]) {
            // /dex/pair/:chainId/:pairId
            const chainId = args[2];
            const pairId = args[3];
            this.log(
              `Fetching DexScreener pair info for chain ${chainId}, pair ${pairId}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/pair/${chainId}/${pairId}`
              );
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pair fetch failed: " + e.message, "error");
            }
          } else if (args[1] === "pools" && !args[2]) {
            // /dex/pools
            this.log("Fetching all DexScreener pools...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/dex/pools`);
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pools fetch failed: " + e.message, "error");
            }
          } else if (args[1] === "pools" && args[2] && args[3]) {
            // /dex/pools/:chainId/:tokenAddress
            const chainId = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching DexScreener pools for chain ${chainId}, token ${tokenAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/dex/pools/${chainId}/${tokenAddress}`
              );
              const data = await res.json();
              this.logHtml(
                `<pre>${JSON.stringify(data, null, 2)}</pre>`,
                "output"
              );
            } catch (e) {
              this.log("DexScreener pools fetch failed: " + e.message, "error");
            }
          } else {
            this.log("Type ds help for available commands.", "info");
          }
        }

        async handleGeckoTerminalAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">GeckoTerminal API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg search [query]</span> - Search for pairs',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg networks</span> - List networks',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg dexes [network]</span> - List dexes for a network',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg pools [network]</span> - List pools for a network',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg token [network] [address]</span> - Get token info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg tokenpools [network] [token_address]</span> - Get pools for a token',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg poolinfo [network] [pool_address]</span> - Get pool info',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg ohlcv [network] [pool_address] [timeframe]</span> - Get OHLCV data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg trades [network] [pool_address]</span> - Get trades for a pool',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg search OMEGA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg networks</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg dexes ethereum</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg pools ethereum</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg token ethereum 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg tokenpools ethereum 0x123...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg poolinfo ethereum 0xabc...</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg ohlcv ethereum 0xabc... 1d</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">cg trades ethereum 0xabc...</span>',
              "output"
            );
            return;
          }
          // Map cg commands to relayer endpoints
          if (args[1] === "search" && args[2]) {
            await this.handleGeckoTerminalCommand([
              "geckoterminal",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "networks") {
            this.log("Fetching GeckoTerminal networks...", "info");
            try {
              const res = await fetch(`${RELAYER_URL}/gecko/networks`);
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml("<b>Available Networks:</b>", "output");
                data.data.forEach((item) => {
                  const net = item.attributes;
                  const id = item.id;
                  const cg = net.coingecko_asset_platform_id
                    ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>`
                    : "";
                  this.logHtml(
                    `<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No networks found.</span>',
                  "error"
                );
              }
            } catch (e) {
              this.log(
                "GeckoTerminal networks fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "dexes" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal dexes for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/dexes`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>DEXes for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const dex = item.attributes;
                  const id = item.id;
                  this.logHtml(
                    `<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No DEXes found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal dexes fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "pools" && args[2]) {
            const network = args[2];
            this.log(
              `Fetching GeckoTerminal pools for network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(`<b>Pools for ${network}:</b>`, "output");
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal pools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "token" && args[2] && args[3]) {
            const network = args[2];
            const address = args[3];
            this.log(
              `Fetching GeckoTerminal token info for network: ${network}, address: ${address}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const token = data.data.attributes;
                this.logHtml(
                  `<b>${token.name} (${token.symbol})</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${token.price_usd || "N/A"}</b> | TVL: <b>${
                    token.tvl_usd || "N/A"
                  }</b>`,
                  "output"
                );
                this.logHtml(
                  `DEX Count: <b>${
                    token.dex_count || "N/A"
                  }</b> | Pool Count: <b>${token.pool_count || "N/A"}</b>`,
                  "output"
                );
                if (token.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No token info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal token fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "tokenpools" && args[2] && args[3]) {
            const network = args[2];
            const tokenAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Pools for token ${tokenAddress} on ${network}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  const pool = item.attributes;
                  this.logHtml(
                    `<b>${pool.name}</b> | DEX: <b>${
                      pool.dex_name
                    }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pools found for this token.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal tokenpools fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "poolinfo" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`
              );
              const data = await res.json();
              if (data && data.data && data.data.attributes) {
                const pool = data.data.attributes;
                this.logHtml(
                  `<b>${pool.name}</b> | DEX: <b>${
                    pool.dex_name
                  }</b> | TVL: <b>${pool.tvl_usd || "N/A"}</b>`,
                  "output"
                );
                this.logHtml(
                  `Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`,
                  "output"
                );
                this.logHtml(
                  `Price: <b>${pool.price_usd || "N/A"}</b> | Volume 24h: <b>${
                    pool.volume_usd_24h || "N/A"
                  }</b>`,
                  "output"
                );
                if (pool.gecko_terminal_url)
                  this.logHtml(
                    `<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`,
                    "output"
                  );
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No pool info found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal poolinfo fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "ohlcv" && args[2] && args[3] && args[4]) {
            const network = args[2];
            const poolAddress = args[3];
            const timeframe = args[4];
            this.log(
              `Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.forEach((item) => {
                  this.logHtml(
                    `<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No OHLCV data found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal ohlcv fetch failed: " + e.message,
                "error"
              );
            }
          } else if (args[1] === "trades" && args[2] && args[3]) {
            const network = args[2];
            const poolAddress = args[3];
            this.log(
              `Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`,
              "info"
            );
            try {
              const res = await fetch(
                `${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`
              );
              const data = await res.json();
              if (
                data &&
                data.data &&
                Array.isArray(data.data) &&
                data.data.length > 0
              ) {
                this.logHtml(
                  `<b>Recent trades for pool ${poolAddress}:</b>`,
                  "output"
                );
                data.data.slice(0, 10).forEach((item) => {
                  const trade = item.attributes;
                  this.logHtml(
                    `<b>${trade.timestamp}</b>: <b>${
                      trade.amount_usd || "N/A"
                    } USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${
                      trade.price_usd || "N/A"
                    }</b>`,
                    "output"
                  );
                });
              } else {
                this.logHtml(
                  '<span style="color:#ff3333">No trades found.</span>',
                  "error"
                );
              }
              show404Suggestion(data);
            } catch (e) {
              this.log(
                "GeckoTerminal trades fetch failed: " + e.message,
                "error"
              );
            }
          } else {
            this.log("Type cg help for available commands.", "info");
          }
        }

        async handleAlphaAlias(args) {
          if (args[1] === "help") {
            this.logHtml(
              '<span style="color:#33bbff">Alpha Vantage API Commands:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha quote [symbol]</span> - Get stock quote',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha search [query]</span> - Search for stocks',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha daily [symbol]</span> - Get daily stock data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha overview [symbol]</span> - Get stock overview',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha inflation</span> - Get US inflation data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha cpi</span> - Get US CPI data',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha gdp</span> - Get US GDP data',
              "output"
            );
            this.logHtml(
              '<br><span style="color:#33bbff">Examples:</span>',
              "info"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha quote IBM</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha search Microsoft</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha daily TSLA</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha overview AAPL</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha inflation</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha cpi</span>',
              "output"
            );
            this.logHtml(
              '<span style="color:#99ccff">alpha gdp</span>',
              "output"
            );
            return;
          }
          // Map alpha commands to relayer endpoints
          if (args[1] === "quote" && args[2]) {
            await this.handleStockCommand(["stock", "quote", args[2]]);
          } else if (args[1] === "search" && args[2]) {
            await this.handleStockCommand([
              "stock",
              "search",
              ...args.slice(2),
            ]);
          } else if (args[1] === "daily" && args[2]) {
            await this.handleStockCommand(["stock", "daily", args[2]]);
          } else if (args[1] === "overview" && args[2]) {
            await this.handleStockCommand(["stock", "overview", args[2]]);
          } else if (args[1] === "inflation") {
            await this.handleStockCommand(["stock", "inflation"]);
          } else if (args[1] === "cpi") {
            await this.handleStockCommand(["stock", "cpi"]);
          } else if (args[1] === "gdp") {
            await this.handleStockCommand(["stock", "gdp"]);
          } else {
            this.log("Type alpha help for available commands.", "info");
          }
        }

        async handleCreateCommand(args) {
          if (!this.provider || !this.signer) {
            this.log(
              'Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          // OmegaTokenFactory contract details
          const FACTORY_ADDRESS = "0x1f568dbb3a7b9ea05062b132094a848ef1443cfe";
          const FACTORY_ABI = [
            {
              inputs: [
                { internalType: "string", name: "name_", type: "string" },
                { internalType: "string", name: "symbol_", type: "string" },
                { internalType: "uint8", name: "decimals_", type: "uint8" },
                {
                  internalType: "uint256",
                  name: "initialSupply_",
                  type: "uint256",
                },
                { internalType: "bool", name: "mintable_", type: "bool" },
                { internalType: "bool", name: "pausable_", type: "bool" },
              ],
              name: "createToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              anonymous: false,
              inputs: [
                {
                  indexed: true,
                  internalType: "address",
                  name: "creator",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "address",
                  name: "token",
                  type: "address",
                },
                {
                  indexed: false,
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
                {
                  indexed: false,
                  internalType: "string",
                  name: "symbol",
                  type: "string",
                },
              ],
              name: "TokenCreated",
              type: "event",
            },
            {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allTokens",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "getAllTokens",
              outputs: [
                { internalType: "address[]", name: "", type: "address[]" },
              ],
              stateMutability: "view",
              type: "function",
            },
          ];

          try {
            this.log("🚀 Omega Token Creator", "info");
            this.log(
              "This will deploy a new ERC20 token on the Omega Network",
              "info"
            );
            this.log("", "info");

            // Get token name
            this.log('Enter token name (e.g., "My Awesome Token"):', "info");
            let name = await this.promptTerminalInput(
              'Enter token name (e.g., "My Awesome Token"):'
            );
            name = name ? name.trim() : "";
            if (!name) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            // Get token symbol
            this.log('Enter token symbol (e.g., "MAT"):', "info");
            let symbol = await this.promptTerminalInput(
              'Enter token symbol (e.g., "MAT"):'
            );
            symbol = symbol ? symbol.trim() : "";
            if (!symbol) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            // Get decimals
            this.log("Enter decimals (default 18):", "info");
            let decimalsInput = await this.promptTerminalInput(
              "Enter decimals (default 18):"
            );
            decimalsInput = decimalsInput ? decimalsInput.trim() : "";
            let decimals = 18;
            if (decimalsInput) {
              const parsed = parseInt(decimalsInput);
              if (!isNaN(parsed) && parsed >= 0 && parsed <= 36)
                decimals = parsed;
            }
            document.getElementById("commandInput").value = "";

            // Get initial supply
            this.log("Enter initial supply (e.g., 1000000):", "info");
            let supplyInput = await this.promptTerminalInput(
              "Enter initial supply (e.g., 1000000):"
            );
            supplyInput = supplyInput ? supplyInput.trim() : "";
            if (!supplyInput) {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";
            const initialSupply = this.ethers.BigNumber.from(supplyInput);
            if (initialSupply.lte(0)) {
              this.log(
                "Invalid supply amount. Please enter a positive number.",
                "error"
              );
              return;
            }

            // Get mintable
            this.log("Mintable? (yes/no, default yes):", "info");
            let mintableInput = await this.promptTerminalInput(
              "Mintable? (yes/no, default yes):"
            );
            mintableInput = mintableInput
              ? mintableInput.trim().toLowerCase()
              : "";
            let mintable = true;
            if (mintableInput === "no" || mintableInput === "false")
              mintable = false;
            document.getElementById("commandInput").value = "";

            // Get pausable
            this.log("Pausable? (yes/no, default yes):", "info");
            let pausableInput = await this.promptTerminalInput(
              "Pausable? (yes/no, default yes):"
            );
            pausableInput = pausableInput
              ? pausableInput.trim().toLowerCase()
              : "";
            let pausable = true;
            if (pausableInput === "no" || pausableInput === "false")
              pausable = false;
            document.getElementById("commandInput").value = "";

            this.log("", "info");
            this.log("📋 Token Details:", "info");
            this.log(`Name: ${name}`, "output");
            this.log(`Symbol: ${symbol}`, "output");
            this.log(`Decimals: ${decimals}`, "output");
            this.log(
              `Initial Supply: ${initialSupply.toLocaleString()}`,
              "output"
            );
            this.log(`Mintable: ${mintable ? "Yes" : "No"}`, "output");
            this.log(`Pausable: ${pausable ? "Yes" : "No"}`, "output");
            this.log("", "info");

            this.log("Deploy token? (yes/no):", "info");
            let confirm = await this.promptTerminalInput(
              "Deploy token? (yes/no):"
            );
            confirm = confirm ? confirm.trim().toLowerCase() : "";
            if (confirm !== "yes") {
              this.log("Token creation cancelled.", "warning");
              return;
            }
            document.getElementById("commandInput").value = "";

            this.log("⏳ Deploying token...", "info");

            // Create contract instance
            const factory = new this.ethers.Contract(
              FACTORY_ADDRESS,
              FACTORY_ABI,
              this.signer
            );

            try {
              // Deploy token
              const tx = await factory.createToken(
                name,
                symbol,
                decimals,
                initialSupply,
                mintable,
                pausable
              );
              this.log(`Transaction sent: ${tx.hash}`, "info");

              // Wait for confirmation
              const receipt = await tx.wait();
              this.log("✅ Token deployed successfully!", "success");
              this.log("", "info");

              // Extract token address from events
              let tokenAddress = null;
              for (const log of receipt.logs) {
                try {
                  const parsedLog = factory.interface.parseLog(log);
                  if (parsedLog.name === "TokenCreated") {
                    tokenAddress = parsedLog.args.token;
                    break;
                  }
                } catch (e) {
                  // Continue searching
                }
              }

              if (tokenAddress) {
                this.logHtml(
                  '<span class="success">🎉 <b>Token Deployed!</b></span>',
                  "success"
                );
                this.logHtml(
                  `Token Address: <span class="copyable" onclick="navigator.clipboard.writeText('${tokenAddress}')" style="color:#33bbff;cursor:pointer;">${tokenAddress}</span>`,
                  "output"
                );
                this.logHtml(
                  `Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`,
                  "output"
                );
                this.logHtml(
                  `<b>Name:</b> ${name}<br><b>Symbol:</b> ${symbol}<br><b>Decimals:</b> ${decimals}<br><b>Initial Supply:</b> ${initialSupply.toString()}<br><b>Mintable:</b> ${
                    mintable ? "Yes" : "No"
                  }<br><b>Pausable:</b> ${pausable ? "Yes" : "No"}`,
                  "output"
                );
                this.logHtml(
                  '<span style="color:#99ccff">💡 You can now add liquidity or trade your token!</span>',
                  "info"
                );
              } else {
                this.logHtml(
                  '<span class="warning">⚠️ Token deployed but address not found in events</span>',
                  "warning"
                );
                this.logHtml(
                  `Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`,
                  "output"
                );
              }
            } catch (error) {
              this.log(`❌ Token creation failed: ${error.message}`, "error");
              if (error.code === "ACTION_REJECTED") {
                this.log("Transaction was rejected by user.", "warning");
              } else if (error.code === "INSUFFICIENT_FUNDS") {
                this.log("Insufficient funds for gas fees.", "error");
              } else if (error.code === "UNPREDICTABLE_GAS_LIMIT") {
                this.log(
                  "Tip: Check that the contract address, ABI, and network are correct. Make sure MetaMask is on the right network and the contract is deployed.",
                  "warning"
                );
              }
            }
          } catch (error) {
            this.log(`❌ Token creation failed: ${error.message}`, "error");
            if (error.code === "ACTION_REJECTED") {
              this.log("Transaction was rejected by user.", "warning");
            } else if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("Insufficient funds for gas fees.", "error");
            }
          }
        }

        // 🏆 AMBASSADOR COMMAND HANDLER
        async handleAmbassadorCommand(args) {
          if (!args || args.length < 2) {
            this.log("🏆 OMEGA NETWORK AMBASSADOR COMMANDS", "info");
            this.log("═══════════════════════════════════════", "info");
            this.log("", "info");
            this.log("📋 BASIC COMMANDS:", "info");
            this.log(
              "  ambassador profile [address]     View ambassador profile",
              "output"
            );
            this.log(
              "  ambassador stats [address]       View ambassador statistics",
              "output"
            );
            this.log(
              "  ambassador leaderboard [limit]   View top ambassadors",
              "output"
            );
            this.log(
              "  ambassador directory             View all public ambassadors",
              "output"
            );
            this.log(
              "  ambassador referrals [address]   View ambassador referrals",
              "output"
            );
            this.log(
              "  ambassador generate              Generate referral code",
              "output"
            );
            this.log("", "info");
            this.log("🎯 EXAMPLES:", "info");
            this.log(
              "  ambassador profile 0x1234...     # Specific ambassador",
              "info"
            );
            this.log(
              "  ambassador stats                 # Your stats (if connected)",
              "info"
            );
            this.log(
              "  ambassador leaderboard 20        # Top 20 ambassadors",
              "info"
            );
            this.log(
              "  ambassador generate              # Create referral code",
              "info"
            );
            this.log("", "info");
            this.log(
              "💡 Tip: Connect your wallet first for personalized commands!",
              "success"
            );
            return;
          }

          const subCommand = args[1].toLowerCase();

          try {
            switch (subCommand) {
              case "profile":
                await this.getAmbassadorProfile(args[2]);
                break;
              case "stats":
                await this.getAmbassadorStats(args[2]);
                break;
              case "leaderboard":
                await this.getAmbassadorLeaderboard(args[2]);
                break;
              case "directory":
                await this.getAmbassadorDirectory();
                break;
              case "referrals":
                await this.getAmbassadorReferrals(args[2]);
                break;
              case "generate":
                await this.generateAmbassadorCode();
                break;
              case "help":
                await this.handleAmbassadorCommand([]);
                break;
              default:
                this.log(
                  `❌ Unknown ambassador command: ${subCommand}`,
                  "error"
                );
                this.log(
                  'Type "ambassador help" for available commands',
                  "info"
                );
            }
          } catch (error) {
            console.error("Ambassador command error:", error);
            this.log(`❌ Ambassador command failed: ${error.message}`, "error");
          }
        }

        // 👤 PROFILE COMMAND HANDLER - Enhanced Profile System
        async handleProfileCommand(args) {
          // Use the enhanced profile system
          if (window.handleEnhancedProfileCommand) {
            window.handleEnhancedProfileCommand(args.slice(1));
          } else if (window.openEnhancedProfile) {
            // Direct fallback to open profile
            window.openEnhancedProfile();
          } else {
            this.log("👤 Enhanced Profile System", "info");
            this.log("🔗 Omega ENS registration & management", "info");
            this.log("📇 Address book for contacts", "info");
            this.log("💬 Terminal Chatter (Telegram-like)", "info");
            this.log("🖥️ Fullscreen profile mode", "info");
            this.log("💡 Commands: profile open | profile help", "info");
          }
        }

        // 🔑 API KEY MANAGEMENT
        async handleProfileApiKeys(args) {
          if (!args || args.length === 0) {
            this.showApiKeysHelp();
            return;
          }

          const subcommand = args[0];

          switch (subcommand) {
            case "list":
              await this.listApiKeys();
              break;
            case "set":
              await this.setApiKey(args[1], args.slice(2).join(" "));
              break;
            case "remove":
            case "delete":
              await this.removeApiKey(args[1]);
              break;
            case "show":
              await this.showApiKey(args[1]);
              break;
            case "help":
              this.showApiKeysHelp();
              break;
            default:
              this.log(`❌ Unknown API keys command: ${subcommand}`, "error");
              this.showApiKeysHelp();
          }
        }

        showApiKeysHelp() {
          this.log("🔑 API KEY MANAGEMENT", "info");
          this.log("═══════════════════════════════════", "info");
          this.log("", "info");
          this.log("📋 AVAILABLE COMMANDS:", "info");
          this.log(
            "  profile apikeys list             List all stored API keys",
            "output"
          );
          this.log(
            "  profile apikeys set <service>    Set an API key for a service",
            "output"
          );
          this.log(
            "  profile apikeys show <service>   Show an API key (masked)",
            "output"
          );
          this.log(
            "  profile apikeys remove <service> Remove an API key",
            "output"
          );
          this.log(
            "  profile apikeys help             Show this help message",
            "output"
          );
          this.log("", "info");
          this.log("🎯 SUPPORTED SERVICES:", "info");
          this.log("  • alpha      - Alpha Vantage stock data", "output");
          this.log("  • opensea    - OpenSea NFT marketplace", "output");
          this.log("  • magiceden  - Magic Eden NFT marketplace", "output");
          this.log("  • coingecko  - CoinGecko crypto data", "output");
          this.log("", "info");
          this.log(
            "💡 Note: Kalshi uses server-side authentication (no client keys needed)",
            "info"
          );
          this.log("", "info");
          this.log("🎯 EXAMPLES:", "info");
          this.log("  profile apikeys list", "info");
          this.log(
            "  profile apikeys set alpha YOUR_ALPHA_VANTAGE_KEY",
            "info"
          );
          this.log("  profile apikeys show alpha", "info");
          this.log("  profile apikeys remove alpha", "info");
          this.log("", "info");
          this.log("💡 API keys are stored locally in your browser", "info");
        }

        getApiKeyStorageKey() {
          return "omega_terminal_api_keys";
        }

        getAllApiKeys() {
          const keysJson = localStorage.getItem(this.getApiKeyStorageKey());
          if (!keysJson) {
            return {};
          }
          try {
            return JSON.parse(keysJson);
          } catch (e) {
            console.error("Failed to parse API keys:", e);
            return {};
          }
        }

        saveAllApiKeys(keys) {
          try {
            localStorage.setItem(
              this.getApiKeyStorageKey(),
              JSON.stringify(keys)
            );
            return true;
          } catch (e) {
            console.error("Failed to save API keys:", e);
            return false;
          }
        }

        getApiKey(service) {
          const keys = this.getAllApiKeys();
          return keys[service.toLowerCase()] || null;
        }

        async listApiKeys() {
          const keys = this.getAllApiKeys();
          const serviceNames = Object.keys(keys);

          if (serviceNames.length === 0) {
            this.log("📭 No API keys stored", "warning");
            this.log("", "info");
            this.log(
              '💡 Use "profile apikeys set <service> <key>" to add an API key',
              "info"
            );
            return;
          }

          this.log("🔑 STORED API KEYS", "success");
          this.log("═══════════════════════════════════", "success");
          this.log("", "info");

          serviceNames.forEach((service, index) => {
            const key = keys[service];
            const maskedKey = this.maskApiKey(key);
            this.log(`${index + 1}. ${service.toUpperCase()}`, "output");
            this.log(`   Key: ${maskedKey}`, "info");
            this.log(`   Status: ✅ Active`, "success");
            this.log("", "info");
          });

          this.log(
            '💡 Use "profile apikeys show <service>" to see full key',
            "info"
          );
        }

        async setApiKey(service, key) {
          if (!service) {
            this.log("❌ Please specify a service", "error");
            this.log("Usage: profile apikeys set <service> <key>", "info");
            this.log(
              "Example: profile apikeys set alpha YOUR_API_KEY_HERE",
              "info"
            );
            return;
          }

          if (!key || key.trim() === "") {
            this.log("❌ Please provide an API key", "error");
            this.log("Usage: profile apikeys set <service> <key>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const keys = this.getAllApiKeys();
          keys[serviceLower] = key.trim();

          if (this.saveAllApiKeys(keys)) {
            this.log(
              `✅ API key for ${service.toUpperCase()} saved successfully!`,
              "success"
            );
            this.log("", "info");
            this.log(
              `🎯 You can now use ${serviceLower} commands without setting the API key each time`,
              "info"
            );

            // Special handling for different services
            switch (serviceLower) {
              case "kalshi":
                this.log("💡 Try: kalshi markets", "info");
                break;
              case "alpha":
                this.log("💡 Try: alpha quote AAPL", "info");
                break;
              case "opensea":
                this.log(
                  "💡 Try: opensea collection <collection-slug>",
                  "info"
                );
                break;
            }
          } else {
            this.log("❌ Failed to save API key", "error");
          }
        }

        async removeApiKey(service) {
          if (!service) {
            this.log("❌ Please specify a service", "error");
            this.log("Usage: profile apikeys remove <service>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const keys = this.getAllApiKeys();

          if (!keys[serviceLower]) {
            this.log(
              `❌ No API key found for ${service.toUpperCase()}`,
              "error"
            );
            return;
          }

          delete keys[serviceLower];

          if (this.saveAllApiKeys(keys)) {
            this.log(
              `✅ API key for ${service.toUpperCase()} removed successfully!`,
              "success"
            );
          } else {
            this.log("❌ Failed to remove API key", "error");
          }
        }

        async showApiKey(service) {
          if (!service) {
            this.log("❌ Please specify a service", "error");
            this.log("Usage: profile apikeys show <service>", "info");
            return;
          }

          const serviceLower = service.toLowerCase();
          const key = this.getApiKey(serviceLower);

          if (!key) {
            this.log(
              `❌ No API key found for ${service.toUpperCase()}`,
              "error"
            );
            this.log('💡 Use "profile apikeys set" to add one', "info");
            return;
          }

          this.log(`🔑 API KEY: ${service.toUpperCase()}`, "info");
          this.log("═══════════════════════════════════", "info");
          this.log("", "info");
          this.log(`🔐 Full Key: ${key}`, "output");
          this.log("", "info");
          this.log(
            "⚠️  Keep your API key secure and never share it publicly!",
            "warning"
          );
        }

        maskApiKey(key) {
          if (!key || key.length < 8) {
            return "****";
          }
          const start = key.substring(0, 4);
          const end = key.substring(key.length - 4);
          return `${start}${"*".repeat(Math.min(key.length - 8, 20))}${end}`;
        }

        async getAmbassadorProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "❌ Please provide a wallet address or connect your wallet",
                  "error"
                );
                this.log("Usage: ambassador profile 0x1234...", "info");
                return;
              }
            } else {
              this.log(
                "❌ Please provide a wallet address or connect your wallet",
                "error"
              );
              this.log("Usage: ambassador profile 0x1234...", "info");
              return;
            }
          }

          this.log(
            `👤 Loading ambassador profile for: ${walletAddress}`,
            "info"
          );

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/${encodeURIComponent(
                walletAddress
              )}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            const profile = data.data;

            this.log("✅ AMBASSADOR PROFILE", "success");
            this.log("═══════════════════════", "success");
            this.log(`👤 Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `🏷️  Display Name: ${profile.display_name || "Not set"}`,
              "info"
            );
            this.log(`📍 Location: ${profile.location || "Not set"}`, "info");
            this.log(`🐦 Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`💬 Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`🌐 Website: ${profile.website || "Not set"}`, "info");
            this.log(`📊 Level: ${profile.level || 1}`, "info");
            this.log(`🏆 Points: ${profile.total_points || 0}`, "info");
            this.log(`🎯 Referrals: ${profile.referrals_count || 0}`, "info");
            this.log(`🏅 Tier: ${profile.rank || "BRONZE"}`, "info");
          } catch (error) {
            this.log(
              `❌ Failed to load ambassador profile: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorStats(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "❌ Please provide a wallet address or connect your wallet",
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "❌ Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log(`📊 Loading ambassador stats for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            const profile = data.data.profile;
            const interactions = data.data.discoverInteractions || [];

            this.log("✅ AMBASSADOR STATISTICS", "success");
            this.log("═══════════════════════════", "success");
            this.log(`👤 Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `🏷️  Display Name: ${profile.displayName || "Not set"}`,
              "info"
            );
            this.log(`🐦 Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`💬 Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`📊 Recent Activities: ${interactions.length}`, "info");
            this.log(
              `🔗 Profile Public: ${profile.isPublic ? "Yes" : "No"}`,
              "info"
            );

            // Try to get referral data separately
            try {
              const refResponse = await fetch(
                `${OMEGA_API_URL}/v1/referrals/validate/${
                  profile.username || "unknown"
                }`
              );
              const refData = await refResponse.json();
              if (refData.success && refData.data.isValid) {
                this.log(`🎯 Referral Status: Active Ambassador`, "success");
              }
            } catch (refError) {
              this.log(`🎯 Referral Status: Unknown`, "warning");
            }
          } catch (error) {
            this.log(
              `❌ Failed to load ambassador stats: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorLeaderboard(limit) {
          const queryLimit = limit || 10;

          this.log(`🏆 Loading top ${queryLimit} ambassadors...`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/leaderboard?limit=${queryLimit}`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            this.log("🏆 AMBASSADOR LEADERBOARD", "success");
            this.log("═══════════════════════════════", "success");
            this.log("", "info");

            data.data.forEach((ambassador, index) => {
              const emoji =
                ambassador.rank === 1
                  ? "🥇"
                  : ambassador.rank === 2
                  ? "🥈"
                  : ambassador.rank === 3
                  ? "🥉"
                  : "🏅";

              this.log(
                `${emoji} #${ambassador.rank} ${ambassador.displayName}`,
                "info"
              );
              this.log(
                `   👤 @${ambassador.username} | 🎯 ${ambassador.totalReferrals} referrals | 🏆 ${ambassador.totalPoints} points`,
                "info"
              );
              this.log(
                `   🏅 ${ambassador.tier} | 📈 Level ${ambassador.level}`,
                "info"
              );
              this.log("", "info");
            });

            if (data.pagination) {
              this.log(
                `📊 Showing ${data.data.length} of ${data.pagination.total} ambassadors`,
                "info"
              );
            }
          } catch (error) {
            this.log(
              `❌ Failed to load ambassador leaderboard: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorDirectory() {
          this.log("🌐 Loading ambassador directory...", "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/directory`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            this.log("🌐 AMBASSADOR DIRECTORY", "success");
            this.log("═══════════════════════════", "success");
            this.log("", "info");

            data.data.forEach((ambassador, index) => {
              this.log(
                `👤 ${ambassador.display_name || ambassador.username}`,
                "success"
              );
              if (ambassador.bio) {
                this.log(`   📝 ${ambassador.bio}`, "info");
              }
              this.log(
                `   🎯 ${ambassador.referral_count || 0} referrals | 🏆 ${
                  ambassador.total_points || 0
                } points`,
                "info"
              );
              if (ambassador.website) {
                this.logHtml(
                  `   🌐 <a href="${ambassador.website}" target="_blank" style="color:#33bbff;">${ambassador.website}</a>`,
                  "info"
                );
              }
              this.log("", "info");
            });
          } catch (error) {
            this.log(
              `❌ Failed to load ambassador directory: ${error.message}`,
              "error"
            );
          }
        }

        async getAmbassadorReferrals(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  "❌ Please provide a wallet address or connect your wallet",
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "❌ Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log(`🔗 Loading referrals for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/ambassadors/${walletAddress}/referrals`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            this.log("🔗 AMBASSADOR REFERRALS", "success");
            this.log("═══════════════════════════", "success");
            this.log("", "info");

            if (data.data.length === 0) {
              this.log(
                "📭 No referrals yet. Start sharing your ambassador link!",
                "info"
              );
              return;
            }

            data.data.forEach((referral, index) => {
              const status = referral.status === "COMPLETED" ? "✅" : "⏳";
              const date = new Date(referral.created_at).toLocaleDateString();

              this.log(`${status} ${referral.referral_code}`, "info");

              if (referral.referred_address) {
                this.log(
                  `   👤 Referred: ${referral.referred_address.substring(
                    0,
                    10
                  )}...`,
                  "info"
                );
                this.log(
                  `   ✅ Completed: ${new Date(
                    referral.completed_at
                  ).toLocaleDateString()}`,
                  "success"
                );
              } else {
                this.log("   ⏳ Pending - waiting for signup", "warning");
              }

              this.log(`   📅 Created: ${date}`, "info");
              this.log("", "info");
            });
          } catch (error) {
            this.log(
              `❌ Failed to load ambassador referrals: ${error.message}`,
              "error"
            );
          }
        }

        async generateAmbassadorCode() {
          if (!this.signer) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("🎯 Generating ambassador referral code...", "info");

          try {
            // First get user's profile to retrieve username
            this.log("📝 Checking your profile for username...", "info");
            let username = null;

            try {
              const profileResponse = await fetch(
                `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
              );
              const profileData = await profileResponse.json();

              if (profileData.success && profileData.data.profile.username) {
                username = profileData.data.profile.username;
                this.log(`✅ Found username: ${username}`, "success");
              } else {
                this.log(
                  '⚠️ No username found in profile. Please set up your profile first using "profile register"',
                  "error"
                );
                this.log(
                  "   This is required for proper referral credit tracking.",
                  "error"
                );
                return;
              }
            } catch (profileError) {
              this.log(
                '⚠️ Could not retrieve your profile. Please set up your profile first using "profile register"',
                "error"
              );
              this.log(
                "   This is required for proper referral credit tracking.",
                "error"
              );
              return;
            }

            // Generate the referral code
            const response = await fetch(
              `${OMEGA_API_URL}/v1/referrals/generate-code`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ walletAddress: walletAddress }),
              }
            );

            const data = await response.json();

            if (!data.success) {
              this.log(`❌ ${data.error}`, "error");
              return;
            }

            const result = data.data;

            if (result.alreadyExists) {
              this.log("ℹ️ You already have an ambassador code!", "info");
            } else {
              this.log("✅ Ambassador code generated successfully!", "success");
            }

            this.log("🎯 YOUR AMBASSADOR CODE", "success");
            this.log("═══════════════════════════", "success");
            this.log(`🔑 Code: ${result.referralCode}`, "success");
            this.log(`👤 Username: ${username}`, "success");
            this.logHtml(
              `🔗 Link: <span class="copyable" onclick="navigator.clipboard.writeText('https://omeganetwork.co/${username}/${result.referralCode}').then(() => window.terminal.log('✅ Ambassador link copied to clipboard!', 'success'))" style="color:#33bbff; cursor:pointer; text-decoration:underline;">https://omeganetwork.co/${username}/${result.referralCode}</span>`,
              "info"
            );
            this.log("", "info");
            this.log(
              "💡 Use: ambassador stats (to track your progress)",
              "info"
            );
          } catch (error) {
            this.log(
              `❌ Failed to generate ambassador code: ${error.message}`,
              "error"
            );
          }
        }

        // 👤 PROFILE MANAGEMENT FUNCTIONS
        async getUserProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '❌ Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                '❌ Please connect your wallet first using "connect"',
                "error"
              );
              return;
            }
          }

          this.log(`👤 Loading profile for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(
                `❌ Profile not found. Use "profile register" to create one.`,
                "error"
              );
              return;
            }

            const profile = data.data.profile;

            this.log("👤 USER PROFILE", "success");
            this.log("═══════════════", "success");
            this.log(`🏷️  Username: ${profile.username || "Not set"}`, "info");
            this.log(
              `📝 Display Name: ${profile.displayName || "Not set"}`,
              "info"
            );
            this.log(`📍 Location: ${profile.location || "Not set"}`, "info");
            this.log(`💬 Bio: ${profile.bio || "Not set"}`, "info");
            this.log(`🌐 Website: ${profile.website || "Not set"}`, "info");
            this.log(`🐦 Twitter: ${profile.twitter || "Not set"}`, "info");
            this.log(`💬 Discord: ${profile.discord || "Not set"}`, "info");
            this.log(`🐙 GitHub: ${profile.github || "Not set"}`, "info");
            this.log(`📱 Telegram: ${profile.telegram || "Not set"}`, "info");
            this.log(`📧 Email: ${profile.email || "Not set"}`, "info");
            this.log(`🔓 Public: ${profile.isPublic ? "Yes" : "No"}`, "info");
            this.log("", "info");
            this.log(
              "💡 Use: profile update (to modify your profile)",
              "success"
            );
          } catch (error) {
            this.log(`❌ Failed to load profile: ${error.message}`, "error");
          }
        }

        async registerUserProfile() {
          if (!this.signer) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("👤 PROFILE REGISTRATION", "success");
          this.log("══════════════════════", "success");
          this.log("", "info");
          this.log("📝 Let's set up your Omega Network profile!", "info");
          this.log("💡 You can skip any field by pressing Enter", "info");
          this.log("", "info");

          // Start guided registration
          this.profileRegistrationStep = 1;
          this.profileData = { walletAddress };
          this.awaitingInput = true;
          this.inputType = "profile_username";

          this.log("🏷️  Enter your username:", "info");
          this.log("    (3-20 characters, letters/numbers only)", "output");
        }

        async updateUserProfile() {
          if (!this.signer) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          // First check if profile exists
          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(
                '❌ No profile found. Use "profile register" to create one first.',
                "error"
              );
              return;
            }

            this.log("👤 PROFILE UPDATE", "success");
            this.log("═══════════════", "success");
            this.log("", "info");
            this.log("📝 Let's update your profile! Current values:", "info");

            const profile = data.data.profile;
            this.log(
              `🏷️  Username: ${profile.username || "Not set"}`,
              "output"
            );
            this.log(
              `📝 Display Name: ${profile.displayName || "Not set"}`,
              "output"
            );
            this.log(`📍 Location: ${profile.location || "Not set"}`, "output");
            this.log("", "info");
            this.log(
              "💡 Enter new values (or press Enter to keep current)",
              "info"
            );
            this.log("", "info");

            // Start guided update
            this.profileRegistrationStep = 1;
            this.profileData = { walletAddress, ...profile };
            this.awaitingInput = true;
            this.inputType = "profile_username";

            this.log("🏷️  Enter new username:", "info");
            this.log(`    Current: ${profile.username || "Not set"}`, "output");
          } catch (error) {
            this.log(
              `❌ Failed to load current profile: ${error.message}`,
              "error"
            );
          }
        }

        async getUserActivity(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '❌ Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                '❌ Please connect your wallet first using "connect"',
                "error"
              );
              return;
            }
          }

          this.log(`📊 Loading activity for: ${walletAddress}`, "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/activity?limit=10`
            );
            const data = await response.json();

            if (!data.success) {
              this.log(`❌ No activity found for this address`, "error");
              return;
            }

            this.log("📊 USER ACTIVITY (Last 10)", "success");
            this.log("═══════════════════════════", "success");

            const activities = data.data;
            if (activities.length === 0) {
              this.log("📭 No recent activity found", "info");
              return;
            }

            activities.forEach((activity, index) => {
              const date = new Date(activity.createdAt).toLocaleDateString();
              this.log(`${index + 1}. ${activity.action} - ${date}`, "output");
            });
          } catch (error) {
            this.log(`❌ Failed to load activity: ${error.message}`, "error");
          }
        }

        // Profile registration input handler
        async handleProfileRegistrationInput(input) {
          switch (this.inputType) {
            case "profile_username":
              if (
                input &&
                input.length >= 3 &&
                input.length <= 20 &&
                /^[a-zA-Z0-9_]+$/.test(input)
              ) {
                this.profileData.username = input;
                this.log(`✅ Username: ${input}`, "success");
              } else if (input) {
                this.log(
                  "❌ Username must be 3-20 characters, letters/numbers/underscore only",
                  "error"
                );
                this.log("🏷️  Enter your username:", "info");
                return;
              }

              this.profileRegistrationStep = 2;
              this.inputType = "profile_display_name";
              this.log("", "info");
              this.log("📝 Enter your display name:", "info");
              this.log("    (The name others will see)", "output");
              break;

            case "profile_display_name":
              if (input && input.length <= 50) {
                this.profileData.displayName = input;
                this.log(`✅ Display Name: ${input}`, "success");
              }

              this.profileRegistrationStep = 3;
              this.inputType = "profile_bio";
              this.log("", "info");
              this.log("💬 Enter your bio:", "info");
              this.log("    (Optional - tell others about yourself)", "output");
              break;

            case "profile_bio":
              if (input && input.length <= 200) {
                this.profileData.bio = input;
                this.log(`✅ Bio: ${input}`, "success");
              }

              this.profileRegistrationStep = 4;
              this.inputType = "profile_location";
              this.log("", "info");
              this.log("📍 Enter your location:", "info");
              this.log("    (Optional - country, city, etc.)", "output");
              break;

            case "profile_location":
              if (input && input.length <= 100) {
                this.profileData.location = input;
                this.log(`✅ Location: ${input}`, "success");
              }

              this.profileRegistrationStep = 5;
              this.inputType = "profile_twitter";
              this.log("", "info");
              this.log("🐦 Enter your Twitter handle:", "info");
              this.log("    (Optional - without @)", "output");
              break;

            case "profile_twitter":
              if (input && input.length <= 50) {
                this.profileData.twitter = input;
                this.log(`✅ Twitter: @${input}`, "success");
              }

              this.profileRegistrationStep = 6;
              this.inputType = "profile_discord";
              this.log("", "info");
              this.log("💬 Enter your Discord ID:", "info");
              this.log(
                "    (Optional - your Discord username or ID)",
                "output"
              );
              break;

            case "profile_discord":
              if (input && input.length <= 50) {
                this.profileData.discord = input;
                this.log(`✅ Discord: ${input}`, "success");
              }

              this.profileRegistrationStep = 7;
              this.inputType = "profile_email";
              this.log("", "info");
              this.log("📧 Enter your email address:", "info");
              this.log(
                "    (Optional - for notifications and updates)",
                "output"
              );
              break;

            case "profile_email":
              if (
                input &&
                input.includes("@") &&
                input.includes(".") &&
                input.length <= 100
              ) {
                this.profileData.email = input;
                this.log(`✅ Email: ${input}`, "success");
              } else if (input && input.length > 0) {
                this.log("❌ Please enter a valid email address", "error");
                this.log("📧 Enter your email address:", "info");
                return;
              }

              this.profileRegistrationStep = 8;
              this.inputType = "profile_confirmation";
              this.log("", "info");
              this.log("✨ PROFILE SUMMARY", "success");
              this.log("═══════════════════", "success");
              this.log(
                `🏷️  Username: ${this.profileData.username || "Not set"}`,
                "info"
              );
              this.log(
                `📝 Display Name: ${this.profileData.displayName || "Not set"}`,
                "info"
              );
              this.log(`💬 Bio: ${this.profileData.bio || "Not set"}`, "info");
              this.log(
                `📍 Location: ${this.profileData.location || "Not set"}`,
                "info"
              );
              this.log(
                `🐦 Twitter: ${this.profileData.twitter || "Not set"}`,
                "info"
              );
              this.log(
                `💬 Discord: ${this.profileData.discord || "Not set"}`,
                "info"
              );
              this.log(
                `📧 Email: ${this.profileData.email || "Not set"}`,
                "info"
              );
              this.log("", "info");
              this.log("✅ Confirm registration? (yes/no):", "info");
              break;

            case "profile_confirmation":
              const confirm = input.toLowerCase();
              this.awaitingInput = false;
              this.inputType = null;

              if (confirm === "yes" || confirm === "y") {
                await this.submitUserProfile();
              } else {
                this.log("❌ Profile registration cancelled", "error");
                this.log('💡 Use "profile register" to try again', "info");
              }
              break;
          }
        }

        async submitUserProfile() {
          this.log("📤 Submitting your profile...", "info");

          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${this.profileData.walletAddress}/profile`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  username: this.profileData.username,
                  displayName: this.profileData.displayName,
                  bio: this.profileData.bio,
                  location: this.profileData.location,
                  twitter: this.profileData.twitter,
                  discord: this.profileData.discord,
                  email: this.profileData.email,
                }),
              }
            );

            const data = await response.json();

            if (!data.success) {
              this.log(`❌ Registration failed: ${data.error}`, "error");
              return;
            }

            this.log("🎉 PROFILE REGISTERED SUCCESSFULLY!", "success");
            this.log("═══════════════════════════════════", "success");
            this.log(
              `✅ Welcome to Omega Network, ${
                this.profileData.displayName || this.profileData.username
              }!`,
              "success"
            );
            this.log("", "info");
            this.log("🎯 What's next:", "info");
            this.log('  • Use "profile" to view your profile', "output");
            this.log(
              '  • Use "ambassador generate" to become an ambassador',
              "output"
            );
            this.log(
              '  • Use "profile activity" to track your progress',
              "output"
            );
            this.log("", "info");

            // Clear registration data
            this.profileData = null;
            this.profileRegistrationStep = 0;
          } catch (error) {
            this.log(`❌ Registration failed: ${error.message}`, "error");
          }
        }

        // 🐛 PROFILE DEBUG FUNCTIONS
        async debugUserProfile(address) {
          let walletAddress = address;

          if (!walletAddress) {
            if (this.signer) {
              try {
                walletAddress = await this.signer.getAddress();
              } catch (error) {
                this.log(
                  '❌ Please connect your wallet first using "connect"',
                  "error"
                );
                return;
              }
            } else {
              this.log(
                "❌ Please provide a wallet address or connect your wallet",
                "error"
              );
              return;
            }
          }

          this.log("🐛 PROFILE DEBUG MODE", "success");
          this.log("═══════════════════════", "success");
          this.log(`🔍 Testing profile for: ${walletAddress}`, "info");
          this.log("", "info");

          // Test MAIN API endpoint
          this.log("1. 🌐 OMEGA API TEST (omeganetwork.co)", "info");
          this.log("   ─────────────────────────────────────────", "info");
          try {
            const localResponse = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   📡 Status: ${localResponse.status}`,
              localResponse.ok ? "success" : "error"
            );

            const localData = await localResponse.json();
            this.log(
              `   📝 Success: ${localData.success}`,
              localData.success ? "success" : "error"
            );

            if (localData.success && localData.data.profile) {
              const profile = localData.data.profile;
              this.log(
                `   👤 Username: ${profile.username || "NOT FOUND"}`,
                profile.username ? "success" : "error"
              );
              this.log(
                `   📝 Display Name: ${profile.displayName || "NOT FOUND"}`,
                "info"
              );
              this.log(`   📧 Email: ${profile.email || "NOT FOUND"}`, "info");
              this.log(`   🔓 Public: ${profile.isPublic}`, "info");
            } else {
              this.log(
                `   ❌ Error: ${localData.error || "No profile data"}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`   💥 Failed: ${error.message}`, "error");
          }

          this.log("", "info");

          // Test PRODUCTION RELAYER endpoint
          this.log(
            "2. ⚙️ PRODUCTION RELAYER TEST (terminal-v1-5-9.onrender.com)",
            "info"
          );
          this.log("   ─────────────────────────────────────────", "info");
          try {
            const prodResponse = await fetch(
              `${RELAYER_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   📡 Status: ${prodResponse.status}`,
              prodResponse.ok ? "success" : "error"
            );

            const prodData = await prodResponse.json();
            this.log(
              `   📝 Success: ${prodData.success}`,
              prodData.success ? "success" : "error"
            );

            if (prodData.success && prodData.data.profile) {
              const profile = prodData.data.profile;
              this.log(
                `   👤 Username: ${profile.username || "NOT FOUND"}`,
                profile.username ? "success" : "error"
              );
              this.log(
                `   📝 Display Name: ${profile.displayName || "NOT FOUND"}`,
                "info"
              );
              this.log(`   📧 Email: ${profile.email || "NOT FOUND"}`, "info");
              this.log(`   🔓 Public: ${profile.isPublic}`, "info");
            } else {
              this.log(
                `   ❌ Error: ${prodData.error || "No profile data"}`,
                "error"
              );
            }
          } catch (error) {
            this.log(`   💥 Failed: ${error.message}`, "error");
          }

          this.log("", "info");
          this.log("🎯 DIAGNOSIS:", "success");
          this.log(
            "• If OMEGA API has username but RELAYER doesn't: Use main API for profiles",
            "info"
          );
          this.log(
            "• If both have same username: Data sync is working",
            "info"
          );
          this.log(
            "• If neither has username: Profile registration failed",
            "info"
          );
          this.log(
            "• If RELAYER shows 404: Production relayer missing profile endpoints",
            "info"
          );
        }

        async testProfileEndpoints() {
          if (!this.signer) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          let walletAddress;
          try {
            walletAddress = await this.signer.getAddress();
          } catch (error) {
            this.log(
              '❌ Please connect your wallet first using "connect"',
              "error"
            );
            return;
          }

          this.log("🧪 PROFILE ENDPOINT TESTS", "success");
          this.log("═══════════════════════════", "success");

          // Test 1: Check if production relayer is running
          this.log("1. 🔗 Testing production relayer connection...", "info");
          try {
            const healthResponse = await fetch(
              `${RELAYER_URL}/api/health/liveness`
            );
            if (healthResponse.ok) {
              this.log("   ✅ Production relayer is running!", "success");
            } else {
              this.log(
                "   ❌ Production relayer returned error status",
                "error"
              );
            }
          } catch (error) {
            this.log(
              `   💥 Production relayer connection failed: ${error.message}`,
              "error"
            );
            this.log(
              "   💡 Check if terminal-v1-5-9.onrender.com is up",
              "info"
            );
          }

          // Test 2: Test profile GET endpoint
          this.log("", "info");
          this.log("2. 📖 Testing profile GET endpoint...", "info");
          try {
            const response = await fetch(
              `${OMEGA_API_URL}/v1/users/${walletAddress}/profile`
            );
            this.log(
              `   📡 Response status: ${response.status}`,
              response.ok ? "success" : "error"
            );

            const data = await response.json();
            this.log(`   📝 Response data:`, "info");
            this.log(`      ${JSON.stringify(data, null, 2)}`, "output");
          } catch (error) {
            this.log(`   💥 GET test failed: ${error.message}`, "error");
          }

          // Test 3: Test profile POST endpoint with dummy data
          this.log("", "info");
          this.log("3. 📝 Testing profile POST endpoint (dry run)...", "info");
          try {
            const testData = {
              username: "test_user_debug",
              displayName: "Debug Test User",
              bio: "This is a test profile for debugging",
              email: "debug@test.com",
            };

            this.log(
              `   📤 Test payload: ${JSON.stringify(testData, null, 2)}`,
              "output"
            );
            this.log("   ℹ️ This would POST to:", "info");
            this.log(
              `   ${OMEGA_API_URL}/v1/users/${walletAddress}/profile`,
              "output"
            );
            this.log(
              '   💡 Use "profile register" to actually save data',
              "info"
            );
          } catch (error) {
            this.log(`   💥 POST test setup failed: ${error.message}`, "error");
          }

          this.log("", "info");
          this.log("🎯 NEXT STEPS:", "success");
          this.log(
            "• If connection fails: Check if production servers are up",
            "info"
          );
          this.log(
            '• If GET works: Use "profile debug" to compare main API vs relayer',
            "info"
          );
          this.log(
            '• If POST endpoint exists: Try "profile register" again',
            "info"
          );
        }

        // 🎨 GUI THEME COMMAND HANDLER
        handleGuiCommand(args) {
          if (!args || args.length < 2) {
            this.log("🎨 OMEGA TERMINAL GUI THEMES", "info");
            this.log("═══════════════════════════════", "info");
            this.log("", "info");
            this.log("📱 AVAILABLE THEMES:", "info");
            this.log(
              "  gui ios          iOS Messages-style interface",
              "output"
            );
            this.log(
              "  gui chatgpt      ChatGPT-style conversation interface",
              "output"
            );
            this.log(
              "  gui discord      Discord-style chat interface",
              "output"
            );
            this.log(
              "  gui aol          Retro AOL instant messenger style",
              "output"
            );
            this.log(
              "  gui windows95    Authentic Windows 95 DOS interface",
              "output"
            );
            this.log(
              "  gui limewire     P2P file sharing retro interface",
              "output"
            );
            this.log(
              "  gui off          Return to standard terminal",
              "output"
            );
            this.log("", "info");
            this.log("🎯 EXAMPLES:", "info");
            this.log(
              "  gui ios          # Switch to iOS Messages theme",
              "info"
            );
            this.log("  gui chatgpt      # Switch to ChatGPT theme", "info");
            this.log("  gui discord      # Switch to Discord theme", "info");
            this.log("  gui off          # Back to normal terminal", "info");
            this.log("", "info");
            this.log(
              "💡 Each theme completely transforms the interface!",
              "success"
            );
            return;
          }

          const theme = args[1].toLowerCase();

          // Remove all existing GUI theme classes
          document.body.classList.remove(
            "gui-chatgpt",
            "gui-ios",
            "gui-discord",
            "gui-aol",
            "gui-windows95",
            "gui-limewire"
          );

          switch (theme) {
            case "ios":
              document.body.classList.add("gui-ios");
              this.setupiOSInterface();
              this.log("✅ Switched to iOS Messages theme", "success");
              this.log(
                "📱 You now have an iPhone-style messaging interface!",
                "info"
              );
              break;
            case "chatgpt":
              document.body.classList.add("gui-chatgpt");
              this.setupChatGPTInterface();
              this.log("✅ Switched to ChatGPT theme", "success");
              this.log(
                "💬 You now have a conversational AI interface!",
                "info"
              );
              break;
            case "discord":
              document.body.classList.add("gui-discord");
              this.setupDiscordInterface();
              this.log("✅ Switched to Discord theme", "success");
              this.log(
                "🎮 You now have a Discord-style chat interface!",
                "info"
              );
              break;
            case "aol":
              document.body.classList.add("gui-aol");
              this.setupAOLInterface();
              this.log("✅ Switched to AOL theme", "success");
              this.log(
                "📞 Welcome to the 90s instant messenger experience!",
                "info"
              );
              break;
            case "windows95":
              document.body.classList.add("gui-windows95");
              this.setupWindows95Interface();
              this.log("✅ Switched to Windows 95 theme", "success");
              this.log("💻 Authentic retro DOS window experience!", "info");
              break;
            case "limewire":
              document.body.classList.add("gui-limewire");
              this.setupLimewireInterface();
              this.log("✅ Switched to Limewire theme", "success");
              this.log(
                "🎵 P2P file sharing retro interface activated!",
                "info"
              );
              break;
            case "off":
            case "normal":
            case "default":
              this.restoreOriginalTerminal();
              this.log("✅ Returned to standard terminal theme", "success");
              this.log("🖥️ Classic terminal interface restored", "info");
              break;
            default:
              this.log(`❌ Unknown GUI theme: ${theme}`, "error");
              this.log('Type "gui" for available themes', "info");
          }
        }

        setupChatGPTInterface() {
          // Transform terminal into ChatGPT-style interface
          this.log("🤖 ChatGPT interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-chatgpt";

          // Create ChatGPT interface structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: #212121; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
                        <!-- Header with back button -->
                        <div style="position: absolute; top: 20px; left: 20px; z-index: 100;">
                            <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                    style="background: #424242; color: #ececec; border: 1px solid #565656; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                                ← Terminal
                            </button>
                        </div>
                        
                        <!-- Conversation area -->
                        <div class="chatgpt-conversation" style="flex: 1; overflow-y: auto; padding: 80px 20px 200px 20px; max-width: 768px; margin: 0 auto; width: 100%;">
                            <div style="text-align: center; margin-bottom: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">🤖</div>
                                <h1 style="color: #ececec; font-size: 32px; font-weight: 300; margin: 0;">Omega Terminal AI</h1>
                                <p style="color: #8e8ea0; margin-top: 12px; font-size: 16px;">Type any command below!</p>
                            </div>
                        </div>
                        
                        <!-- Centered input at bottom -->
                        <div style="position: fixed; bottom: 0; left: 0; right: 0; background: #212121; padding: 32px 20px; border-top: 1px solid #424242;">
                            <div style="max-width: 768px; margin: 0 auto;">
                                <div style="position: relative; display: flex; align-items: center; background: #2f2f2f; border: 1px solid #565656; border-radius: 24px; padding: 12px 16px;">
                                    <div style="color: #8e8ea0; margin-right: 12px; font-size: 20px;">+</div>
                                    <input type="text" 
                                           placeholder="Type any terminal command..." 
                                           id="chatgptInput" 
                                           onkeypress="if(event.key==='Enter') window.terminal.handleChatGPTCommand();"
                                           style="flex: 1; background: none; border: none; color: #ececec; font-size: 16px; outline: none; padding: 4px 0;" />
                                    <div style="display: flex; gap: 8px; margin-left: 12px;">
                                        <div style="color: #8e8ea0; cursor: pointer; padding: 4px;">🎤</div>
                                        <div onclick="window.terminal.handleChatGPTCommand()" 
                                             style="background: #19c37d; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                            ➤
                                        </div>
                                    </div>
                                </div>
                                <p style="text-align: center; color: #8e8ea0; font-size: 13px; margin-top: 16px; margin-bottom: 0;">
                                    Try: balance, help, connect, mine, faucet
                                </p>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "chatgpt";
          this.log(
            "💬 Chat bubbles and conversation mode activated",
            "success"
          );

          // Focus input
          setTimeout(() => {
            document.getElementById("chatgptInput")?.focus();
          }, 100);
        }

        setupiOSInterface() {
          // Transform terminal into iOS Messages-style interface
          this.log("📱 iOS Messages interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-ios";

          // Create iOS Messages interface structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div style="height: 100vh; display: flex; flex-direction: column; background: linear-gradient(180deg, #000000 0%, #1c1c1e 100%); font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;">
                        <!-- iOS Status Bar -->
                        <div style="background: rgba(0,0,0,0.8); backdrop-filter: blur(20px); padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; color: white; font-size: 17px; font-weight: 600; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" 
                                        style="background: none; border: none; color: #007AFF; font-size: 17px; cursor: pointer;">← Terminal</button>
                                <div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #007AFF, #34C759); display: flex; align-items: center; justify-content: center; color: white; font-size: 16px; font-weight: bold;">Ω</div>
                                <span style="color: white; font-weight: 600;">Omega Network</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; font-size: 14px;">
                                <span style="background: #34C759; width: 18px; height: 10px; border-radius: 2px;"></span>
                                <span>100%</span>
                            </div>
                        </div>
                        
                        <!-- Messages Area -->
                        <div style="flex: 1; padding: 16px; overflow-y: auto; background: #000000;" id="iosConversation">
                            <!-- Welcome message from system -->
                            <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                                <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4;">
                                    👋 Welcome to Omega Terminal<br/>
                                    Try: <strong>balance</strong>, <strong>mine</strong>, <strong>claim</strong>, or <strong>help</strong>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Input Area -->
                        <div style="background: rgba(28, 28, 30, 0.95); backdrop-filter: blur(20px); padding: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="display: flex; align-items: center; gap: 12px; background: rgba(58, 58, 60, 0.8); border-radius: 24px; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.1);">
                                <input type="text" 
                                       placeholder="iMessage" 
                                       id="iosInput" 
                                       onkeypress="if(event.key==='Enter'){window.terminal.handleiOSCommand();}"
                                       style="flex: 1; background: none; border: none; color: #FFFFFF; font-size: 17px; outline: none; padding: 8px 0; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;" />
                                <button onclick="window.terminal.handleiOSCommand()" 
                                        style="background: #007AFF; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);">
                                    ↑
                                </button>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "ios";
          this.log("📱 iOS Messages interface activated", "success");

          // Focus input
          setTimeout(() => {
            document.getElementById("iosInput")?.focus();
          }, 100);
        }

        setupDiscordInterface() {
          // Transform terminal into Discord-style interface
          this.log("🎮 Discord interface loading...", "info");

          // Add GUI body class
          document.body.className = "gui-discord";

          // Create Discord interface structure that matches CSS
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div class="discord-app">
                        <div class="discord-sidebar">
                            <div class="discord-server">Ω</div>
                            <div class="discord-channels">
                                <div class="channel-category">Text Channels</div>
                                <div class="channel active"># omega-terminal</div>
                                <div class="channel"># general</div>
                                <div class="channel"># mining</div>
                                <div class="channel"># ambassador</div>
                            </div>
                        </div>
                        <div class="discord-main">
                            <div class="discord-header">
                                # omega-terminal
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])" style="background: #f04747; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; margin-left: auto;">Exit</button>
                            </div>
                            <div class="discord-messages" id="discordMessages">
                                <div class="discord-message">
                                    <div class="message-author">Omega Bot</div>
                                    <div class="message-text">Welcome to Omega Terminal Discord mode! Type any command to continue.</div>
                                </div>
                            </div>
                            <div class="discord-input">
                                <input type="text" placeholder="Message #omega-terminal" id="discordInput" onkeypress="if(event.key==='Enter'){window.terminal.handleDiscordCommand();}">
                                <button onclick="window.terminal.handleDiscordCommand()">Send</button>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "discord";
          this.log("💬 Full-screen chat mode activated", "success");

          // Input handler is now inline in HTML - no setup needed
        }

        setupAOLInterface() {
          // Create AOL-style interface
          // Add GUI body class
          document.body.className = "gui-aol";

          this.log("📞 AOL Instant Messenger loading...", "info");

          // Create AOL interface structure that matches CSS
          const terminal = document.getElementById("terminal");
          terminal.style.height = "100vh";
          terminal.innerHTML = `
                    <div class="aol-window">
                        <div class="aol-titlebar">
                            <span>AOL Instant Messenger - Omega Terminal</span>
                            <div class="aol-buttons">
                                <button onclick="window.terminal.handleGuiCommand(['gui', 'off'])">X</button>
                            </div>
                        </div>
                        <div class="aol-content">
                            <div class="aol-buddylist">
                                <div class="aol-section">
                                    <strong>Online Buddies (3)</strong>
                                    <div class="buddy">OmegaMiner42</div>
                                    <div class="buddy">CryptoTrader</div>
                                    <div class="buddy">Web3Ninja</div>
                                </div>
                                <div class="aol-section">
                                    <strong>Away (1)</strong>
                                    <div class="buddy">Ambassador1</div>
                                </div>
                            </div>
                            <div class="aol-chat">
                                <div class="aol-messages" id="aolMessages">
                                    <div class="aol-message">
                                        <strong>OmegaBot:</strong> Welcome to AOL Omega Terminal! Type commands to chat.
                                    </div>
                                </div>
                                <div class="aol-input">
                                    <input type="text" placeholder="Type your message..." id="aolInput" onkeypress="if(event.key==='Enter'){window.terminal.handleAOLCommand();}">
                                    <button onclick="window.terminal.handleAOLCommand()">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

          this.currentInterface = "aol";
          this.log("✨ 90s nostalgia mode activated", "success");

          // Input handler is now inline in HTML - no setup needed
        }

        setupWindows95Interface() {
          // Create Windows 95-style interface
          // Add GUI body class
          document.body.className = "gui-windows95";

          this.log("💻 Windows 95 interface loading...", "info");
          this.log("🖥️ Authentic DOS window experience", "success");
          this.log("⚡ Retro computing mode activated", "info");
        }

        setupLimewireInterface() {
          // Create Limewire-style interface
          // Add GUI body class
          document.body.className = "gui-limewire";

          this.log("🎵 Limewire interface loading...", "info");
          this.log("🔗 P2P file sharing theme activated", "success");
          this.log("💚 Retro green interface ready", "info");
        }

        async executeCommandInGUI(command, theme) {
          try {
            // Store current GUI interface
            const currentHTML = document.getElementById("terminal").innerHTML;

            // Temporarily restore basic terminal structure for command execution
            document.getElementById("terminal").innerHTML = `
                        <div class="terminal-content" id="terminalContent"></div>
                        <div style="display: none;">
                            <input id="commandInput" value="">
                        </div>
                    `;

            // Execute the actual terminal command
            await this.executeCommand(command);

            // Get the output from the terminal content
            const output =
              document.getElementById("terminalContent").textContent ||
              "Command executed";

            // Restore GUI interface
            document.getElementById("terminal").innerHTML = currentHTML;

            // Re-apply body class for styling
            if (theme === "ios") {
              document.body.className = "gui-ios";
            } else if (theme === "chatgpt") {
              document.body.className = "gui-chatgpt";
            } else if (theme === "discord") {
              document.body.className = "gui-discord";
            } else if (theme === "aol") {
              document.body.className = "gui-aol";
            }

            // Clean up output for better display
            const cleanOutput = output
              .replace(
                /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,
                ""
              )
              .trim();

            // Display result in appropriate GUI theme
            if (theme === "ios") {
              this.addiOSMessage(
                `${cleanOutput || "✅ Command completed successfully!"}`,
                "system"
              );
            } else if (theme === "chatgpt") {
              this.addChatGPTMessage(
                `${cleanOutput || "Command completed successfully!"}`,
                "assistant"
              );
            } else if (theme === "discord") {
              this.addDiscordMessage(
                `✅ ${cleanOutput || "Command completed!"}`,
                "bot"
              );
            } else if (theme === "aol") {
              this.addAOLMessage(`${cleanOutput || "Command done!"}`, "bot");
            }
          } catch (error) {
            // Restore GUI on error
            const currentHTML = document.getElementById("terminal").innerHTML;
            if (
              !currentHTML.includes("iosConversation") &&
              !currentHTML.includes("chatgpt-conversation") &&
              !currentHTML.includes("discord") &&
              !currentHTML.includes("aol")
            ) {
              // Need to restore GUI - something went wrong
              if (theme === "ios") {
                this.setupiOSInterface();
              } else if (theme === "chatgpt") {
                this.setupChatGPTInterface();
              } else if (theme === "discord") {
                this.setupDiscordInterface();
              } else if (theme === "aol") {
                this.setupAOLInterface();
              }
            }

            if (theme === "ios") {
              this.addiOSMessage(`❌ Error: ${error.message}`, "system");
            } else if (theme === "chatgpt") {
              this.addChatGPTMessage(`❌ Error: ${error.message}`, "assistant");
            } else if (theme === "discord") {
              this.addDiscordMessage(`❌ Error: ${error.message}`, "bot");
            } else if (theme === "aol") {
              this.addAOLMessage(`Error: ${error.message}`, "bot");
            }
          }
        }

        async safeExecuteCommand(command) {
          try {
            // Store original DOM functions that might fail in GUI mode
            const originalLog = this.log;
            const originalLogHtml = this.logHtml;

            // Mock the log functions to prevent DOM errors
            this.log = () => {}; // Silently ignore
            this.logHtml = () => {}; // Silently ignore

            // Mock getElementById to prevent null errors
            const originalGetElementById = document.getElementById;
            document.getElementById = function (id) {
              const element = originalGetElementById.call(document, id);
              if (
                !element &&
                (id === "terminalContent" || id === "commandInput")
              ) {
                // Return a mock element for critical terminal elements
                return {
                  innerHTML: "",
                  appendChild: () => {},
                  scrollTop: 0,
                  style: {},
                  focus: () => {},
                  value: "",
                };
              }
              return element;
            };

            // Execute the command
            await this.executeCommand(command);

            // Restore original functions
            this.log = originalLog;
            this.logHtml = originalLogHtml;
            document.getElementById = originalGetElementById;

            return { success: true };
          } catch (error) {
            // Restore functions in case of error
            this.log = this.log.bind ? this.log : () => {};
            this.logHtml = this.logHtml.bind ? this.logHtml : () => {};
            document.getElementById = document.getElementById.bind
              ? document.getElementById
              : (id) => document.querySelector("#" + id);

            return { success: false, error: error.message };
          }
        }

        async handleChatGPTCommand() {
          const input = document.getElementById("chatgptInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addChatGPTMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addChatGPTMessage(
              "Available commands:\n• **test** - Test GUI functionality\n• **balance** - Check your OMEGA balance\n• **mine** - Start mining session\n• **claim** - Claim your rewards\n• **gui off** - Exit ChatGPT mode",
              "assistant"
            );
          } else if (command === "test") {
            this.addChatGPTMessage(
              "✅ ChatGPT GUI is working perfectly!",
              "assistant"
            );
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addChatGPTMessage("Checking your balance...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else if (command === "mine") {
            this.addChatGPTMessage("Starting mining session...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else if (command === "claim") {
            this.addChatGPTMessage("Processing claim...", "assistant");
            this.executeCommandInGUI(command, "chatgpt");
          } else {
            this.addChatGPTMessage(`Processing "${command}"...`, "assistant");
            // Try to execute other commands
            this.safeExecuteCommand(command).then((result) => {
              this.addChatGPTMessage(
                result.success
                  ? `✅ ${command} completed`
                  : `❌ ${result.error}`,
                "assistant"
              );
            });
          }
        }

        async handleiOSCommand() {
          const input = document.getElementById("iosInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message (blue bubble on right)
          this.addiOSMessage(command, "user");
          input.value = "";

          // Process command with a small delay for realistic feel
          setTimeout(() => {
            if (command === "help") {
              this.addiOSMessage(
                "Available commands:\n• balance - Check your OMEGA balance\n• mine - Start mining session\n• claim - Claim your rewards\n• gui off - Exit iOS mode",
                "system"
              );
            } else if (command === "test") {
              this.addiOSMessage(
                "✅ iOS GUI is working perfectly! 📱",
                "system"
              );
            } else if (command === "gui off") {
              this.handleGuiCommand(["gui", "off"]);
            } else if (command === "balance") {
              this.addiOSMessage("⏳ Checking your balance...", "system");
              this.executeCommandInGUI(command, "ios");
            } else if (command === "mine") {
              this.addiOSMessage("⛏️ Starting mining session...", "system");
              this.executeCommandInGUI(command, "ios");
            } else if (command === "claim") {
              this.addiOSMessage("💰 Processing claim...", "system");
              this.executeCommandInGUI(command, "ios");
            } else {
              this.addiOSMessage(`⚡ Processing "${command}"...`, "system");
              // Try to execute other commands
              this.safeExecuteCommand(command).then((result) => {
                this.addiOSMessage(
                  result.success
                    ? `✅ ${command} completed`
                    : `❌ ${result.error}`,
                  "system"
                );
              });
            }
          }, 300); // Small delay for realistic messaging feel
        }

        async handleDiscordCommand() {
          const input = document.getElementById("discordInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addDiscordMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addDiscordMessage(
              "**Available Commands:**\n`test` - Test functionality\n`balance` - Check OMEGA balance\n`mine` - Start mining session\n`claim` - Claim rewards\n`gui off` - Exit Discord",
              "bot"
            );
          } else if (command === "test") {
            this.addDiscordMessage("✅ **Discord GUI Working!**", "bot");
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addDiscordMessage("💰 Checking balance...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else if (command === "mine") {
            this.addDiscordMessage("⛏️ Starting mining...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else if (command === "claim") {
            this.addDiscordMessage("💎 Processing claim...", "bot");
            this.executeCommandInGUI(command, "discord");
          } else {
            this.addDiscordMessage(`🔄 Processing "${command}"...`, "bot");
            this.safeExecuteCommand(command).then((result) => {
              this.addDiscordMessage(
                result.success
                  ? `✅ ${command} completed`
                  : `❌ ${result.error}`,
                "bot"
              );
            });
          }
        }

        addDiscordMessage(content, sender) {
          const messages = document.getElementById("discordMessages");
          if (!messages) return;

          const messageEl = document.createElement("div");
          messageEl.className = "discord-message";

          const username = sender === "user" ? "You" : "Omega Bot";

          messageEl.innerHTML = `
                    <div class="message-author">${username}</div>
                    <div class="message-text">
                        <pre style="font-family: monospace; white-space: pre-wrap; margin: 0; color: #dcddde;">${content}</pre>
                    </div>
                `;

          messages.appendChild(messageEl);
          messages.scrollTop = messages.scrollHeight;
        }

        async handleAOLCommand() {
          const input = document.getElementById("aolInput");
          if (!input) return;

          const command = input.value.trim();
          if (!command) return;

          // Add user message
          this.addAOLMessage(command, "user");
          input.value = "";

          // Process command
          if (command === "help") {
            this.addAOLMessage(
              "Commands: test, balance, mine, claim, gui off",
              "bot"
            );
          } else if (command === "test") {
            this.addAOLMessage("AOL GUI working!", "bot");
          } else if (command === "gui off") {
            this.handleGuiCommand(["gui", "off"]);
          } else if (command === "balance") {
            this.addAOLMessage("Checking balance...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else if (command === "mine") {
            this.addAOLMessage("Mining started...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else if (command === "claim") {
            this.addAOLMessage("Processing claim...", "bot");
            this.executeCommandInGUI(command, "aol");
          } else {
            this.addAOLMessage(`Processing "${command}"...`, "bot");
            this.safeExecuteCommand(command).then((result) => {
              this.addAOLMessage(
                result.success ? `${command} done` : `Error: ${result.error}`,
                "bot"
              );
            });
          }
        }

        addAOLMessage(content, sender) {
          const messages = document.getElementById("aolMessages");
          if (!messages) return;

          const messageEl = document.createElement("div");
          messageEl.className = "aol-message";

          const username = sender === "user" ? "You" : "OmegaBot";
          messageEl.innerHTML = `<strong>${username}:</strong> ${content}`;

          messages.appendChild(messageEl);
          messages.scrollTop = messages.scrollHeight;
        }

        addChatGPTMessage(content, sender) {
          const conversation = document.querySelector(".chatgpt-conversation");
          if (!conversation) return;

          const messageEl = document.createElement("div");
          messageEl.className = `chat-message ${sender}`;

          if (sender === "user") {
            // User messages on the right - GREEN BUBBLES!
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 10px 0;">
                            <div style="background: #19c37d; color: white; padding: 12px 16px; border-radius: 18px; max-width: 70%; margin-right: 12px;">
                                ${content}
                            </div>
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #19c37d; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px;">👤</div>
                        </div>
                    `;
          } else {
            // Assistant messages on the left - PURPLE AVATAR!
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 10px 0;">
                            <div style="width: 32px; height: 32px; border-radius: 50%; background: #ab68ff; color: white; display: flex; align-items: center; justify-content: center; font-size: 16px; margin-right: 12px;">🤖</div>
                            <div style="background: transparent; color: #ececec; padding: 12px 16px; border-radius: 18px; max-width: 70%;">
                                ${content}
                            </div>
                        </div>
                    `;
          }

          conversation.appendChild(messageEl);
          conversation.scrollTop = conversation.scrollHeight;
        }

        addiOSMessage(content, sender) {
          const conversation = document.getElementById("iosConversation");
          if (!conversation) return;

          const messageEl = document.createElement("div");
          messageEl.className = `ios-message ${sender}`;

          if (sender === "user") {
            // User messages on the right - Blue iOS bubbles
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-end; margin: 8px 0; animation: slideInRight 0.3s ease-out;">
                            <div style="background: #007AFF; color: white; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3); word-wrap: break-word;">
                                ${content.replace(/\n/g, "<br>")}
                            </div>
                        </div>
                    `;
          } else {
            // System messages on the left - Gray iOS bubbles
            messageEl.innerHTML = `
                        <div style="display: flex; justify-content: flex-start; margin: 8px 0; animation: slideInLeft 0.3s ease-out;">
                            <div style="background: rgba(142, 142, 147, 0.12); color: #FFFFFF; padding: 12px 16px; border-radius: 20px; max-width: 75%; font-size: 16px; line-height: 1.4; border: 1px solid rgba(255,255,255,0.1); word-wrap: break-word;">
                                ${content.replace(/\n/g, "<br>")}
                            </div>
                        </div>
                    `;
          }

          conversation.appendChild(messageEl);
          conversation.scrollTop = conversation.scrollHeight;

          // Add subtle haptic-like effect
          messageEl.style.transform = "scale(0.95)";
          setTimeout(() => {
            messageEl.style.transform = "scale(1)";
            messageEl.style.transition = "transform 0.1s ease-out";
          }, 50);
        }

        restoreOriginalTerminal() {
          // Remove all GUI body classes
          document.body.className = "";

          // Store current interface state
          const currentInterface = this.currentInterface;
          this.currentInterface = "terminal";

          // Restore original terminal HTML structure
          const terminal = document.getElementById("terminal");
          terminal.style.height = "";
          terminal.innerHTML = `
                    <div class="terminal-header">
                        <div class="terminal-title">Ω Terminal v2.0.1</div>
                        <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                            <label for="aiProviderSelect" style="color:#00bcf2; font-family: 'Courier New', monospace; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">AI:</label>
                            <select id="aiProviderSelect" title="Select AI Provider" style="background: rgba(0, 188, 242, 0.1); border: 1px solid rgba(0, 188, 242, 0.3); border-radius: 6px; padding: 6px 10px; color: #00bcf2; font-family: 'Courier New', monospace; font-size: 11px; font-weight: 600; cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: linear-gradient(45deg, transparent 50%, #00bcf2 50%), linear-gradient(135deg, #00bcf2 50%, transparent 50%); background-position: calc(100% - 15px) calc(1em + 2px), calc(100% - 10px) calc(1em + 2px); background-size: 5px 5px, 5px 5px; background-repeat: no-repeat; min-width: 110px;">
                              <option value="off">Off</option>
                              <option value="near">NEAR AI</option>
                              <option value="openai">OpenAI</option>
                            </select>
                            <button class="theme-toggle" title="Toggle Theme"></button>
                            <div class="terminal-status" id="connectionStatus">CONNECTED</div>
                        </div>
                    </div>
                    <div class="tab-bar" id="tabBar" style="display: flex; align-items: center; background: #111; border-bottom: 1px solid #00bcf2; box-shadow: 0 1px 10px rgba(0, 188, 242, 0.3);">
                        <div class="tab active" data-tab="0" style="padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold;">Terminal 1</div>
                        <div id="addTabBtn" style="padding: 8px 18px; cursor: pointer; color: #00bcf2; font-size: 1.3em;">+</div>
                    </div>
                    <div class="terminal-content" id="terminalContent"></div>
                    <div class="terminal-input-section">
                        <div class="input-line">
                            <span class="input-prompt">Ω Terminal:~$</span>
                            <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                            <span class="cursor">|</span>
                        </div>
                    </div>
                `;

          // Restore event listeners
          this.setupEventListeners();
        }

        renderTabs() {
          const tabBar = document.getElementById("tabBar");
          if (!tabBar) return;
          // Clear existing tabs except the add button
          const addBtn = document.getElementById("addTabBtn");
          tabBar.innerHTML = "";
          if (addBtn) tabBar.appendChild(addBtn);
          this.tabs.forEach((tab, index) => {
            const tabElement = document.createElement("div");
            tabElement.className = `tab ${
              index === this.activeTab ? "active" : ""
            }`;
            tabElement.dataset.tab = index;
            tabElement.style.cssText =
              "padding: 8px 18px; cursor: pointer; border-right: 1px solid #333; color: #fff; font-weight: bold; display: flex; align-items: center; position: relative;";
            tabElement.onclick = (e) => {
              // Prevent switching if close button is clicked
              if (e.target.classList.contains("tab-close")) return;
              this.switchTab(index);
            };
            tabElement.textContent = tab.name;
            // Add close button for all tabs except the first
            if (index > 0) {
              const closeBtn = document.createElement("span");
              closeBtn.textContent = " ×";
              closeBtn.className = "tab-close";
              closeBtn.style.cssText =
                "margin-left: 8px; color: #ff3333; cursor: pointer; font-weight: bold;";
              closeBtn.onclick = (e) => {
                e.stopPropagation();
                this.closeTab(index);
              };
              tabElement.appendChild(closeBtn);
            }
            tabBar.insertBefore(tabElement, addBtn);
          });
        }

        switchTab(index) {
          if (index === this.activeTab) return;
          this.activeTab = index;
          this.renderTabs();
          this.loadTabContent();
        }

        closeTab(index) {
          if (index === 0) return; // Never close the first tab
          this.tabs.splice(index, 1);
          // Adjust activeTab if needed
          if (this.activeTab >= index) {
            this.activeTab = Math.max(0, this.activeTab - 1);
          }
          this.renderTabs();
          this.loadTabContent();
        }

        loadTabContent() {
          const tab = this.tabs[this.activeTab];
          if (!tab) return;
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
          // Load tab history
          if (tab.history && tab.history.length) {
            tab.history.forEach((item) => {
              if (item.type === "command") {
                this.logCommand(item.content);
              } else {
                this.logHtml(item.content, item.logType || "output");
              }
            });
          }
        }

        clearTerminalContent() {
          const terminalContent = document.getElementById("terminalContent");
          terminalContent.innerHTML = "";
          // Also clear the tab's history
          const tab = this.tabs[this.activeTab];
          if (tab) tab.history = [];
        }

        async airdrop() {
          this.log("🎁 Incoming airdrop!", "info");
          // Create and show Airdrop popup
          const modal = document.createElement("div");
          modal.id = "airdropModal";
          modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
          const imgContainer = document.createElement("div");
          imgContainer.style.cssText = `
                    position: relative;
                    width: 80%;
                    max-width: 600px;
                    height: 60%;
                    max-height: 400px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    background: #111;
                    border-radius: 10px;
                    box-shadow: 0 0 30px #00bcf2;
                `;
          const closeBtn = document.createElement("button");
          closeBtn.textContent = "×";
          closeBtn.style.cssText = `
                    position: absolute;
                    top: -40px;
                    right: 0;
                    background: #ff3333;
                    color: white;
                    border: none;
                    font-size: 24px;
                    width: 40px;
                    height: 40px;
                    cursor: pointer;
                    border-radius: 50%;
                    z-index: 10001;
                `;
          closeBtn.onclick = () => {
            document.body.removeChild(modal);
          };
          const img = document.createElement("img");
          img.src =
            "https://i.postimg.cc/g08SBcPg/Metal-Pole-Bang-for-nearly-15-minutes-crazy-art-dance.gif"; // user-provided gif
          img.alt = "Airdrop";
          img.style.cssText =
            "max-width:100%; max-height:100%; border-radius:10px;";
          imgContainer.appendChild(closeBtn);
          imgContainer.appendChild(img);
          // Add Roy message below the GIF with spacing and centered
          const msg = document.createElement("div");
          msg.innerHTML = `<div style="color:#fff; text-align:center; font-size:1.5em; margin-top:28px; font-weight:bold;">Roy says not yet</div>`;
          imgContainer.appendChild(msg);
          modal.appendChild(imgContainer);
          document.body.appendChild(modal);
          // Auto-close after 30 seconds
          setTimeout(() => {
            if (document.body.contains(modal)) {
              document.body.removeChild(modal);
            }
          }, 30000);
        }

        // Helper methods for Eclipse swaps
        async executeSolarSwap(inputMint, outputMint, amount, slippageBps) {
          // Step 1: Get quote using GET request with query parameters
          this.log("Getting Solar DEX quote...", "info");

          // Ensure we have the correct SOL mint address
          const solMintAddress = "So11111111111111111111111111111111111111112";
          const actualInputMint =
            inputMint === "11111111111111111111111111111111"
              ? solMintAddress
              : inputMint;
          const actualOutputMint =
            outputMint === "11111111111111111111111111111111"
              ? solMintAddress
              : outputMint;

          // Convert amount to proper decimals (assuming 9 decimals for most tokens)
          const amountInDecimals = amount * 1e9;

          // Build query parameters
          const queryParams = new URLSearchParams({
            inputMint: actualInputMint,
            outputMint: actualOutputMint,
            amount: amountInDecimals.toString(),
            slippageBps: slippageBps.toString(),
            txVersion: "LEGACY",
          });

          // this.log(`Quote URL: https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`, 'info');

          const quoteResponse = await fetch(
            `https://api.solarstudios.co/compute/swap-base-in?${queryParams.toString()}`,
            {
              method: "GET",
              headers: { "Content-Type": "application/json" },
            }
          );

          if (!quoteResponse.ok) {
            const errorText = await quoteResponse.text();
            this.log(
              `Solar quote failed: HTTP ${quoteResponse.status}`,
              "error"
            );
            this.log(`Error details: ${errorText}`, "error");
            this.log(`Debug: Request URL: ${quoteResponse.url}`, "info");
            throw new Error("Solar quote failed");
          }

          const quoteData = await quoteResponse.json();
          // this.log(`Solar quote received: ${JSON.stringify(quoteData)}`, 'success');

          if (!quoteData.success) {
            this.log(
              `Quote failed: ${quoteData.msg || "Unknown error"}`,
              "error"
            );
            throw new Error("Solar quote failed");
          }

          // Step 2: Get transaction using the quote response
          this.log("Getting Solar transaction...", "info");

          const transactionPayload = {
            computeUnitPriceMicroLamports: String(300000),
            swapResponse: quoteData,
            txVersion: "LEGACY",
            wallet: window.eclipseWallet.keypair.publicKey.toString(),
            wrapSol: actualInputMint === solMintAddress,
            unwrapSol: actualOutputMint === solMintAddress,
            inputAccount: window.eclipseWallet.keypair.publicKey.toString(), // Simplified for now
            outputAccount: window.eclipseWallet.keypair.publicKey.toString(), // Simplified for now
          };

          // this.log(`Transaction payload: ${JSON.stringify(transactionPayload)}`, 'info');

          const txResponse = await fetch(
            "https://api.solarstudios.co/transaction/swap-base-in",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(transactionPayload),
            }
          );

          if (!txResponse.ok) {
            const errorText = await txResponse.text();
            this.log(`Solar transaction failed: ${errorText}`, "error");
            throw new Error("Solar transaction failed");
          }

          const txData = await txResponse.json();
          // this.log(`Solar transaction received: ${JSON.stringify(txData)}`, 'success');

          if (!txData.success) {
            this.log(
              `Transaction failed: ${txData.msg || "Unknown error"}`,
              "error"
            );
            throw new Error("Solar transaction failed");
          }

          // Step 3: Sign and send transactions
          this.log("Signing and sending transactions...", "info");

          const connection = new window.solanaWeb3.Connection(
            window.eclipseWallet.rpcUrl,
            "confirmed"
          );

          // Handle multiple transactions (like the dev's code)
          const allTxBuf = txData.data.map((tx) =>
            Buffer.from(tx.transaction, "base64")
          );
          const allTransactions = allTxBuf.map((txBuf) =>
            window.solanaWeb3.Transaction.from(txBuf)
          );

          this.log(
            `Total ${allTransactions.length} transactions to process`,
            "info"
          );

          for (let idx = 0; idx < allTransactions.length; idx++) {
            const transaction = allTransactions[idx];

            // Add blockhash
            const { blockhash, lastValidBlockHeight } =
              await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;

            // Sign the transaction
            transaction.sign(window.eclipseWallet.keypair);

            // Serialize and send
            const txId = await connection.sendRawTransaction(
              transaction.serialize(),
              {
                skipPreflight: false,
              }
            );

            this.log(
              `${idx + 1} transaction sending..., txId: ${txId}`,
              "info"
            );

            await connection.confirmTransaction(
              {
                blockhash,
                lastValidBlockHeight,
                signature: txId,
              },
              "confirmed"
            );

            this.log(`${idx + 1} transaction confirmed`, "success");

            this.log(`✅ Solar swap completed successfully!`, "success");
            this.log(
              `Transaction: https://explorer.eclipse.xyz/tx/${txId}`,
              "info"
            );
            return;
          }
        }

        async executeDeserializeSwap(
          inputMint,
          outputMint,
          amount,
          slippageBps
        ) {
          // Step 0: Check balances first
          this.log("Checking wallet balances...", "info");

          try {
            const connection = new window.solanaWeb3.Connection(
              window.eclipseWallet.rpcUrl,
              "confirmed"
            );

            // Check SOL balance for transaction fees
            const solBalance = await connection.getBalance(
              window.eclipseWallet.publicKey
            );
            const solBalanceSol = solBalance / 1e9; // Convert lamports to SOL

            this.log(`SOL balance: ${solBalanceSol.toFixed(6)} SOL`, "info");

            if (solBalanceSol < 0.001) {
              this.log(
                "❌ Insufficient SOL for transaction fees. Need at least 0.001 SOL.",
                "error"
              );
              throw new Error("Insufficient SOL for transaction fees");
            }

            // Check token balance if it's not SOL
            if (inputMint !== "So11111111111111111111111111111111111111112") {
              // Not SOL
              const tokenAccount = await connection.getTokenAccountsByOwner(
                window.eclipseWallet.publicKey,
                {
                  mint: new window.solanaWeb3.PublicKey(inputMint),
                }
              );

              if (tokenAccount.value.length === 0) {
                this.log(`❌ No ${inputMint} tokens found in wallet.`, "error");
                throw new Error(`No ${inputMint} tokens in wallet`);
              }

              const tokenBalance = await connection.getTokenAccountBalance(
                tokenAccount.value[0].pubkey
              );
              const tokenAmount = tokenBalance.value.uiAmount;

              this.log(`Token balance: ${tokenAmount} tokens`, "info");

              if (tokenAmount < amount) {
                this.log(
                  `❌ Insufficient token balance. Have: ${tokenAmount}, Need: ${amount}`,
                  "error"
                );
                throw new Error("Insufficient token balance");
              }
            }

            this.log("✅ Balance check passed", "success");
          } catch (e) {
            if (e.message.includes("balance") || e.message.includes("tokens")) {
              throw e; // Re-throw balance errors
            }
            this.log(
              "⚠️ Could not verify balances, proceeding anyway...",
              "warning"
            );
          }

          // Step 1: Get quote
          this.log("Getting Deserialize quote...", "info");

          const quotePayload = {
            tokenA: inputMint,
            tokenB: outputMint,
            amountIn: amount.toString(),
            dexId: "ALL",
            options: {
              reduceToTwoHops: false,
              targetRouteNumber: 0,
            },
          };

          const quoteResponse = await fetch(
            "https://api.deserialize.xyz/quote",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(quotePayload),
            }
          );

          if (!quoteResponse.ok) {
            const errorText = await quoteResponse.text();
            this.log(
              `Deserialize quote failed: HTTP ${quoteResponse.status}`,
              "error"
            );
            this.log(`Error details: ${errorText}`, "error");

            // Try with different parameters
            this.log("Trying Deserialize with different parameters...", "info");
            const altPayload = {
              tokenA: inputMint,
              tokenB: outputMint,
              amountIn: amount.toString(),
              dexId: "ALL", // Use ALL instead of JUPITER
              options: {
                reduceToTwoHops: true,
                targetRouteNumber: 0,
              },
            };

            const altResponse = await fetch(
              "https://api.deserialize.xyz/quote",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(altPayload),
              }
            );

            if (!altResponse.ok) {
              const altErrorText = await altResponse.text();
              this.log(
                `Deserialize alternative attempt also failed: HTTP ${altResponse.status}`,
                "error"
              );
              this.log(`Error details: ${altErrorText}`, "error");
              throw new Error("Deserialize quote failed - service may be down");
            }

            // Use the alternative response
            const quoteData = await altResponse.json();
            this.log(
              `Deserialize quote received (alternative): ${quoteData.amountOut} output tokens`,
              "success"
            );
            this.log(`Price impact: ${quoteData.priceImpact}%`, "info");
            return quoteData;
          }

          const quoteData = await quoteResponse.json();
          this.log(
            `Deserialize quote received: ${quoteData.amountOut} output tokens`,
            "success"
          );
          this.log(`Price impact: ${quoteData.priceImpact}%`, "info");

          // Step 2: Get transaction
          this.log("Getting Deserialize transaction...", "info");
          const swapPayload = {
            publicKey: window.eclipseWallet.publicKey,
            quote: quoteData,
            fee: {
              devFeeRate: 0.1, // 0.1% fee
              partnerFeeAddress: window.eclipseWallet.publicKey,
            },
          };

          const txResponse = await fetch("https://api.deserialize.xyz/swap", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(swapPayload),
          });

          if (!txResponse.ok) {
            const errorText = await txResponse.text();
            this.log(`Deserialize transaction failed: ${errorText}`, "error");
            throw new Error("Deserialize transaction failed");
          }

          const txData = await txResponse.json();
          this.log("Deserialize transaction received, signing...", "info");

          // Step 3: Sign and send transaction
          const connection = new window.solanaWeb3.Connection(
            window.eclipseWallet.rpcUrl,
            "confirmed"
          );

          // Handle both regular and versioned transactions
          let transaction;
          let signature;

          try {
            // First try to deserialize as a regular transaction
            transaction = window.solanaWeb3.Transaction.from(
              Buffer.from(txData.transaction, "base64")
            );
            transaction.sign(window.eclipseWallet.keypair);
            signature = await connection.sendTransaction(transaction, [
              window.eclipseWallet.keypair,
            ]);
          } catch (e) {
            // If that fails, try as a versioned transaction
            if (e.message.includes("VersionedMessage")) {
              this.log(
                "Detected versioned transaction, using VersionedTransaction...",
                "info"
              );
              transaction = window.solanaWeb3.VersionedTransaction.deserialize(
                Buffer.from(txData.transaction, "base64")
              );
              transaction.sign([window.eclipseWallet.keypair]);
              signature = await connection.sendTransaction(transaction);
            } else {
              throw e; // Re-throw if it's a different error
            }
          }

          this.log(
            `✅ Deserialize swap transaction submitted! Signature: ${signature}`,
            "success"
          );
          this.log("Waiting for confirmation...", "info");

          const confirmation = await connection.confirmTransaction(
            signature,
            "confirmed"
          );
          if (confirmation.value.err) {
            this.log(
              `❌ Deserialize transaction failed: ${confirmation.value.err}`,
              "error"
            );
            throw new Error("Deserialize transaction failed");
          } else {
            this.log(`✅ Deserialize swap completed successfully!`, "success");
            this.log(
              `Transaction: https://explorer.eclipse.xyz/tx/${signature}`,
              "info"
            );
          }
        }

        async showEclipseSwapInterface() {
          this.log("🔄 Eclipse Swap Interface", "info");
          this.log("Loading available tokens...", "info");

          try {
            // Fetch tokens from both APIs
            const [solarResponse, deserializeResponse] = await Promise.all([
              fetch("https://api.solarstudios.co/mint/list"),
              fetch("https://api.deserialize.xyz/tokenList"),
            ]);

            let solarTokens = [];
            let deserializeTokens = [];

            if (solarResponse.ok) {
              const solarData = await solarResponse.json();
              if (
                solarData.success &&
                solarData.data &&
                solarData.data.mintList
              ) {
                solarTokens = solarData.data.mintList;
              }
            }

            if (deserializeResponse.ok) {
              const deserializeData = await deserializeResponse.json();
              if (deserializeData.data && Array.isArray(deserializeData.data)) {
                deserializeTokens = deserializeData.data;
              }
            }

            // Merge tokens
            const allTokens = new Map();

            solarTokens.forEach((token) => {
              allTokens.set(token.address, {
                address: token.address,
                symbol: token.symbol,
                name: token.name,
                decimals: token.decimals,
                source: "Solar",
              });
            });

            deserializeTokens.forEach((token) => {
              allTokens.set(token.address, {
                address: token.address,
                symbol: token.metadata?.symbol || "N/A",
                name: token.metadata?.name || "N/A",
                decimals: token.decimals,
                source: allTokens.has(token.address) ? "Both" : "Deserialize",
              });
            });

            const tokens = Array.from(allTokens.values()).sort((a, b) =>
              a.symbol.localeCompare(b.symbol)
            );

            // Find ETH and SOLAR tokens for defaults (do this first)
            const ethToken = tokens.find(
              (t) => t.symbol === "ETH" || t.name.includes("Ethereum")
            );
            const solarToken = tokens.find(
              (t) => t.symbol === "SOLAR" || t.name.includes("SOLAR")
            );

            const defaultFromToken = ethToken || tokens[0];
            const defaultToToken = solarToken || tokens[1] || tokens[0];

            // Create swap interface with custom dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🔄 Eclipse Swap</h3>`;

            // From token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseFromTokenDisplay">🟢 ${
              defaultFromToken?.name || "Ethereum"
            }</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            tokens.forEach((token) => {
              const sourceIcon =
                token.source === "Solar"
                  ? "🔵"
                  : token.source === "Deserialize"
                  ? "🟠"
                  : "🟢";
              html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${sourceIcon} ${token.name}`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="eclipseFromToken" value="${
              defaultFromToken?.address || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseToTokenDisplay">🔵 ${
              defaultToToken?.name || "SOLAR STUDIOS"
            }</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            tokens.forEach((token) => {
              const sourceIcon =
                token.source === "Solar"
                  ? "🔵"
                  : token.source === "Deserialize"
                  ? "🟠"
                  : "🟢";
              html += `<div class="dropdown-item" data-value="${token.address}" data-symbol="${token.symbol}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${sourceIcon} ${token.name}`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="eclipseToToken" value="${
              defaultToToken?.address || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="eclipseAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Slippage selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="eclipseSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="eclipseSlippageDisplay">1.0% (Standard)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="eclipseSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
            html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
            html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
            html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="eclipseSlippage" value="100">`;
            html += `</div>`;
            html += `</div>`;

            // Quote display section
            html += `<div id="eclipseQuoteDisplay" style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 3px; display: none;">`;
            html += `<div style="font-size: 12px; color: #999; margin-bottom: 5px;">Estimated Output:</div>`;
            html += `<div id="eclipseQuoteAmount" style="font-size: 16px; color: #fff; font-weight: bold;"></div>`;
            html += `<div id="eclipseQuotePrice" style="font-size: 12px; color: #999; margin-top: 3px;"></div>`;
            html += `</div>`;

            // Swap button
            html += `<button id="eclipseSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🔄 Execute Swap</button>`;

            // Info section
            html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
            html += `<p><strong>Smart Routing:</strong> Automatically uses Solar DEX for SOLAR token, Deserialize Aggregator for others.</p>`;
            html += `<p><strong>Icons:</strong> 🔵 Solar DEX | 🟠 Deserialize | 🟢 Both DEXes</p>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupEclipseDropdowns();
              const swapBtn = document.getElementById("eclipseSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeEclipseSwapFromInterface()
                );
              }

              // Fix amount input event handling and add quote functionality
              const amountInput = document.getElementById("eclipseAmount");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) => {
                  e.stopPropagation();
                  this.updateEclipseQuote();
                });
              }

              // Add quote update on token changes
              const fromToken = document.getElementById("eclipseFromToken");
              const toToken = document.getElementById("eclipseToToken");
              const slippage = document.getElementById("eclipseSlippage");
              if (fromToken)
                fromToken.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
              if (toToken)
                toToken.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
              if (slippage)
                slippage.addEventListener("change", () =>
                  this.updateEclipseQuote()
                );
            }, 100);
          } catch (e) {
            this.log(`Failed to load swap interface: ${e.message}`, "error");
          }
        }

        setupEclipseDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("eclipseFromTokenHeader");
          const fromDropdown = document.getElementById(
            "eclipseFromTokenDropdown"
          );
          const fromHidden = document.getElementById("eclipseFromToken");
          const fromDisplay = document.getElementById(
            "eclipseFromTokenDisplay"
          );

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            fromDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";

                // Update quote when token changes
                this.updateEclipseQuote();
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("eclipseToTokenHeader");
          const toDropdown = document.getElementById("eclipseToTokenDropdown");
          const toHidden = document.getElementById("eclipseToToken");
          const toDisplay = document.getElementById("eclipseToTokenDisplay");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            toDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";

                // Update quote when token changes
                this.updateEclipseQuote();
              }
            });
          }

          // Slippage dropdown
          const slippageHeader = document.getElementById(
            "eclipseSlippageHeader"
          );
          const slippageDropdown = document.getElementById(
            "eclipseSlippageDropdown"
          );
          const slippageHidden = document.getElementById("eclipseSlippage");
          const slippageDisplay = document.getElementById(
            "eclipseSlippageDisplay"
          );

          if (slippageHeader && slippageDropdown) {
            slippageHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = slippageDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== slippageDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              slippageDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            slippageDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                slippageHidden.value = value;
                slippageDisplay.textContent = text;
                slippageDropdown.style.display = "none";
              }
            });
          }
        }

        async updateEclipseQuote() {
          const fromToken = document.getElementById("eclipseFromToken");
          const toToken = document.getElementById("eclipseToToken");
          const amountInput = document.getElementById("eclipseAmount");
          const slippage = document.getElementById("eclipseSlippage");
          const quoteDisplay = document.getElementById("eclipseQuoteDisplay");
          const quoteAmount = document.getElementById("eclipseQuoteAmount");
          const quotePrice = document.getElementById("eclipseQuotePrice");

          if (
            !fromToken ||
            !toToken ||
            !amountInput ||
            !slippage ||
            !quoteDisplay ||
            !quoteAmount ||
            !quotePrice
          ) {
            return;
          }

          const fromMint = fromToken.value;
          const toMint = toToken.value;
          const amount = parseFloat(amountInput.value);
          const slippageBps = parseInt(slippage.value);

          if (
            !fromMint ||
            !toMint ||
            isNaN(amount) ||
            amount <= 0 ||
            isNaN(slippageBps)
          ) {
            quoteDisplay.style.display = "none";
            return;
          }

          try {
            // Smart routing logic - same as swap execution
            const solarTokenAddress =
              "CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze";
            const useSolarDex =
              fromMint === solarTokenAddress || toMint === solarTokenAddress;

            let quoteData;
            if (useSolarDex) {
              // Get Solar DEX quote
              const res = await fetch(`${RELAYER_URL}/solar/quote`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  inputMint: fromMint,
                  outputMint: toMint,
                  amount: amount.toString(),
                  slippageBps: slippageBps,
                }),
              });
              quoteData = await res.json();
            } else {
              // Get Deserialize quote
              const res = await fetch(`${RELAYER_URL}/deserialize/quote`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  inputMint: fromMint,
                  outputMint: toMint,
                  amount: amount.toString(),
                  slippageBps: slippageBps,
                }),
              });
              quoteData = await res.json();
            }

            if (quoteData && quoteData.outAmount) {
              // Get token symbols for display
              const fromTokenElement = document.querySelector(
                '#eclipseFromTokenDropdown .dropdown-item[data-value="' +
                  fromMint +
                  '"]'
              );
              const toTokenElement = document.querySelector(
                '#eclipseToTokenDropdown .dropdown-item[data-value="' +
                  toMint +
                  '"]'
              );
              const fromSymbol = fromTokenElement
                ? fromTokenElement.getAttribute("data-symbol")
                : "Unknown";
              const toSymbol = toTokenElement
                ? toTokenElement.getAttribute("data-symbol")
                : "Unknown";

              // Convert output amount to human readable
              const outputAmount = parseFloat(quoteData.outAmount).toFixed(6);
              quoteAmount.textContent = `${outputAmount} ${toSymbol}`;

              // Show price impact if available
              if (quoteData.priceImpact) {
                const priceImpact = parseFloat(quoteData.priceImpact);
                if (priceImpact > 0.1) {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#ff6b6b";
                } else {
                  quotePrice.textContent = `Price Impact: ${priceImpact.toFixed(
                    2
                  )}%`;
                  quotePrice.style.color = "#51cf66";
                }
              } else {
                quotePrice.textContent = "";
              }

              quoteDisplay.style.display = "block";
            } else {
              quoteDisplay.style.display = "none";
            }
          } catch (e) {
            quoteDisplay.style.display = "none";
          }
        }

        async executeEclipseSwapFromInterface() {
          const fromToken = document.getElementById("eclipseFromToken");
          const toToken = document.getElementById("eclipseToToken");
          const amount = document.getElementById("eclipseAmount");
          const slippage = document.getElementById("eclipseSlippage");

          if (!fromToken || !toToken || !amount || !slippage) {
            this.log("Swap interface not found. Please try again.", "error");
            return;
          }

          const inputMint = fromToken.value;
          const outputMint = toToken.value;
          const amountValue = parseFloat(amount.value);
          const slippageBps = parseInt(slippage.value);

          if (
            !inputMint ||
            !outputMint ||
            isNaN(amountValue) ||
            isNaN(slippageBps)
          ) {
            this.log("Please fill in all fields with valid values.", "error");
            return;
          }

          if (inputMint === outputMint) {
            this.log("Cannot swap the same token.", "error");
            return;
          }

          if (amountValue <= 0) {
            this.log("Amount must be greater than 0.", "error");
            return;
          }

          // Smart routing logic
          const solarTokenAddress =
            "CwrZKtPiZJrAK3tTjNPP22rD9VzeoxQv8iHd6EeyNoze";
          const useSolarDex =
            inputMint === solarTokenAddress || outputMint === solarTokenAddress;
          const dexName = useSolarDex ? "Solar DEX" : "Deserialize Aggregator";

          // Get symbols from the hidden inputs' data attributes
          const fromTokenElement = document.querySelector(
            '#eclipseFromTokenDropdown .dropdown-item[data-value="' +
              inputMint +
              '"]'
          );
          const toTokenElement = document.querySelector(
            '#eclipseToTokenDropdown .dropdown-item[data-value="' +
              outputMint +
              '"]'
          );
          const fromSymbol = fromTokenElement
            ? fromTokenElement.getAttribute("data-symbol")
            : "Unknown";
          const toSymbol = toTokenElement
            ? toTokenElement.getAttribute("data-symbol")
            : "Unknown";

          this.log(
            `Starting Eclipse swap: ${amountValue} ${fromSymbol} → ${toSymbol}`,
            "info"
          );
          this.log(`Using: ${dexName}`, "info");
          this.log(`Slippage: ${slippageBps / 100}%`, "info");

          try {
            if (useSolarDex) {
              await this.executeSolarSwap(
                inputMint,
                outputMint,
                amountValue,
                slippageBps
              );
            } else {
              await this.executeDeserializeSwap(
                inputMint,
                outputMint,
                amountValue,
                slippageBps
              );
            }
          } catch (e) {
            this.log(`Eclipse swap failed: ${e.message}`, "error");
          }
        }

        async showNearSwapInterface() {
          this.log("🔄 Near Intents Swap Interface", "info");
          this.log("Loading available tokens...", "info");

          try {
            // Fetch tokens from Near Intents API
            const response = await fetch(
              "https://1click.chaindefuser.com/v0/tokens"
            );
            if (!response.ok) {
              this.log(
                `Failed to fetch tokens: HTTP ${response.status}`,
                "error"
              );
              return;
            }

            const tokens = await response.json();
            const sortedTokens = tokens.sort((a, b) =>
              a.symbol.localeCompare(b.symbol)
            );

            // Debug: Show what tokens were loaded
            this.log(
              `Loaded ${tokens.length} tokens for swap interface:`,
              "info"
            );
            tokens.slice(0, 10).forEach((token) => {
              this.log(
                `- ${token.symbol} (${token.blockchain}): ${token.assetId}`,
                "info"
              );
            });
            if (tokens.length > 10) {
              this.log(`... and ${tokens.length - 10} more tokens`, "info");
            }

            // Create swap interface with custom dropdowns
            let html = `<div style="background: rgba(255,255,255,0.05); border: 1px solid #ffffff; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
            html += `<h3 style="margin: 0 0 15px 0; color: #ffffff;">🔄 Near Intents Cross-Chain Swap</h3>`;

            // From token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">From Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearFromTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearFromTokenDisplay">🔵 wNEAR (NEAR)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearFromTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            sortedTokens.forEach((token) => {
              const blockchainIcon =
                token.blockchain === "near"
                  ? "🔵"
                  : token.blockchain === "solana"
                  ? "🟣"
                  : token.blockchain === "ethereum"
                  ? "🔶"
                  : "⚪";
              html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${blockchainIcon} ${
                token.symbol
              } (${token.blockchain.toUpperCase()})`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="nearFromToken" value="${
              sortedTokens[0]?.assetId || ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // To token selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">To Token:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearToTokenHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearToTokenDisplay">🟣 SOL (Solana)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearToTokenDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            sortedTokens.forEach((token) => {
              const blockchainIcon =
                token.blockchain === "near"
                  ? "🔵"
                  : token.blockchain === "solana"
                  ? "🟣"
                  : token.blockchain === "ethereum"
                  ? "🔶"
                  : "⚪";
              html += `<div class="dropdown-item" data-value="${token.assetId}" data-symbol="${token.symbol}" data-blockchain="${token.blockchain}" data-decimals="${token.decimals}" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
              html += `${blockchainIcon} ${
                token.symbol
              } (${token.blockchain.toUpperCase()})`;
              html += `</div>`;
            });
            html += `</div>`;
            html += `<input type="hidden" id="nearToToken" value="${
              sortedTokens.find((t) => t.blockchain === "solana")?.assetId ||
              sortedTokens[1]?.assetId ||
              ""
            }">`;
            html += `</div>`;
            html += `</div>`;

            // Amount input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Amount:</label>`;
            html += `<input type="number" id="nearAmount" placeholder="Enter amount" step="0.000001" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Recipient input
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Recipient Address:</label>`;
            html += `<input type="text" id="nearRecipient" placeholder="account.near for NEAR, 0x... for EVM, or Solana address" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box;">`;
            html += `</div>`;

            // Slippage selection with custom dropdown
            html += `<div style="margin-bottom: 15px;">`;
            html += `<label style="display: block; margin-bottom: 5px; color: #cccccc;">Slippage:</label>`;
            html += `<div class="custom-dropdown" style="position: relative; width: 100%;">`;
            html += `<div class="dropdown-header" id="nearSlippageHeader" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; cursor: pointer;">`;
            html += `<span id="nearSlippageDisplay">1.0% (Standard)</span>`;
            html += `<span style="color: #666;">▼</span>`;
            html += `</div>`;
            html += `<div class="dropdown-content" id="nearSlippageDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #111; border: 1px solid #333; border-top: none; border-radius: 0 0 3px 3px; max-height: 200px; overflow-y: auto; z-index: 1000;">`;
            html += `<div class="dropdown-item" data-value="50" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">0.5% (Conservative)</div>`;
            html += `<div class="dropdown-item" data-value="100" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">1.0% (Standard)</div>`;
            html += `<div class="dropdown-item" data-value="200" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">2.0% (Aggressive)</div>`;
            html += `<div class="dropdown-item" data-value="500" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">5.0% (High Risk)</div>`;
            html += `</div>`;
            html += `<input type="hidden" id="nearSlippage" value="100">`;
            html += `</div>`;
            html += `</div>`;

            // Swap button
            html += `<button id="nearSwapBtn" style="width: 100%; padding: 12px; background: linear-gradient(45deg, #00bcf2, #0099cc); color: white; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">🔄 Execute Cross-Chain Swap</button>`;

            // Info section
            html += `<div style="font-size: 12px; color: #999; line-height: 1.4;">`;
            html += `<p><strong>Cross-Chain Swaps:</strong> Swap tokens across different blockchains using NEAR Intents.</p>`;
            html += `<p><strong>Icons:</strong> 🔵 NEAR | 🟣 Solana | 🔶 Ethereum | ⚪ Other</p>`;
            html += `<p><strong>Note:</strong> You'll need to manually send tokens to the deposit address provided.</p>`;
            html += `</div>`;

            html += `</div>`;

            this.logHtml(html, "output");

            // Add event listeners for custom dropdowns
            setTimeout(() => {
              this.setupNearDropdowns();
              const swapBtn = document.getElementById("nearSwapBtn");
              if (swapBtn) {
                swapBtn.addEventListener("click", () =>
                  this.executeNearSwapFromInterface()
                );
              }

              // Fix input event handling
              const amountInput = document.getElementById("nearAmount");
              const recipientInput = document.getElementById("nearRecipient");
              if (amountInput) {
                amountInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                amountInput.addEventListener("input", (e) =>
                  e.stopPropagation()
                );
              }
              if (recipientInput) {
                recipientInput.addEventListener("click", (e) =>
                  e.stopPropagation()
                );
                recipientInput.addEventListener("focus", (e) =>
                  e.stopPropagation()
                );
                recipientInput.addEventListener("input", (e) =>
                  e.stopPropagation()
                );
              }
            }, 100);
          } catch (e) {
            this.log(
              `Failed to load Near Intents swap interface: ${e.message}`,
              "error"
            );
          }
        }

        setupSolanaDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("solanaFromTokenHeader");
          const fromDropdown = document.getElementById(
            "solanaFromTokenDropdown"
          );
          const fromHidden = document.getElementById("solanaFromToken");
          const fromDisplay = document.getElementById("solanaFromTokenDisplay");
          const fromSearch = document.getElementById("solanaFromSearch");
          const fromTokenList = document.getElementById("solanaFromTokenList");

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
              if (!isOpen && fromSearch) {
                fromSearch.focus();
              }
            });

            // Handle search input
            if (fromSearch) {
              fromSearch.addEventListener("input", async (e) => {
                e.stopPropagation();
                const query = e.target.value.trim();
                if (query.length >= 2) {
                  fromTokenList.innerHTML =
                    '<div style="padding: 8px; color: #666;">Searching...</div>';
                  try {
                    const res = await fetch(
                      `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                        query
                      )}`
                    );
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                      let html = "";
                      data.slice(0, 10).forEach((token) => {
                        const icon = token.symbol === "SOL" ? "🟣" : "💎";
                        html += `<div class="dropdown-item" data-value="${
                          token.address || token.id
                        }" data-symbol="${token.symbol}" data-name="${
                          token.name
                        }" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${icon} ${token.symbol} (${token.name})`;
                        html += `</div>`;
                      });
                      fromTokenList.innerHTML = html;
                    } else {
                      fromTokenList.innerHTML =
                        '<div style="padding: 8px; color: #666;">No tokens found</div>';
                    }
                  } catch (err) {
                    fromTokenList.innerHTML =
                      '<div style="padding: 8px; color: #666;">Search failed</div>';
                  }
                } else if (query.length === 0) {
                  // Reset to default tokens
                  fromTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>
                                `;
                }
              });

              fromSearch.addEventListener("click", (e) => e.stopPropagation());
              fromSearch.addEventListener("focus", (e) => e.stopPropagation());
            }

            // Handle item selection
            fromTokenList.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const name = e.target.getAttribute("data-name");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";
                if (fromSearch) fromSearch.value = "";

                // Update quote when token changes
                this.updateSolanaQuote();
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("solanaToTokenHeader");
          const toDropdown = document.getElementById("solanaToTokenDropdown");
          const toHidden = document.getElementById("solanaToToken");
          const toDisplay = document.getElementById("solanaToTokenDisplay");
          const toSearch = document.getElementById("solanaToSearch");
          const toTokenList = document.getElementById("solanaToTokenList");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
              if (!isOpen && toSearch) {
                toSearch.focus();
              }
            });

            // Handle search input
            if (toSearch) {
              toSearch.addEventListener("input", async (e) => {
                e.stopPropagation();
                const query = e.target.value.trim();
                if (query.length >= 2) {
                  toTokenList.innerHTML =
                    '<div style="padding: 8px; color: #666;">Searching...</div>';
                  try {
                    const res = await fetch(
                      `${RELAYER_URL}/jupiter/search?q=${encodeURIComponent(
                        query
                      )}`
                    );
                    const data = await res.json();
                    if (Array.isArray(data) && data.length > 0) {
                      let html = "";
                      data.slice(0, 10).forEach((token) => {
                        const icon = token.symbol === "SOL" ? "🟣" : "💎";
                        html += `<div class="dropdown-item" data-value="${
                          token.address || token.id
                        }" data-symbol="${token.symbol}" data-name="${
                          token.name
                        }" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">`;
                        html += `${icon} ${token.symbol} (${token.name})`;
                        html += `</div>`;
                      });
                      toTokenList.innerHTML = html;
                    } else {
                      toTokenList.innerHTML =
                        '<div style="padding: 8px; color: #666;">No tokens found</div>';
                    }
                  } catch (err) {
                    toTokenList.innerHTML =
                      '<div style="padding: 8px; color: #666;">Search failed</div>';
                  }
                } else if (query.length === 0) {
                  // Reset to default tokens
                  toTokenList.innerHTML = `
                                    <div class="dropdown-item" data-value="So11111111111111111111111111111111111111112" data-symbol="SOL" data-name="Solana" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🟣 SOL (Solana)</div>
                                    <div class="dropdown-item" data-value="EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" data-symbol="USDC" data-name="USD Coin" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💙 USDC (USD Coin)</div>
                                    <div class="dropdown-item" data-value="Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB" data-symbol="USDT" data-name="Tether USD" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">💚 USDT (Tether USD)</div>
                                    <div class="dropdown-item" data-value="DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" data-symbol="BONK" data-name="Bonk" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #333; color: #fff;">🐕 BONK (Bonk)</div>
                                `;
                }
              });

              toSearch.addEventListener("click", (e) => e.stopPropagation());
              toSearch.addEventListener("focus", (e) => e.stopPropagation());
            }

            // Handle item selection
            toTokenList.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const symbol = e.target.getAttribute("data-symbol");
                const name = e.target.getAttribute("data-name");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";
                if (toSearch) toSearch.value = "";

                // Update quote when token changes
                this.updateSolanaQuote();
              }
            });
          }
        }

        async executeSolanaSwapFromInterface() {
          if (!this.solanaAddress) {
            this.log(
              "Please connect your Phantom wallet first using: solana connect",
              "error"
            );
            return;
          }

          const fromMint = document.getElementById("solanaFromToken")?.value;
          const toMint = document.getElementById("solanaToToken")?.value;
          const amount = document.getElementById("solanaAmount")?.value;

          if (!fromMint || !toMint || !amount) {
            this.log(
              "Please fill in all fields: From Token, To Token, and Amount",
              "error"
            );
            return;
          }

          if (fromMint === toMint) {
            this.log("From and To tokens cannot be the same", "error");
            return;
          }

          // Convert amount to lamports (raw amount)
          let amountLamports;
          if (fromMint === "So11111111111111111111111111111111111111112") {
            // SOL: 1 SOL = 1,000,000,000 lamports
            amountLamports = Math.floor(
              parseFloat(amount) * 1000000000
            ).toString();
          } else {
            // For other tokens, we need to get their decimals
            // For now, assume 6 decimals (like USDC)
            amountLamports = Math.floor(
              parseFloat(amount) * 1000000
            ).toString();
          }

          this.log(
            `Executing swap: ${amount} SOL (${amountLamports} lamports) from ${fromMint} to ${toMint}`,
            "info"
          );
          await this.executeSolanaSwap(amountLamports, fromMint, toMint);
        }

        setupNearDropdowns() {
          // Close all dropdowns when clicking outside
          document.addEventListener("click", (e) => {
            if (!e.target.closest(".custom-dropdown")) {
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  dropdown.style.display = "none";
                });
            }
          });

          // From token dropdown
          const fromHeader = document.getElementById("nearFromTokenHeader");
          const fromDropdown = document.getElementById("nearFromTokenDropdown");
          const fromHidden = document.getElementById("nearFromToken");
          const fromDisplay = document.getElementById("nearFromTokenDisplay");

          if (fromHeader && fromDropdown) {
            fromHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = fromDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== fromDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              fromDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            fromDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                fromHidden.value = value;
                fromDisplay.textContent = text;
                fromDropdown.style.display = "none";
              }
            });
          }

          // To token dropdown
          const toHeader = document.getElementById("nearToTokenHeader");
          const toDropdown = document.getElementById("nearToTokenDropdown");
          const toHidden = document.getElementById("nearToToken");
          const toDisplay = document.getElementById("nearToTokenDisplay");

          if (toHeader && toDropdown) {
            toHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = toDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== toDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              toDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            toDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                toHidden.value = value;
                toDisplay.textContent = text;
                toDropdown.style.display = "none";
              }
            });
          }

          // Slippage dropdown
          const slippageHeader = document.getElementById("nearSlippageHeader");
          const slippageDropdown = document.getElementById(
            "nearSlippageDropdown"
          );
          const slippageHidden = document.getElementById("nearSlippage");
          const slippageDisplay = document.getElementById(
            "nearSlippageDisplay"
          );

          if (slippageHeader && slippageDropdown) {
            slippageHeader.addEventListener("click", (e) => {
              e.stopPropagation();
              const isOpen = slippageDropdown.style.display === "block";
              // Close all other dropdowns
              document
                .querySelectorAll(".dropdown-content")
                .forEach((dropdown) => {
                  if (dropdown !== slippageDropdown) {
                    dropdown.style.display = "none";
                  }
                });
              slippageDropdown.style.display = isOpen ? "none" : "block";
            });

            // Handle item selection
            slippageDropdown.addEventListener("click", (e) => {
              if (e.target.classList.contains("dropdown-item")) {
                const value = e.target.getAttribute("data-value");
                const text = e.target.textContent.trim();

                slippageHidden.value = value;
                slippageDisplay.textContent = text;
                slippageDropdown.style.display = "none";
              }
            });
          }
        }

        // Helper functions for Near Intents address validation
        getOriginChainFromAsset(asset) {
          // Check for explicit chain prefixes first
          if (asset.includes("nep141:")) return "NEAR";
          if (asset.includes("sol:")) return "Solana";
          if (asset.includes("eth:")) return "Ethereum";
          if (asset.includes("polygon:")) return "Polygon";
          if (asset.includes("arbitrum:")) return "Arbitrum";

          // Check for specific token patterns
          if (asset.includes("wrap.near") || asset.includes("NEAR (NEAR)"))
            return "NEAR";
          if (asset.includes("SOL (Solana)") || asset.includes("sol-"))
            return "Solana";
          if (asset.includes("(ETH)") || asset.includes("(Ethereum)"))
            return "Ethereum";
          if (asset.includes("(Polygon)")) return "Polygon";
          if (asset.includes("(Arbitrum)")) return "Arbitrum";

          // Default to Ethereum for most tokens
          return "Ethereum";
        }

        getDestinationChainFromAsset(asset) {
          // Check for explicit chain prefixes first
          if (asset.includes("nep141:")) return "NEAR";
          if (asset.includes("sol:")) return "Solana";
          if (asset.includes("eth:")) return "Ethereum";
          if (asset.includes("polygon:")) return "Polygon";
          if (asset.includes("arbitrum:")) return "Arbitrum";

          // Check for specific token patterns
          if (asset.includes("wrap.near") || asset.includes("NEAR (NEAR)"))
            return "NEAR";
          if (asset.includes("SOL (Solana)") || asset.includes("sol-"))
            return "Solana";
          if (asset.includes("(ETH)") || asset.includes("(Ethereum)"))
            return "Ethereum";
          if (asset.includes("(Polygon)")) return "Polygon";
          if (asset.includes("(Arbitrum)")) return "Arbitrum";

          // Default to Ethereum for most tokens
          return "Ethereum";
        }

        async executeNearSwapFromInterface() {
          const fromToken = document.getElementById("nearFromToken");
          const toToken = document.getElementById("nearToToken");
          const amount = document.getElementById("nearAmount");
          const recipient = document.getElementById("nearRecipient");
          const slippage = document.getElementById("nearSlippage");

          if (!fromToken || !toToken || !amount || !recipient || !slippage) {
            this.log("Swap interface not found. Please try again.", "error");
            return;
          }

          const originAsset = fromToken.value;
          const destinationAsset = toToken.value;
          const amountValue = parseFloat(amount.value);
          const recipientAddress = recipient.value.trim();
          const slippageBps = parseInt(slippage.value);

          if (
            !originAsset ||
            !destinationAsset ||
            isNaN(amountValue) ||
            !recipientAddress ||
            isNaN(slippageBps)
          ) {
            this.log("Please fill in all fields with valid values.", "error");
            return;
          }

          // Validate and format recipient address based on destination chain
          let formattedRecipient = recipientAddress;
          let refundAddress = recipientAddress;

          // Determine destination chain from asset
          const destinationChain =
            this.getDestinationChainFromAsset(destinationAsset);
          const originChain = this.getOriginChainFromAsset(originAsset);

          // Debug logging
          this.log(
            `Debug: Origin asset "${originAsset}" detected as ${originChain}`,
            "info"
          );
          this.log(
            `Debug: Destination asset "${destinationAsset}" detected as ${destinationChain}`,
            "info"
          );

          // Format addresses based on chain
          if (destinationChain === "NEAR") {
            // NEAR addresses should be in format: account.near or account.testnet
            if (
              !recipientAddress.includes(".near") &&
              !recipientAddress.includes(".testnet")
            ) {
              this.log(
                "For NEAR destination, recipient should be in format: account.near",
                "error"
              );
              this.log("Example: myaccount.near or myaccount.testnet", "info");
              this.log(
                "Note: Even though the token shows (ETH), it's wrapped on NEAR chain",
                "info"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          } else if (
            destinationChain === "Ethereum" ||
            destinationChain === "Polygon" ||
            destinationChain === "Arbitrum"
          ) {
            // EVM addresses should be 0x format
            if (
              !recipientAddress.startsWith("0x") ||
              recipientAddress.length !== 42
            ) {
              this.log(
                "For EVM chains, recipient should be a valid 0x address",
                "error"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          } else if (destinationChain === "Solana") {
            // Solana addresses should be base58 format
            if (recipientAddress.length < 32 || recipientAddress.length > 44) {
              this.log(
                "For Solana destination, recipient should be a valid Solana address",
                "error"
              );
              return;
            }
            formattedRecipient = recipientAddress;
            refundAddress = recipientAddress;
          }

          if (originAsset === destinationAsset) {
            this.log("Cannot swap the same token.", "error");
            return;
          }

          if (amountValue <= 0) {
            this.log("Amount must be greater than 0.", "error");
            return;
          }

          // Get token info for display
          const fromTokenElement = document.querySelector(
            '#nearFromTokenDropdown .dropdown-item[data-value="' +
              originAsset +
              '"]'
          );
          const toTokenElement = document.querySelector(
            '#nearToTokenDropdown .dropdown-item[data-value="' +
              destinationAsset +
              '"]'
          );
          const fromSymbol = fromTokenElement
            ? fromTokenElement.getAttribute("data-symbol")
            : "Unknown";
          const toSymbol = toTokenElement
            ? toTokenElement.getAttribute("data-symbol")
            : "Unknown";

          this.log(
            `Starting Near Intents swap: ${amountValue} ${fromSymbol} → ${toSymbol}`,
            "info"
          );
          this.log(`Recipient: ${recipientAddress}`, "info");
          this.log(`Slippage: ${slippageBps / 100}%`, "info");

          try {
            // Step 1: Get quote
            this.log("Getting quote...", "info");
            const quotePayload = {
              dry: false, // Real swap
              swapType: "EXACT_INPUT",
              slippageTolerance: slippageBps,
              originAsset,
              depositType: "ORIGIN_CHAIN",
              destinationAsset,
              amount: amountValue.toString(),
              refundTo: refundAddress,
              refundType: "ORIGIN_CHAIN",
              recipient: formattedRecipient,
              recipientType: "DESTINATION_CHAIN",
              deadline: new Date(
                Date.now() + 24 * 60 * 60 * 1000
              ).toISOString(),
              quoteWaitingTimeMs: 3000,
            };

            const quoteResponse = await fetch(
              "https://1click.chaindefuser.com/v0/quote",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(quotePayload),
              }
            );

            if (!quoteResponse.ok) {
              const errorText = await quoteResponse.text();
              this.log(`Quote failed: HTTP ${quoteResponse.status}`, "error");
              this.log(`Error details: ${errorText}`, "error");
              return;
            }

            const quoteData = await quoteResponse.json();
            this.log(`✅ Quote received!`, "success");
            this.log(
              `Input: ${quoteData.quote.amountInFormatted} ${fromSymbol}`,
              "info"
            );
            this.log(
              `Output: ${quoteData.quote.amountOutFormatted} ${toSymbol}`,
              "info"
            );
            this.log(
              `Deposit Address: ${quoteData.quote.depositAddress}`,
              "info"
            );
            this.log(
              `Deadline: ${new Date(
                quoteData.quote.deadline
              ).toLocaleString()}`,
              "info"
            );

            // Store swap info for status checking
            window.nearSwapInfo = {
              depositAddress: quoteData.quote.depositAddress,
              originAsset,
              destinationAsset,
              amount: amountValue.toString(),
              recipient: recipientAddress,
              timestamp: Date.now(),
            };

            this.log(
              `<br><b>⚠️ IMPORTANT:</b> Send ${quoteData.quote.amountInFormatted} ${fromSymbol} to:`,
              "warning"
            );
            this.log(`<b>${quoteData.quote.depositAddress}</b>`, "info");
            this.log(
              `<br>Use <b>near status ${quoteData.quote.depositAddress}</b> to check swap progress`,
              "info"
            );
          } catch (e) {
            this.log(`Swap failed: ${e.message}`, "error");
          }
        }

        // Polymarket Prediction Market Functions
        async getPolymarketMarkets() {
          try {
            this.log("Fetching Polymarket prediction markets...", "info");

            // Try multiple API endpoints
            let data = null;
            let response = null;

            // Try the main API first
            try {
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=20",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Primary API failed, trying alternative...", "warning");
            }

            // If primary failed, try alternative endpoint
            if (!data) {
              try {
                response = await fetch("https://clob.polymarket.com/markets", {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                });

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e) {
                this.log("Alternative API also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              let html = `<b>🔮 Polymarket Prediction Markets (${data.length} shown)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

              data.forEach((market, index) => {
                const status = market.active
                  ? "🟢 Active"
                  : market.closed
                  ? "🔴 Closed"
                  : "🟡 Archived";
                const endDate = market.end_date_iso
                  ? new Date(market.end_date_iso).toLocaleDateString()
                  : "N/A";
                const outcomes = market.tokens
                  ? market.tokens.map((t) => t.outcome).join(" / ")
                  : "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  market.question || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'>${status}</td>`;
                html += `<td style='padding:8px;'>${endDate}</td>`;
                html += `<td style='padding:8px;'>${outcomes}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;
              html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
              this.logHtml(html, "output");
            } else if (data && typeof data === "object") {
              // Handle different response formats
              const markets = data.markets || data.data || data.results || [];
              if (Array.isArray(markets) && markets.length > 0) {
                let html = `<b>🔮 Polymarket Prediction Markets (${markets.length} shown)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                markets.forEach((market, index) => {
                  const status = market.active
                    ? "🟢 Active"
                    : market.closed
                    ? "🔴 Closed"
                    : "🟡 Archived";
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${status}</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                html += `<br><small>Use "polymarket market &lt;id&gt;" to get detailed info for a specific market</small>`;
                this.logHtml(html, "output");
              } else {
                this.log("No markets found in response.", "warning");
                this.log(
                  `Response structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            } else {
              this.log(
                "No markets found or invalid response format.",
                "warning"
              );
              if (response) {
                this.log(`HTTP Status: ${response.status}`, "info");
                const text = await response.text();
                this.log(`Response: ${text.substring(0, 200)}...`, "info");
              }
            }
          } catch (e) {
            this.log(
              `Failed to fetch Polymarket markets: ${e.message}`,
              "error"
            );
            this.log(
              "This might be due to CORS restrictions or API changes.",
              "info"
            );

            // Show sample data for demonstration
            this.log(
              "Showing sample Polymarket data for demonstration:",
              "info"
            );
            const sampleMarkets = [
              {
                question: "Will Bitcoin reach $100,000 by end of 2024?",
                active: true,
                end_date_iso: "2024-12-31T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
              {
                question: "Will Ethereum 2.0 launch before June 2024?",
                active: true,
                end_date_iso: "2024-06-30T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
              {
                question: "Will the US have a recession in 2024?",
                active: true,
                end_date_iso: "2024-12-31T23:59:59Z",
                tokens: [{ outcome: "Yes" }, { outcome: "No" }],
              },
            ];

            let html = `<b>🔮 Sample Polymarket Prediction Markets (Demo)</b><br>`;
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            sampleMarkets.forEach((market, index) => {
              const status = market.active ? "🟢 Active" : "🔴 Closed";
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'>${status}</td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;
            html += `<br><small>Note: This is sample data. Real API access requires server-side proxy due to CORS restrictions.</small>`;
            this.logHtml(html, "output");
          }
        }

        async getPolymarketLiveMarkets() {
          try {
            this.log("Fetching live Polymarket prediction markets...", "info");

            let data = null;
            let response = null;

            try {
              // Use the same approach as active markets but with different endpoint
              this.log(
                "Attempting API call to Polymarket live markets...",
                "info"
              );
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (!response.ok) {
                // Try with CORS proxy
                this.log("Direct API failed, trying CORS proxy...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try alternative CORS proxy
                this.log(
                  "First CORS proxy failed, trying alternative...",
                  "info"
                );
                response = await fetch(
                  "https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=200&sort=volume&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
                throw new Error(`API returned status: ${response.status}`);
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              // Handle object response format (same as active markets)
              this.log("Processing live markets response format...", "info");

              // Handle GraphQL response format
              let markets = [];
              if (data.data && data.data.markets) {
                markets = data.data.markets;
                this.log("Processing GraphQL response format...", "info");
              } else {
                markets = data.markets || data.data || data.results || [];
                this.log("Processing REST API response format...", "info");
              }

              this.log(`Found ${markets.length} live markets`, "info");

              // Filter for active markets
              let liveMarkets = markets.filter((market) => {
                if (
                  !market.active ||
                  !market.question ||
                  !market.tokens ||
                  market.tokens.length === 0
                ) {
                  return false;
                }

                // Check if market is still open
                if (market.end_date_iso) {
                  const endDate = new Date(market.end_date_iso);
                  const now = new Date();
                  const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);

                  // Only include markets that haven't ended or ended within the last 7 days
                  if (daysDiff < -7) {
                    return false;
                  }
                }

                return true;
              });

              this.log(
                `Found ${liveMarkets.length} truly live markets`,
                "info"
              );

              if (liveMarkets.length > 0) {
                const displayMarkets = liveMarkets.slice(0, 20);

                let html = `<b>🟢 Live Polymarket Prediction Markets (${liveMarkets.length} total, showing first 20)</b><br>`;

                // Add category filter buttons
                html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                html += `<b>Quick Filters:</b> `;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${liveMarkets.length})</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                html += `</div>`;

                // Add search box
                html += `<div style='margin: 10px 0;'>`;
                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                html += `</div>`;

                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                displayMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const category = this.getMarketCategory(
                    market.question || ""
                  );

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;

                // Store markets for filtering
                window.polymarketActiveMarkets = liveMarkets;

                this.logHtml(html, "output");

                // Add search functionality
                this.setupPolymarketSearch();
              } else {
                this.log("No live markets found.", "warning");
              }
            } else {
              this.log("No valid data received for live markets.", "warning");
            }
          } catch (e) {
            this.log(
              `Failed to fetch live Polymarket markets: ${e.message}`,
              "error"
            );
          }
        }

        async getPolymarketRecentMarkets() {
          try {
            this.log(
              "Fetching recent Polymarket prediction markets (last 30 days)...",
              "info"
            );

            let data = null;
            let response = null;

            try {
              // Try to get recent markets with different parameters
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=1000&sort=created_at&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              const markets = data.markets || data.data || data.results || [];
              this.log(`Found ${markets.length} total markets`, "info");

              // Filter for markets created in the last 30 days
              const thirtyDaysAgo = new Date();
              thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

              let recentMarkets = markets.filter((market) => {
                if (
                  !market.active ||
                  !market.question ||
                  !market.tokens ||
                  market.tokens.length === 0
                ) {
                  return false;
                }

                // Check creation date if available
                if (market.created_at) {
                  const createdDate = new Date(market.created_at);
                  return createdDate >= thirtyDaysAgo;
                }

                // If no creation date, check end date (must be in the future or recent past)
                if (market.end_date_iso) {
                  const endDate = new Date(market.end_date_iso);
                  const now = new Date();
                  const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);
                  return daysDiff > -30; // Within 30 days of end date
                }

                return true; // Include if no date info available
              });

              this.log(
                `Found ${recentMarkets.length} recent markets (last 30 days)`,
                "info"
              );

              if (recentMarkets.length > 0) {
                const displayMarkets = recentMarkets.slice(0, 20);

                let html = `<b>🟢 Recent Polymarket Prediction Markets (${recentMarkets.length} total, showing first 20)</b><br>`;

                // Add category filter buttons
                html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                html += `<b>Quick Filters:</b> `;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${recentMarkets.length})</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                html += `</div>`;

                // Add search box
                html += `<div style='margin: 10px 0;'>`;
                html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                html += `</div>`;

                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                displayMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const category = this.getMarketCategory(
                    market.question || ""
                  );

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;

                // Store markets for filtering
                window.polymarketActiveMarkets = recentMarkets;

                this.logHtml(html, "output");

                // Add search functionality
                this.setupPolymarketSearch();
              } else {
                this.log("No recent markets found.", "warning");
              }
            } else {
              this.log("No valid data received for recent markets.", "warning");
            }
          } catch (e) {
            this.log(
              `Failed to fetch recent Polymarket markets: ${e.message}`,
              "error"
            );
          }
        }

        async getPolymarketActiveMarkets() {
          try {
            this.log(
              "Fetching active Polymarket prediction markets...",
              "info"
            );

            let data = null;
            let response = null;

            try {
              // Try direct API call first (might work in some browsers)
              this.log("Attempting direct API call to Polymarket...", "info");
              response = await fetch(
                "https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (!response.ok) {
                // Try with different CORS proxy
                this.log("Direct API failed, trying CORS proxy...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try another CORS proxy
                this.log(
                  "First CORS proxy failed, trying alternative...",
                  "info"
                );
                response = await fetch(
                  "https://thingproxy.freeboard.io/fetch/https://clob.polymarket.com/markets?limit=500&sort=created_at&order=desc",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              if (!response.ok) {
                // Try Polymarket's public API
                this.log("CORS proxies failed, trying public API...", "info");
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api.polymarket.com/markets?limit=200&status=open",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );
              }

              this.log(`API Response Status: ${response.status}`, "info");

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
                throw new Error(`API returned status: ${response.status}`);
              }

              if (response.ok) {
                data = await response.json();
                this.log(`Received data type: ${typeof data}`, "info");
                this.log(
                  `Total markets received: ${
                    Array.isArray(data) ? data.length : "N/A"
                  }`,
                  "info"
                );
              } else {
                this.log(`API returned status: ${response.status}`, "warning");
              }
            } catch (e) {
              this.log("API request failed", "warning");
              this.log(`Error: ${e.message}`, "info");
            }

            if (data && typeof data === "object" && !Array.isArray(data)) {
              // Handle object response format (this is what the API actually returns)
              this.log("Processing object response format...", "info");
              this.log(`Object keys: ${Object.keys(data).join(", ")}`, "info");

              // Handle GraphQL response format
              let markets = [];
              if (data.data && data.data.markets) {
                markets = data.data.markets;
                this.log("Processing GraphQL response format...", "info");
              } else {
                markets = data.markets || data.data || data.results || [];
                this.log("Processing REST API response format...", "info");
              }

              this.log(`Found ${markets.length} markets in object`, "info");

              if (markets.length > 0) {
                this.log(
                  `Processing ${markets.length} markets from API...`,
                  "info"
                );

                // Filter for truly active markets with strict date checking
                let activeMarkets = markets.filter((market) => {
                  // Must be active
                  if (!market.active) {
                    return false;
                  }

                  // Must have valid question and tokens
                  if (
                    !market.question ||
                    !market.tokens ||
                    market.tokens.length === 0
                  ) {
                    return false;
                  }

                  // Check if market has ended - only show markets that haven't ended or ended very recently
                  if (market.end_date_iso) {
                    const endDate = new Date(market.end_date_iso);
                    const now = new Date();
                    const daysDiff = (endDate - now) / (1000 * 60 * 60 * 24);

                    // Only include markets that haven't ended or ended within the last 7 days
                    if (daysDiff < -7) {
                      return false;
                    }
                  }

                  return true;
                });

                this.log(
                  `Found ${activeMarkets.length} truly active markets after filtering`,
                  "info"
                );

                // If no active markets found, try to get some recent ones
                if (activeMarkets.length === 0) {
                  this.log(
                    "No active markets found, looking for recent markets...",
                    "info"
                  );
                  activeMarkets = markets
                    .filter(
                      (market) =>
                        market.active &&
                        market.question &&
                        market.tokens &&
                        market.tokens.length > 0
                    )
                    .slice(0, 20);

                  this.log(
                    `Found ${activeMarkets.length} recent markets as fallback`,
                    "info"
                  );
                }

                if (activeMarkets.length > 0) {
                  // Limit to first 20 markets for better readability
                  const displayMarkets = activeMarkets.slice(0, 20);

                  let html = `<b>🟢 Active Polymarket Prediction Markets (${activeMarkets.length} total, showing first 20)</b><br>`;

                  // Add category filter buttons
                  html += `<div style='margin: 10px 0; padding: 10px; background: #222; border-radius: 5px;'>`;
                  html += `<b>Quick Filters:</b> `;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${activeMarkets.length})</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
                  html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
                  html += `</div>`;

                  // Add search box
                  html += `<div style='margin: 10px 0;'>`;
                  html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
                  html += `</div>`;

                  html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                  html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                  displayMarkets.forEach((market, index) => {
                    const endDate = market.end_date_iso
                      ? new Date(market.end_date_iso).toLocaleDateString()
                      : "N/A";
                    const outcomes = market.tokens
                      ? market.tokens.map((t) => t.outcome).join(" / ")
                      : "N/A";
                    const category = this.getMarketCategory(
                      market.question || ""
                    );

                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${
                      market.question || "N/A"
                    }</td>`;
                    html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
                    html += `<td style='padding:8px;'>${endDate}</td>`;
                    html += `<td style='padding:8px;'>${outcomes}</td>`;
                    html += `</tr>`;
                  });

                  html += `</table>`;

                  // Add "Show More" button if there are more results
                  if (activeMarkets.length > 20) {
                    html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                      activeMarkets.length - 20
                    } remaining)</button>`;
                  }

                  // Store markets for filtering
                  window.polymarketActiveMarkets = activeMarkets;

                  this.logHtml(html, "output");

                  // Add search functionality
                  this.setupPolymarketSearch();
                } else {
                  this.log(
                    "No active markets found after filtering.",
                    "warning"
                  );
                }
              } else {
                this.log("No markets found in object response.", "warning");
                this.log(
                  `Debug: Data structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            } else if (data && Array.isArray(data)) {
              // Handle direct array response (fallback)
              this.log(
                `Processing array response format with ${data.length} markets...`,
                "info"
              );

              // Filter for truly active markets with better date checking
              let activeMarkets = data.filter((market) => {
                // Debug: Log what we're checking
                const endDate = market.end_date_iso
                  ? new Date(market.end_date_iso)
                  : null;
                const now = new Date();
                const daysDiff = endDate
                  ? (now - endDate) / (1000 * 60 * 60 * 24)
                  : 0;

                // Must be active (but allow closed markets if they're recent)
                if (!market.active) {
                  this.log(`Filtered out: not active`, "info");
                  return false;
                }

                // Additional checks for market validity
                if (market.tokens && market.tokens.length === 0) {
                  this.log(`Filtered out: no tokens`, "info");
                  return false;
                }
                if (!market.question || market.question.trim() === "") {
                  this.log(`Filtered out: no question`, "info");
                  return false;
                }

                // Check if market has ended - but be very lenient (90 days)
                if (market.end_date_iso) {
                  if (endDate < now) {
                    if (daysDiff > 90) {
                      this.log(
                        `Filtered out: ended ${daysDiff.toFixed(0)} days ago`,
                        "info"
                      );
                      return false;
                    }
                  }
                }

                return true;
              });

              this.log(
                `Found ${activeMarkets.length} truly active markets after date filtering`,
                "info"
              );
              this.log(
                `Found ${activeMarkets.length} active markets after filtering`,
                "info"
              );

              if (activeMarkets.length > 0) {
                let html = `<b>🟢 Active Polymarket Prediction Markets (${activeMarkets.length} found)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th><th style='padding:8px;text-align:left;'>Min Order</th></tr>`;

                activeMarkets.forEach((market, index) => {
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";
                  const minOrder = market.minimum_order_size
                    ? `$${market.minimum_order_size}`
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `<td style='padding:8px;'>${minOrder}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                this.logHtml(html, "output");
              } else {
                this.log("No active markets found.", "warning");
              }
            } else {
              this.log("No valid data received.", "warning");
              if (data) {
                this.log(`Debug: Received data type: ${typeof data}`, "info");
                this.log(
                  `Debug: Data structure: ${JSON.stringify(data).substring(
                    0,
                    200
                  )}...`,
                  "info"
                );
              }
            }
          } catch (e) {
            this.log(
              `Failed to fetch active Polymarket markets: ${e.message}`,
              "error"
            );
            this.log(
              "This might be due to CORS restrictions or API changes.",
              "info"
            );
          }
        }

        // Helper function to categorize markets
        getMarketCategory(question) {
          const q = question.toLowerCase();

          // Sports categories
          if (
            q.includes("nfl") ||
            q.includes("nba") ||
            q.includes("mlb") ||
            q.includes("nhl") ||
            q.includes("soccer") ||
            q.includes("football") ||
            q.includes("basketball") ||
            q.includes("baseball") ||
            q.includes("hockey") ||
            q.includes("ufc") ||
            q.includes("boxing") ||
            q.includes("tennis") ||
            q.includes("golf") ||
            q.includes("champion") ||
            q.includes("vs") ||
            q.includes("beat") ||
            q.includes("super bowl") ||
            q.includes("playoff") ||
            q.includes("final") ||
            q.includes("league") ||
            q.includes("cup") ||
            q.includes("tournament")
          ) {
            return "Sports";
          }

          // Politics categories
          if (
            q.includes("election") ||
            q.includes("president") ||
            q.includes("biden") ||
            q.includes("trump") ||
            q.includes("congress") ||
            q.includes("senate") ||
            q.includes("house") ||
            q.includes("democrat") ||
            q.includes("republican") ||
            q.includes("state of the union") ||
            q.includes("hearing") ||
            q.includes("secretary") ||
            q.includes("campaign") ||
            q.includes("vote") ||
            q.includes("poll") ||
            q.includes("government") ||
            q.includes("policy") ||
            q.includes("law")
          ) {
            return "Politics";
          }

          // Entertainment categories
          if (
            q.includes("movie") ||
            q.includes("film") ||
            q.includes("box office") ||
            q.includes("gross") ||
            q.includes("oscar") ||
            q.includes("award") ||
            q.includes("tv") ||
            q.includes("television") ||
            q.includes("show") ||
            q.includes("album") ||
            q.includes("music") ||
            q.includes("concert") ||
            q.includes("actor") ||
            q.includes("actress") ||
            q.includes("director") ||
            q.includes("streaming") ||
            q.includes("netflix") ||
            q.includes("disney")
          ) {
            return "Entertainment";
          }

          // Crypto categories - Much more comprehensive
          if (
            q.includes("bitcoin") ||
            q.includes("ethereum") ||
            q.includes("crypto") ||
            q.includes("token") ||
            q.includes("coin") ||
            q.includes("blockchain") ||
            q.includes("defi") ||
            q.includes("nft") ||
            q.includes("airdrop") ||
            q.includes("btc") ||
            q.includes("eth") ||
            q.includes("sol") ||
            q.includes("solana") ||
            q.includes("xrp") ||
            q.includes("ripple") ||
            q.includes("dogecoin") ||
            q.includes("doge") ||
            q.includes("cardano") ||
            q.includes("ada") ||
            q.includes("polkadot") ||
            q.includes("dot") ||
            q.includes("chainlink") ||
            q.includes("link") ||
            q.includes("uniswap") ||
            q.includes("uni") ||
            q.includes("opensea") ||
            q.includes("blur") ||
            q.includes("pump.fun") ||
            q.includes("price") ||
            q.includes("market cap") ||
            q.includes("fdv") ||
            q.includes("merge") ||
            q.includes("eip") ||
            q.includes("upgrade") ||
            q.includes("wallet") ||
            q.includes("exchange") ||
            q.includes("dex") ||
            q.includes("staking") ||
            q.includes("yield") ||
            q.includes("liquidity") ||
            q.includes("dao") ||
            q.includes("governance") ||
            q.includes("protocol")
          ) {
            return "Crypto";
          }

          // Economy categories
          if (
            q.includes("inflation") ||
            q.includes("recession") ||
            q.includes("gdp") ||
            q.includes("unemployment") ||
            q.includes("fed") ||
            q.includes("interest rate") ||
            q.includes("economy") ||
            q.includes("market") ||
            q.includes("stock") ||
            q.includes("dollar") ||
            q.includes("currency") ||
            q.includes("trade") ||
            q.includes("tariff") ||
            q.includes("tax") ||
            q.includes("debt") ||
            q.includes("bond") ||
            q.includes("treasury") ||
            q.includes("central bank")
          ) {
            return "Economy";
          }

          return "Other";
        }

        // Filter markets by category
        filterPolymarketMarkets(category) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available for filtering.", "warning");
            return;
          }

          let filteredMarkets = window.polymarketActiveMarkets;

          if (category !== "all") {
            // Convert category to proper case for comparison
            const categoryMap = {
              sports: "Sports",
              politics: "Politics",
              entertainment: "Entertainment",
              crypto: "Crypto",
              economy: "Economy",
            };
            const targetCategory = categoryMap[category] || category;

            filteredMarkets = window.polymarketActiveMarkets.filter(
              (market) =>
                this.getMarketCategory(market.question || "") === targetCategory
            );
          }

          // Display filtered results
          const displayMarkets = filteredMarkets.slice(0, 20);

          let html = `<b>🟢 ${
            category.charAt(0).toUpperCase() + category.slice(1)
          } Markets (${
            filteredMarkets.length
          } total, showing first 20)</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are more results
            if (filteredMarkets.length > 20) {
              html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - 20
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found in this category.</p>`;
          }

          this.logHtml(html, "output");
        }

        // Show more markets for a category
        showMorePolymarketMarkets(category, currentCount) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available.", "warning");
            return;
          }

          let filteredMarkets = window.polymarketActiveMarkets;

          if (category !== "all") {
            // Convert category to proper case for comparison
            const categoryMap = {
              sports: "Sports",
              politics: "Politics",
              entertainment: "Entertainment",
              crypto: "Crypto",
              economy: "Economy",
            };
            const targetCategory = categoryMap[category] || category;

            filteredMarkets = window.polymarketActiveMarkets.filter(
              (market) =>
                this.getMarketCategory(market.question || "") === targetCategory
            );
          }

          // Show next batch of results
          const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
          const displayMarkets = filteredMarkets.slice(0, nextBatch);

          let html = `<b>🟢 ${
            category.charAt(0).toUpperCase() + category.slice(1)
          } Markets (${
            filteredMarkets.length
          } total, showing ${nextBatch})</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < filteredMarkets.length) {
              html += `<br><button onclick="window.terminal.showMorePolymarketMarkets('${category}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found in this category.</p>`;
          }

          this.logHtml(html, "output");
        }

        // Search within displayed markets
        searchPolymarketResults(query) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available for search.", "warning");
            return;
          }

          // If query is empty, show all markets
          if (!query || !query.trim()) {
            this.filterPolymarketMarkets("all");
            return;
          }

          const filteredMarkets = window.polymarketActiveMarkets.filter(
            (market) =>
              market.question &&
              market.question.toLowerCase().includes(query.toLowerCase())
          );

          const displayMarkets = filteredMarkets.slice(0, 20);

          let html = `<b>🔍 Search Results for "${query}" (${filteredMarkets.length} found, showing first 20)</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const category = this.getMarketCategory(market.question || "");

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are more results
            if (filteredMarkets.length > 20) {
              html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - 20
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found matching "${query}".</p>`;
          }

          this.logHtml(html, "output");
        }

        // Show more all markets
        showMoreAllPolymarketMarkets(currentCount) {
          if (!window.polymarketActiveMarkets) {
            this.log("No markets available.", "warning");
            return;
          }

          // Show next batch of results
          const nextBatch = Math.min(
            currentCount + 20,
            window.polymarketActiveMarkets.length
          );
          const displayMarkets = window.polymarketActiveMarkets.slice(
            0,
            nextBatch
          );

          let html = `<b>🟢 Active Polymarket Prediction Markets (${window.polymarketActiveMarkets.length} total, showing ${nextBatch})</b><br>`;

          // Add category filter buttons
          html += `<div style='margin: 10px 0;'><b>Quick Filters:</b><br>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('all')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>All (${window.polymarketActiveMarkets.length})</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('sports')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Sports</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('politics')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Politics</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('entertainment')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Entertainment</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('crypto')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Crypto</button>`;
          html += `<button onclick="window.terminal.filterPolymarketMarkets('economy')" style='margin: 2px; padding: 5px 10px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Economy</button>`;
          html += `</div>`;

          // Add search box
          html += `<div style='margin: 10px 0;'>`;
          html += `<input type="text" id="polymarketSearch" placeholder="Search markets..." style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #333; border-radius: 3px; box-sizing: border-box; z-index: 1000; position: relative; pointer-events: auto;" autocomplete="off" spellcheck="false" oninput="window.terminal.searchPolymarketResults(this.value)" onclick="this.focus()" onkeydown="console.log('Key pressed:', event.key)">`;
          html += `<br><small style="color: #666;">Type to search markets (e.g., "bitcoin", "election", "nfl")</small>`;
          html += `</div>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const marketCategory = this.getMarketCategory(
                market.question || ""
              );

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${marketCategory}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < window.polymarketActiveMarkets.length) {
              html += `<br><button onclick="window.terminal.showMoreAllPolymarketMarkets(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                window.polymarketActiveMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found.</p>`;
          }

          this.logHtml(html, "output");

          // Re-add search functionality
          this.setupPolymarketSearch();
        }

        // Setup search functionality for Polymarket
        setupPolymarketSearch() {
          // Since we're using inline event handlers, this function is now simplified
          // The search functionality is handled directly by the oninput attribute
          console.log("Polymarket search functionality ready");

          // Add a test button to help debug search issues
          setTimeout(() => {
            const searchBox = document.getElementById("polymarketSearch");
            if (searchBox) {
              // Add a test button next to the search box
              const testButton = document.createElement("button");
              testButton.textContent = "Test Search";
              testButton.style.cssText =
                "margin-left: 10px; padding: 4px 8px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;";
              testButton.onclick = () => {
                this.log("Testing search functionality...", "info");
                this.searchPolymarketResults("bitcoin");
              };
              searchBox.parentNode.insertBefore(
                testButton,
                searchBox.nextSibling
              );
            }
          }, 1000);
        }

        // Show more search results
        showMoreSearchResults(query, currentCount) {
          if (!window.polymarketActiveMarkets || !query.trim()) {
            return;
          }

          const filteredMarkets = window.polymarketActiveMarkets.filter(
            (market) =>
              market.question &&
              market.question.toLowerCase().includes(query.toLowerCase())
          );

          // Show next batch of results
          const nextBatch = Math.min(currentCount + 20, filteredMarkets.length);
          const displayMarkets = filteredMarkets.slice(0, nextBatch);

          let html = `<b>🔍 Search Results for "${query}" (${filteredMarkets.length} found, showing ${nextBatch})</b><br>`;

          if (displayMarkets.length > 0) {
            html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
            html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Category</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

            displayMarkets.forEach((market, index) => {
              const endDate = market.end_date_iso
                ? new Date(market.end_date_iso).toLocaleDateString()
                : "N/A";
              const outcomes = market.tokens
                ? market.tokens.map((t) => t.outcome).join(" / ")
                : "N/A";
              const category = this.getMarketCategory(market.question || "");

              html += `<tr style='border-bottom:1px solid #444;'>`;
              html += `<td style='padding:8px;'>${
                market.question || "N/A"
              }</td>`;
              html += `<td style='padding:8px;'><span style='color: #99ccff;'>${category}</span></td>`;
              html += `<td style='padding:8px;'>${endDate}</td>`;
              html += `<td style='padding:8px;'>${outcomes}</td>`;
              html += `</tr>`;
            });

            html += `</table>`;

            // Add "Show More" button if there are still more results
            if (nextBatch < filteredMarkets.length) {
              html += `<br><button onclick="window.terminal.showMoreSearchResults('${query}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                filteredMarkets.length - nextBatch
              } remaining)</button>`;
            }
          } else {
            html += `<p>No markets found matching "${query}".</p>`;
          }

          this.logHtml(html, "output");
        }

        async searchPolymarketMarkets(query) {
          try {
            this.log(`Searching Polymarket markets for: "${query}"`, "info");

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://clob.polymarket.com/markets?limit=50`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("API request failed", "warning");
            }

            if (data && Array.isArray(data)) {
              const searchResults = data.filter(
                (market) =>
                  (market.question &&
                    market.question
                      .toLowerCase()
                      .includes(query.toLowerCase())) ||
                  (market.description &&
                    market.description
                      .toLowerCase()
                      .includes(query.toLowerCase())) ||
                  (market.tags &&
                    market.tags.some((tag) =>
                      tag.toLowerCase().includes(query.toLowerCase())
                    ))
              );

              if (searchResults.length > 0) {
                let html = `<b>🔍 Polymarket Search Results for "${query}" (${searchResults.length} found)</b><br>`;
                html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
                html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Question</th><th style='padding:8px;text-align:left;'>Status</th><th style='padding:8px;text-align:left;'>End Date</th><th style='padding:8px;text-align:left;'>Outcomes</th></tr>`;

                searchResults.slice(0, 10).forEach((market, index) => {
                  const status = market.active
                    ? "🟢 Active"
                    : market.closed
                    ? "🔴 Closed"
                    : "🟡 Archived";
                  const endDate = market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleDateString()
                    : "N/A";
                  const outcomes = market.tokens
                    ? market.tokens.map((t) => t.outcome).join(" / ")
                    : "N/A";

                  html += `<tr style='border-bottom:1px solid #444;'>`;
                  html += `<td style='padding:8px;'>${
                    market.question || "N/A"
                  }</td>`;
                  html += `<td style='padding:8px;'>${status}</td>`;
                  html += `<td style='padding:8px;'>${endDate}</td>`;
                  html += `<td style='padding:8px;'>${outcomes}</td>`;
                  html += `</tr>`;
                });

                html += `</table>`;
                if (searchResults.length > 10) {
                  html += `<br><small>Showing first 10 results. Use more specific search terms to narrow results.</small>`;
                }
                this.logHtml(html, "output");
              } else {
                this.log(`No markets found matching "${query}"`, "warning");
              }
            } else {
              this.log("Failed to fetch markets for search.", "error");
            }
          } catch (e) {
            this.log(`Search failed: ${e.message}`, "error");
          }
        }

        async getPolymarketMarketDetails(marketId) {
          try {
            this.log(
              `Fetching details for Polymarket market: ${marketId}`,
              "info"
            );

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://clob.polymarket.com/markets?limit=100`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("API request failed", "warning");
            }

            if (data && Array.isArray(data)) {
              // Try to find market by ID or slug
              const market = data.find(
                (m) =>
                  m.condition_id === marketId ||
                  m.question_id === marketId ||
                  m.market_slug === marketId ||
                  (m.question &&
                    m.question.toLowerCase().includes(marketId.toLowerCase()))
              );

              if (market) {
                let html = `<b>🔮 Polymarket Market Details</b><br>`;
                html += `<div style='background:#222;padding:15px;border-radius:5px;margin:10px 0;'>`;
                html += `<b>Question:</b> ${market.question || "N/A"}<br>`;
                html += `<b>Description:</b> ${
                  market.description
                    ? market.description.substring(0, 200) + "..."
                    : "N/A"
                }<br>`;
                html += `<b>Status:</b> ${
                  market.active
                    ? "🟢 Active"
                    : market.closed
                    ? "🔴 Closed"
                    : "🟡 Archived"
                }<br>`;
                html += `<b>End Date:</b> ${
                  market.end_date_iso
                    ? new Date(market.end_date_iso).toLocaleString()
                    : "N/A"
                }<br>`;
                html += `<b>Minimum Order:</b> ${
                  market.minimum_order_size
                    ? `$${market.minimum_order_size}`
                    : "N/A"
                }<br>`;
                html += `<b>Accepting Orders:</b> ${
                  market.accepting_orders ? "Yes" : "No"
                }<br>`;
                html += `</div>`;

                if (market.tokens && market.tokens.length > 0) {
                  html += `<b>Outcomes:</b><br>`;
                  html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;margin:10px 0;'>`;
                  html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Outcome</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Winner</th></tr>`;

                  market.tokens.forEach((token) => {
                    const price =
                      token.price !== undefined ? `$${token.price}` : "N/A";
                    const winner = token.winner ? "🏆 Yes" : "No";

                    html += `<tr style='border-bottom:1px solid #444;'>`;
                    html += `<td style='padding:8px;'>${
                      token.outcome || "N/A"
                    }</td>`;
                    html += `<td style='padding:8px;'>${price}</td>`;
                    html += `<td style='padding:8px;'>${winner}</td>`;
                    html += `</tr>`;
                  });

                  html += `</table>`;
                }

                if (market.tags && market.tags.length > 0) {
                  html += `<b>Tags:</b> ${market.tags.join(", ")}<br>`;
                }

                this.logHtml(html, "output");
              } else {
                this.log(`Market not found: ${marketId}`, "error");
                this.log(
                  'Try using "polymarket markets" to see available markets',
                  "info"
                );
              }
            } else {
              this.log("Failed to fetch market details.", "error");
            }
          } catch (e) {
            this.log(`Failed to fetch market details: ${e.message}`, "error");
          }
        }

        // Magic Eden NFT Marketplace Functions
        async getMagicEdenCollections() {
          try {
            this.log("Fetching Magic Eden collections...", "info");

            let data = null;
            let response = null;

            try {
              response = await fetch(
                "https://api-mainnet.magiceden.dev/v2/collections",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log("Proxy request also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              const collections = data.slice(0, 20); // Show first 20

              let html = `<b>🎨 Magic Eden Collections (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;

              collections.forEach((collection, index) => {
                const floorPrice = collection.floorPrice
                  ? `${collection.floorPrice} SOL`
                  : "N/A";
                const listed = collection.listedCount || "N/A";
                const supply = collection.supply || "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  collection.name || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
                  collection.symbol || "N/A"
                }</span></td>`;
                html += `<td style='padding:8px;'>${floorPrice}</td>`;
                html += `<td style='padding:8px;'>${listed}</td>`;
                html += `<td style='padding:8px;'>${supply}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenCollections = data;
            } else {
              this.log("Failed to fetch Magic Eden collections.", "error");
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden collections: ${e.message}`,
              "error"
            );
          }
        }

        async getMagicEdenPopularCollections() {
          try {
            this.log("Fetching Magic Eden popular collections...", "info");

            let data = null;
            let response = null;

            try {
              // Try the collections endpoint with sorting by volume
              response = await fetch(
                "https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log(
                  "First proxy failed, trying second proxy...",
                  "warning"
                );
                try {
                  response = await fetch(
                    "https://thingproxy.freeboard.io/fetch/https://api-mainnet.magiceden.dev/v2/collections?limit=50&offset=0",
                    {
                      method: "GET",
                      headers: {
                        Accept: "application/json",
                      },
                    }
                  );

                  if (response.ok) {
                    data = await response.json();
                  }
                } catch (e3) {
                  this.log(
                    "All proxies failed, trying popular collections as fallback",
                    "warning"
                  );
                  try {
                    response = await fetch(
                      "https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/marketplace/popular_collections",
                      {
                        method: "GET",
                        headers: {
                          Accept: "application/json",
                        },
                      }
                    );

                    if (response.ok) {
                      data = await response.json();
                    }
                  } catch (e4) {
                    this.log("All API requests failed", "error");
                  }
                }
              }
            }

            if (data && Array.isArray(data)) {
              const collections = data.slice(0, 20); // Show first 20

              // Fetch stats for each collection to get volume and listed count
              this.log(
                "Fetching detailed stats for each collection...",
                "info"
              );

              const collectionsWithStats = await Promise.all(
                collections.map(async (collection) => {
                  try {
                    let statsResponse = await fetch(
                      `https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`,
                      {
                        method: "GET",
                        headers: {
                          Accept: "application/json",
                          "User-Agent":
                            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                        },
                      }
                    );

                    if (!statsResponse.ok) {
                      // Try proxy if direct request fails
                      statsResponse = await fetch(
                        `https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${collection.symbol}/stats?timeWindow=24h&listingAggMode=true`,
                        {
                          method: "GET",
                          headers: {
                            Accept: "application/json",
                          },
                        }
                      );
                    }

                    if (statsResponse.ok) {
                      const stats = await statsResponse.json();
                      console.log(`Stats for ${collection.symbol}:`, stats); // Debug log
                      return {
                        ...collection,
                        volume1d: stats.volumeAll, // Use volumeAll for 24h volume
                        listedCount: stats.listedCount,
                        floorPrice: stats.floorPrice, // Use floor price from stats
                      };
                    }
                  } catch (e) {
                    // If stats fetch fails, continue with original data
                    console.log(
                      `Failed to fetch stats for ${collection.symbol}:`,
                      e.message
                    );
                  }
                  return collection;
                })
              );

              let html = `<b>🔥 Magic Eden Popular Collections (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume (24h)</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;

              collectionsWithStats.forEach((collection, index) => {
                // Convert to SOL - API returns values in a different unit
                // Based on the API response, it seems like values might be in a smaller unit
                const floorPrice = collection.floorPrice
                  ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL`
                  : "N/A";

                // Use stats data for volume and listed count
                const volume = collection.volume1d
                  ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL`
                  : "N/A";
                const listed = collection.listedCount || "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'>${
                  collection.name || "N/A"
                }</td>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
                  collection.symbol || "N/A"
                }</span></td>`;
                html += `<td style='padding:8px;'>${floorPrice}</td>`;
                html += `<td style='padding:8px;'>${volume}</td>`;
                html += `<td style='padding:8px;'>${listed}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenPopularCollections = collectionsWithStats;
            } else {
              this.log(
                "Failed to fetch Magic Eden popular collections.",
                "error"
              );
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden popular collections: ${e.message}`,
              "error"
            );
          }
        }

        async getMagicEdenCollectionActivities(symbol) {
          try {
            this.log(
              `Fetching Magic Eden activities for collection: ${symbol}`,
              "info"
            );

            let data = null;
            let response = null;

            try {
              response = await fetch(
                `https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`,
                {
                  method: "GET",
                  headers: {
                    Accept: "application/json",
                    "User-Agent":
                      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                  },
                }
              );

              if (response.ok) {
                data = await response.json();
              }
            } catch (e) {
              this.log("Direct API request failed, trying proxy...", "warning");
              try {
                response = await fetch(
                  `https://api.codetabs.com/v1/proxy?quest=https://api-mainnet.magiceden.dev/v2/collections/${symbol}/activities`,
                  {
                    method: "GET",
                    headers: {
                      Accept: "application/json",
                    },
                  }
                );

                if (response.ok) {
                  data = await response.json();
                }
              } catch (e2) {
                this.log("Proxy request also failed", "warning");
              }
            }

            if (data && Array.isArray(data)) {
              const activities = data.slice(0, 20); // Show first 20

              let html = `<b>📊 Magic Eden Activities for ${symbol} (${data.length} total, showing first 20)</b><br>`;
              html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
              html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;

              activities.forEach((activity, index) => {
                const type = activity.type || "N/A";
                const price = activity.price ? `${activity.price} SOL` : "N/A";
                const token = activity.tokenMint
                  ? activity.tokenMint.substring(0, 8) + "..."
                  : "N/A";
                const time = activity.blockTime
                  ? new Date(activity.blockTime * 1000).toLocaleString()
                  : "N/A";
                const buyer = activity.buyer
                  ? activity.buyer.substring(0, 8) + "..."
                  : "N/A";
                const seller = activity.seller
                  ? activity.seller.substring(0, 8) + "..."
                  : "N/A";

                html += `<tr style='border-bottom:1px solid #444;'>`;
                html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
                html += `<td style='padding:8px;'>${price}</td>`;
                html += `<td style='padding:8px;'>${token}</td>`;
                html += `<td style='padding:8px;'>${time}</td>`;
                html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
                html += `</tr>`;
              });

              html += `</table>`;

              if (data.length > 20) {
                html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', 20)" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
                  data.length - 20
                } remaining)</button>`;
              }

              this.logHtml(html, "output");
              window.magicEdenActivities = data;
            } else {
              this.log(
                `Failed to fetch activities for collection: ${symbol}`,
                "error"
              );
            }
          } catch (e) {
            this.log(
              `Failed to fetch Magic Eden activities: ${e.message}`,
              "error"
            );
          }
        }

        // Helper functions for "Show More" buttons
        showMoreMagicEdenCollections(currentCount) {
          if (!window.magicEdenCollections) {
            this.log("No collections available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenCollections.length
          );
          const collections = window.magicEdenCollections.slice(0, nextBatch);

          let html = `<b>🎨 Magic Eden Collections (${window.magicEdenCollections.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Listed</th><th style='padding:8px;text-align:left;'>Supply</th></tr>`;

          collections.forEach((collection, index) => {
            const floorPrice = collection.floorPrice
              ? `${collection.floorPrice} SOL`
              : "N/A";
            const listed = collection.listedCount || "N/A";
            const supply = collection.supply || "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'>${collection.name || "N/A"}</td>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
              collection.symbol || "N/A"
            }</span></td>`;
            html += `<td style='padding:8px;'>${floorPrice}</td>`;
            html += `<td style='padding:8px;'>${listed}</td>`;
            html += `<td style='padding:8px;'>${supply}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenCollections.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenCollections.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        showMoreMagicEdenPopularCollections(currentCount) {
          if (!window.magicEdenPopularCollections) {
            this.log("No popular collections available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenPopularCollections.length
          );
          const collections = window.magicEdenPopularCollections.slice(
            0,
            nextBatch
          );

          let html = `<b>🔥 Magic Eden Popular Collections (${window.magicEdenPopularCollections.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Name</th><th style='padding:8px;text-align:left;'>Symbol</th><th style='padding:8px;text-align:left;'>Floor Price</th><th style='padding:8px;text-align:left;'>Volume</th><th style='padding:8px;text-align:left;'>Listed</th></tr>`;

          collections.forEach((collection, index) => {
            // Convert lamports to SOL (1 SOL = 1,000,000,000 lamports)
            const floorPrice = collection.floorPrice
              ? `${(collection.floorPrice / 1000000000).toFixed(3)} SOL`
              : "N/A";

            // Use stats data for volume and listed count
            const volume = collection.volume1d
              ? `${(collection.volume1d / 1000000000).toFixed(1)} SOL`
              : "N/A";
            const listed = collection.listedCount || "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'>${collection.name || "N/A"}</td>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${
              collection.symbol || "N/A"
            }</span></td>`;
            html += `<td style='padding:8px;'>${floorPrice}</td>`;
            html += `<td style='padding:8px;'>${volume}</td>`;
            html += `<td style='padding:8px;'>${listed}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenPopularCollections.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenPopularCollections(${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenPopularCollections.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        showMoreMagicEdenActivities(symbol, currentCount) {
          if (!window.magicEdenActivities) {
            this.log("No activities available.", "warning");
            return;
          }

          const nextBatch = Math.min(
            currentCount + 20,
            window.magicEdenActivities.length
          );
          const activities = window.magicEdenActivities.slice(0, nextBatch);

          let html = `<b>📊 Magic Eden Activities for ${symbol} (${window.magicEdenActivities.length} total, showing ${nextBatch})</b><br>`;
          html += `<table style='width:100%;font-size:0.9em;border-collapse:collapse;'>`;
          html += `<tr style='background:#333;'><th style='padding:8px;text-align:left;'>Type</th><th style='padding:8px;text-align:left;'>Price</th><th style='padding:8px;text-align:left;'>Token</th><th style='padding:8px;text-align:left;'>Time</th><th style='padding:8px;text-align:left;'>Buyer/Seller</th></tr>`;

          activities.forEach((activity, index) => {
            const type = activity.type || "N/A";
            const price = activity.price ? `${activity.price} SOL` : "N/A";
            const token = activity.tokenMint
              ? activity.tokenMint.substring(0, 8) + "..."
              : "N/A";
            const time = activity.blockTime
              ? new Date(activity.blockTime * 1000).toLocaleString()
              : "N/A";
            const buyer = activity.buyer
              ? activity.buyer.substring(0, 8) + "..."
              : "N/A";
            const seller = activity.seller
              ? activity.seller.substring(0, 8) + "..."
              : "N/A";

            html += `<tr style='border-bottom:1px solid #444;'>`;
            html += `<td style='padding:8px;'><span style='color: #99ccff;'>${type}</span></td>`;
            html += `<td style='padding:8px;'>${price}</td>`;
            html += `<td style='padding:8px;'>${token}</td>`;
            html += `<td style='padding:8px;'>${time}</td>`;
            html += `<td style='padding:8px;'>${buyer} / ${seller}</td>`;
            html += `</tr>`;
          });

          html += `</table>`;

          if (nextBatch < window.magicEdenActivities.length) {
            html += `<br><button onclick="window.terminal.showMoreMagicEdenActivities('${symbol}', ${nextBatch})" style='margin: 5px; padding: 8px 16px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; cursor: pointer;'>Show More (${
              window.magicEdenActivities.length - nextBatch
            } remaining)</button>`;
          }

          this.logHtml(html, "output");
        }

        async handleRomeCommand(args) {
          if (!args || args.length < 2) {
            this.log("🏛️ ROME NETWORK COMMANDS", "info");
            this.log("═══════════════════════════", "info");
            this.log("", "info");
            this.log("📋 AVAILABLE COMMANDS:", "info");
            this.log("  rome connect     Connect to Rome Network", "output");
            this.log("  rome balance     Check Rome Network balance", "output");
            this.log("  rome status      Show Rome Network status", "output");
            this.log(
              "  rome info        Display Rome Network information",
              "output"
            );
            this.log("  rome gen-wallet  Generate a new Rome wallet", "output");
            this.log(
              "  rome token create Create a new token on Rome",
              "output"
            );
            this.log(
              "  rome ens         ENS commands (register/resolve)",
              "output"
            );
            this.log(
              "  rome send        Send tokens via ENS or address",
              "output"
            );
            this.log(
              "  rome nft mint    Mint NFT on Rome Network with UI",
              "output"
            );
            this.log("  rome help        Show this help message", "output");
            this.log("", "info");
            this.log("🎯 EXAMPLES:", "info");
            this.log("  rome connect     # Connect to Rome Network", "info");
            this.log("  rome balance     # Check your Rome balance", "info");
            this.log("  rome gen-wallet  # Generate new Rome wallet", "info");
            this.log("  rome token create # Create Rome token", "info");
            this.log(
              "  rome ens register myname  # Register myname.rome",
              "info"
            );
            this.log(
              "  rome ens resolve myname   # Look up myname.rome",
              "info"
            );
            this.log(
              "  rome send 1 rSOL roman.rome  # Send 1 rSOL to roman.rome",
              "info"
            );
            this.log(
              "  rome send 100 TOKEN 0x123...  # Send 100 TOKEN to address",
              "info"
            );
            this.log("  rome nft mint    # Open NFT minting UI", "info");
            this.log("", "info");
            this.log(
              "💡 Rome Network is a Layer 2 scaling solution!",
              "success"
            );
            return;
          }

          const subcommand = args[1].toLowerCase();

          switch (subcommand) {
            case "connect":
              this.connectToRomeNetwork();
              break;

            case "balance":
              this.checkRomeBalance();
              break;

            case "status":
              this.log("📊 Rome Network Status", "info");
              this.log("═══════════════════════", "info");
              this.log("🌐 Network: Rome Layer 2", "info");
              this.log("⛏️ Block Height: 2,847,392", "info");
              this.log("⏱️ Block Time: 2.1s", "info");
              this.log("💨 Gas Price: 0.001 ROME", "info");
              this.log("🔗 Validators: 127 active", "info");
              this.log("✅ Network Status: Healthy", "success");
              break;

            case "info":
              this.log("🏛️ Rome Network Information", "info");
              this.log("════════════════════════════", "info");
              this.log("📝 Description: Layer 2 scaling solution", "info");
              this.log("⚡ Features:", "info");
              this.log("  • Fast transaction processing", "info");
              this.log("  • Low transaction fees", "info");
              this.log("  • High throughput", "info");
              this.log("  • EVM compatibility", "info");
              this.log("  • Decentralized consensus", "info");
              this.log("🌐 Website: https://rome.network", "info");
              this.log("📚 Docs: https://docs.rome.network", "info");
              break;

            case "gen-wallet":
              this.log("🏛️ Generating new Rome Network wallet...", "info");
              this.log(
                "🔐 Creating secure wallet with Rome Layer 2 compatibility",
                "info"
              );

              // Generate a new wallet (using ethers.js if available)
              if (typeof ethers !== "undefined") {
                const wallet = ethers.Wallet.createRandom();
                this.log("✅ Rome wallet generated successfully!", "success");
                this.log("", "info");
                this.log("📋 WALLET DETAILS:", "info");
                this.log(`🏛️ Address: ${wallet.address}`, "output");
                this.log(`🔑 Private Key: ${wallet.privateKey}`, "output");
                this.log(`📧 Mnemonic: ${wallet.mnemonic.phrase}`, "output");
                this.log("", "info");
                this.log(
                  "⚠️  SECURITY WARNING: Save these details securely!",
                  "error"
                );
                this.log(
                  "💡 This wallet is compatible with Rome Network Layer 2",
                  "info"
                );
              } else {
                this.log(
                  "❌ Error: Ethers.js not available for wallet generation",
                  "error"
                );
                this.log(
                  "💡 Rome wallet generation requires Web3 library",
                  "info"
                );
              }
              break;

            case "token":
              if (args.length < 3) {
                this.log("🏛️ ROME TOKEN COMMANDS", "info");
                this.log("═══════════════════════", "info");
                this.log("", "info");
                this.log("📋 AVAILABLE TOKEN COMMANDS:", "info");
                this.log(
                  "  rome token create <name> <symbol> <supply>  Create new Rome token",
                  "output"
                );
                this.log("", "info");
                this.log("🎯 EXAMPLES:", "info");
                this.log("  rome token create RomeCoin ROME 1000000", "info");
                this.log("  rome token create MyToken MTK 500000", "info");
                return;
              }

              if (args[2] === "create") {
                if (args.length < 6) {
                  this.log(
                    "❌ Usage: rome token create <name> <symbol> <supply> [decimals]",
                    "error"
                  );
                  this.log(
                    "🎯 Example: rome token create RomeCoin ROME 1000000 18",
                    "info"
                  );
                  return;
                }

                const tokenName = args[3];
                const tokenSymbol = args[4];
                const tokenSupply = parseInt(args[5]);
                const decimals = args[6] ? parseInt(args[6]) : 18;

                if (isNaN(tokenSupply) || tokenSupply <= 0) {
                  this.log(
                    "❌ Invalid token supply. Must be a positive number.",
                    "error"
                  );
                  return;
                }

                if (isNaN(decimals) || decimals < 0 || decimals > 18) {
                  this.log(
                    "❌ Invalid decimals. Must be between 0 and 18.",
                    "error"
                  );
                  return;
                }

                this.log(
                  "🏛️ Creating Rome Network token via Factory...",
                  "info"
                );
                this.log(`📝 Token Name: ${tokenName}`, "info");
                this.log(`🏷️ Symbol: ${tokenSymbol}`, "info");
                this.log(`💰 Supply: ${tokenSupply.toLocaleString()}`, "info");
                this.log(`🔢 Decimals: ${decimals}`, "info");
                this.log("", "info");
                this.log("⚡ Calling Rome Token Factory...", "info");

                // Call the factory to create the token
                this.createRomeTokenViaFactory(
                  tokenName,
                  tokenSymbol,
                  tokenSupply,
                  decimals
                );
              } else {
                this.log(`Unknown token command: ${args[2]}`, "error");
                this.log(
                  'Type "rome token" for available token commands',
                  "info"
                );
              }
              break;

            case "ens":
              if (args.length < 3) {
                this.log("🏛️ ROME ENS COMMANDS", "info");
                this.log("═══════════════════════", "info");
                this.log("", "info");
                this.log("📋 AVAILABLE ENS COMMANDS:", "info");
                this.log(
                  "  rome ens register <username>  Register .rome username",
                  "output"
                );
                this.log(
                  "  rome ens resolve <username>   Resolve .rome username",
                  "output"
                );
                this.log("", "info");
                this.log("🎯 EXAMPLES:", "info");
                this.log(
                  "  rome ens register terminal   # Register terminal.rome",
                  "info"
                );
                this.log(
                  "  rome ens resolve terminal    # Look up terminal.rome",
                  "info"
                );
                this.log("", "info");
                this.log("📋 VALID CHARACTERS:", "info");
                this.log("  • Letters (a-z, A-Z)", "info");
                this.log("  • Numbers (0-9)", "info");
                this.log("  • Hyphens (-) and Underscores (_)", "info");
                this.log("  • Max length: 32 characters", "info");
                return;
              }

              const ensAction = args[2].toLowerCase();

              if (ensAction === "register") {
                if (args.length < 4) {
                  this.log("❌ Usage: rome ens register <username>", "error");
                  this.log("🎯 Example: rome ens register terminal", "info");
                  return;
                }
                const ensName = args[3];
                await this.registerRomeUsername(ensName);
              } else if (ensAction === "resolve") {
                if (args.length < 4) {
                  this.log("❌ Usage: rome ens resolve <username>", "error");
                  this.log("🎯 Example: rome ens resolve terminal", "info");
                  return;
                }
                const ensName = args[3];
                await this.resolveRomeUsername(ensName);
              } else {
                // Backwards compatibility - treat as register command
                const ensName = args[2];
                await this.registerRomeUsername(ensName);
              }
              break;

            case "send":
              if (args.length < 4) {
                this.log("🏛️ ROME SEND COMMANDS", "info");
                this.log("═══════════════════════", "info");
                this.log("", "info");
                this.log("📋 USAGE:", "info");
                this.log("  rome send <amount> <token> <recipient>", "output");
                this.log("", "info");
                this.log("🎯 EXAMPLES:", "info");
                this.log(
                  "  rome send 1 rSOL roman.rome        # Send 1 rSOL to roman.rome",
                  "info"
                );
                this.log(
                  "  rome send 100 TOKEN 0x123...       # Send 100 TOKEN to address",
                  "info"
                );
                this.log(
                  "  rome send 0.5 rSOL alice.rome      # Send 0.5 rSOL to alice.rome",
                  "info"
                );
                this.log("", "info");
                this.log(
                  "💡 Recipients can be ENS names (.rome) or wallet addresses",
                  "info"
                );
                this.log(
                  "💡 Token can be rSOL (native) or any ERC-20 token symbol",
                  "info"
                );
                return;
              }

              const amount = args[2];
              const token = args[3];
              const recipient = args[4];

              await this.sendRomeTokens(amount, token, recipient);
              break;

            case "nft":
              if (args.length < 3) {
                this.log("🏛️ ROME NFT COMMANDS", "info");
                this.log("═══════════════════════", "info");
                this.log("", "info");
                this.log("📋 AVAILABLE NFT COMMANDS:", "info");
                this.log(
                  "  rome nft mint    Mint NFT on Rome Network with UI",
                  "output"
                );
                this.log("", "info");
                this.log("🎯 EXAMPLES:", "info");
                this.log("  rome nft mint    # Open NFT minting UI", "info");
                this.log("", "info");
                this.log(
                  "💡 Upload image, add metadata, and mint on Rome Network!",
                  "info"
                );
                return;
              }

              if (args[2] === "mint") {
                // Open Rome NFT minting UI
                this.openRomeNFTMintUI();
              } else {
                this.log(`Unknown NFT command: ${args[2]}`, "error");
                this.log('Type "rome nft" for available NFT commands', "info");
              }
              break;

            case "help":
              this.handleRomeCommand(["rome"]);
              break;

            default:
              this.log(`Unknown Rome command: ${subcommand}`, "error");
              this.log('Type "rome help" for available commands', "info");
          }
        }

        async handleMonadCommand(args) {
          if (!args || args.length < 2) {
            this.log("🔷 MONAD NETWORK COMMANDS", "info");
            this.log("═══════════════════════════", "info");
            this.log("", "info");
            this.log("📋 AVAILABLE COMMANDS:", "info");
            this.log("  monad connect     Connect to MONAD Network", "output");
            this.log(
              "  monad balance     Check MONAD Network balance",
              "output"
            );
            this.log(
              "  monad network     Show MONAD Network information",
              "output"
            );
            this.log("  monad validators  View MONAD validators", "output");
            this.log("  monad transactions View transaction history", "output");
            this.log("  monad staking     MONAD staking operations", "output");
            this.log("  monad governance  MONAD governance features", "output");
            this.log("  monad help        Show this help message", "output");
            this.log("", "info");
            this.log(
              "💡 MONAD is a high-performance EVM-compatible blockchain",
              "info"
            );
            this.log(
              "   with advanced consensus and parallel execution",
              "info"
            );
            return;
          }

          const subcommand = args[1].toLowerCase();

          switch (subcommand) {
            case "connect":
              this.log("🔷 Connecting to MONAD Network...", "info");
              this.log("MONAD Network connection coming soon!", "info");
              this.log(
                "This will connect your wallet to the MONAD blockchain",
                "output"
              );
              break;

            case "balance":
              this.log("💰 Checking MONAD balance...", "info");

              // Play balance/wealth sound effect
              if (
                window.OmegaSoundEffects &&
                window.OmegaSoundEffects.isSoundEnabled()
              ) {
                window.OmegaSoundEffects.playBalanceWealthSound();
              }

              this.log("MONAD balance checking coming soon!", "info");
              this.log("This will show your MONAD token balance", "output");
              break;

            case "network":
              this.log("🌐 MONAD Network Information", "info");
              this.log("════════════════════════════", "info");
              this.log("", "info");
              this.log("🔷 Network: MONAD", "output");
              this.log("⚡ Consensus: MonadBFT", "output");
              this.log("🚀 Parallel Execution: Yes", "output");
              this.log("🔗 EVM Compatible: Yes", "output");
              this.log("⛽ Gas Model: EIP-1559", "output");
              this.log("", "info");
              this.log(
                "MONAD is a high-performance EVM-compatible blockchain",
                "info"
              );
              this.log(
                "featuring parallel execution and advanced consensus",
                "info"
              );
              break;

            case "validators":
              this.log("✅ MONAD Validators", "info");
              this.log("MONAD validator information coming soon!", "info");
              this.log(
                "This will show active validators and their status",
                "output"
              );
              break;

            case "transactions":
              this.log("📋 MONAD Transaction History", "info");
              this.log("MONAD transaction history coming soon!", "info");
              this.log(
                "This will show your transaction history on MONAD",
                "output"
              );
              break;

            case "staking":
              this.log("🏦 MONAD Staking", "info");
              this.log("MONAD staking features coming soon!", "info");
              this.log("This will allow you to stake MONAD tokens", "output");
              break;

            case "governance":
              this.log("🗳️ MONAD Governance", "info");
              this.log("MONAD governance features coming soon!", "info");
              this.log(
                "This will show governance proposals and voting",
                "output"
              );
              break;

            case "help":
              this.handleMonadCommand(["monad"]);
              break;

            default:
              this.log(`Unknown MONAD command: ${subcommand}`, "error");
              this.log('Type "monad help" for available commands', "info");
          }
        }

        async connectToRomeNetwork() {
          if (!window.ethereum) {
            this.log(
              "❌ MetaMask not detected. Please install MetaMask.",
              "error"
            );
            return;
          }

          try {
            this.log("🏛️ Connecting to Rome Network...", "info");

            // Rome Network configuration
            const ROME_CONFIG = {
              chainId: "0x1d97c", // 121212 in hex
              chainName: "Rome Devnet Esquiline",
              nativeCurrency: {
                name: "RSOL",
                symbol: "RSOL",
                decimals: 18,
              },
              rpcUrls: ["https://esquiline-i.devnet.romeprotocol.xyz"],
              blockExplorerUrls: [
                "https://romescout-esquiline-i.devnet.romeprotocol.xyz",
              ],
            };

            // Try to switch to Rome network first
            try {
              await window.ethereum.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: ROME_CONFIG.chainId }],
              });
              this.log("✅ Switched to Rome Devnet Esquiline", "success");
            } catch (switchError) {
              // Network not added, add it
              if (switchError.code === 4902) {
                this.log("📡 Adding Rome Network to MetaMask...", "info");
                await window.ethereum.request({
                  method: "wallet_addEthereumChain",
                  params: [ROME_CONFIG],
                });
                this.log("✅ Rome Network added to MetaMask", "success");
              } else {
                throw switchError;
              }
            }

            // Get account info
            const accounts = await window.ethereum.request({
              method: "eth_accounts",
            });

            if (accounts.length === 0) {
              this.log("🔐 Please connect your wallet in MetaMask", "info");
              await window.ethereum.request({
                method: "eth_requestAccounts",
              });
            }

            // Get current network info
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId === ROME_CONFIG.chainId) {
              this.log("🏛️ Successfully connected to Rome Network!", "success");
              this.log("", "info");
              this.log("📋 Network Details:", "info");
              this.log(`🏛️ Network: ${ROME_CONFIG.chainName}`, "info");
              this.log(`🔗 Chain ID: 121212 (0x1d97c)`, "info");
              this.log(
                `💰 Currency: ${ROME_CONFIG.nativeCurrency.symbol}`,
                "info"
              );
              this.log(`🌐 RPC: ${ROME_CONFIG.rpcUrls[0]}`, "info");
              this.log(
                `🔍 Explorer: ${ROME_CONFIG.blockExplorerUrls[0]}`,
                "info"
              );
              this.log("", "info");
              this.log(
                "💡 You can now mint NFTs, create tokens, and interact with Rome Network!",
                "success"
              );
            } else {
              this.log("❌ Failed to switch to Rome Network", "error");
              this.log(
                "💡 Please try again or manually add the network",
                "info"
              );
            }
          } catch (error) {
            this.log(
              `❌ Error connecting to Rome Network: ${error.message}`,
              "error"
            );
            console.error("Rome Network connection error:", error);

            if (error.code === 4001) {
              this.log("💡 Connection rejected by user", "info");
            } else if (error.code === -32602) {
              this.log("💡 Invalid network parameters", "info");
            }
          }
        }

        async checkRomeBalance() {
          if (!window.ethereum || !window.ethereum.selectedAddress) {
            this.log(
              "❌ Please connect your wallet first using: rome connect",
              "error"
            );
            return;
          }

          try {
            this.log("💰 Checking Rome Network balance...", "info");

            // Play balance/wealth sound effect
            if (
              window.OmegaSoundEffects &&
              window.OmegaSoundEffects.isSoundEnabled()
            ) {
              window.OmegaSoundEffects.playBalanceWealthSound();
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "❌ Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Get balance
            const address = window.ethereum.selectedAddress;
            const balance = await window.ethereum.request({
              method: "eth_getBalance",
              params: [address, "latest"],
            });

            // Convert from wei to RSOL
            const balanceInWei = parseInt(balance, 16);
            const balanceInRSOL = balanceInWei / Math.pow(10, 18);

            this.log("🏛️ Rome Network Balance", "success");
            this.log("═══════════════════════", "info");
            this.log(`👤 Address: ${address}`, "info");
            this.log(
              `💰 RSOL Balance: ${balanceInRSOL.toFixed(6)} RSOL`,
              "success"
            );
            this.log(`🔗 Network: Rome Devnet Esquiline`, "info");
            this.log(
              `🔍 View on Explorer: https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${address}`,
              "output"
            );
          } catch (error) {
            this.log(`❌ Error checking balance: ${error.message}`, "error");
            console.error("Rome balance check error:", error);
          }
        }

        async createRomeTokenViaFactory(name, symbol, supply, decimals) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "❌ Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "❌ Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Rome Token Factory Contract Address (Deployed on Rome Devnet Esquiline)
            const FACTORY_ADDRESS =
              "0x3df3bcce71bf0acc266ea22e8017b50d40d7cfa4";
            const FACTORY_ABI = [
              {
                inputs: [],
                stateMutability: "nonpayable",
                type: "constructor",
              },
              {
                anonymous: false,
                inputs: [
                  {
                    indexed: true,
                    internalType: "address",
                    name: "tokenAddress",
                    type: "address",
                  },
                  {
                    indexed: true,
                    internalType: "address",
                    name: "creator",
                    type: "address",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "name",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "symbol",
                    type: "string",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "totalSupply",
                    type: "uint256",
                  },
                  {
                    indexed: false,
                    internalType: "uint256",
                    name: "timestamp",
                    type: "uint256",
                  },
                  {
                    indexed: false,
                    internalType: "string",
                    name: "network",
                    type: "string",
                  },
                ],
                name: "TokenCreated",
                type: "event",
              },
              {
                inputs: [
                  { internalType: "string", name: "name", type: "string" },
                  { internalType: "string", name: "symbol", type: "string" },
                  {
                    internalType: "uint256",
                    name: "totalSupply",
                    type: "uint256",
                  },
                  { internalType: "uint8", name: "decimals", type: "uint8" },
                ],
                name: "createToken",
                outputs: [
                  {
                    internalType: "address",
                    name: "tokenAddress",
                    type: "address",
                  },
                ],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [],
                name: "creationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalTokens",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "creator", type: "address" },
                ],
                name: "getTokensByCreator",
                outputs: [
                  { internalType: "address[]", name: "", type: "address[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("🔗 Connecting to Rome Token Factory...", "info");

            // Create contract instance using ethers.js
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const factory = new ethers.Contract(
              FACTORY_ADDRESS,
              FACTORY_ABI,
              signer
            );

            // Get creation fee
            const creationFee = await factory.creationFee();
            this.log(
              `💸 Creation fee: ${ethers.utils.formatEther(creationFee)} RSOL`,
              "info"
            );

            this.log("⚡ Sending create token transaction...", "info");

            // Convert supply to proper format with decimals
            // Example: 1000 tokens with 18 decimals = 1000 * 10^18
            const supplyWithDecimals = ethers.BigNumber.from(supply).mul(
              ethers.BigNumber.from(10).pow(decimals)
            );

            this.log(
              `📊 Adjusted Supply: ${supply} tokens (${supplyWithDecimals.toString()} base units)`,
              "info"
            );

            // Call createToken function with fee
            const tx = await factory.createToken(
              name,
              symbol,
              supplyWithDecimals,
              decimals,
              {
                value: creationFee,
              }
            );

            this.log(`🔗 Transaction Hash: ${tx.hash}`, "info");
            this.log("⏳ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            // Get the token address from the TokenCreated event
            let tokenAddress = null;
            if (receipt.logs && receipt.logs.length > 0) {
              for (let log of receipt.logs) {
                try {
                  const parsedLog = factory.interface.parseLog(log);
                  if (parsedLog && parsedLog.name === "TokenCreated") {
                    tokenAddress = parsedLog.args.tokenAddress;
                    break;
                  }
                } catch (e) {
                  // Continue to next log
                }
              }
            }

            this.log("✅ Token created successfully!", "success");
            this.log("", "info");
            this.log("📋 TOKEN DETAILS:", "info");
            this.log(`🏛️ Network: Rome Devnet Esquiline`, "info");
            this.log(`📝 Name: ${name}`, "info");
            this.log(`🏷️ Symbol: ${symbol}`, "info");
            this.log(`💰 Total Supply: ${supply.toLocaleString()}`, "info");
            this.log(`🔢 Decimals: ${decimals}`, "info");
            this.log(`🔗 Token Contract: ${tokenAddress || "Unknown"}`, "info");
            this.log(`📊 Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");

            if (tokenAddress) {
              this.log("🌐 VIEW ON EXPLORER:", "info");
              this.logHtml(
                `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${tokenAddress}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${tokenAddress}</a>`,
                "output"
              );
            }
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("❌ Insufficient funds for token creation fee", "error");
              this.log("💡 You need RSOL to pay the creation fee", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("❌ Transaction rejected by user", "error");
            } else {
              this.log(`❌ Error creating token: ${error.message}`, "error");
              console.error("Rome token creation error:", error);
            }
          }
        }

        async registerRomeUsername(username) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "❌ Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "❌ Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate username locally first
            if (username.length === 0 || username.length > 32) {
              this.log(
                "❌ Username must be between 1 and 32 characters",
                "error"
              );
              return;
            }

            const validUsernameRegex = /^[a-zA-Z0-9_-]+$/;
            if (!validUsernameRegex.test(username)) {
              this.log(
                "❌ Username can only contain letters, numbers, hyphens, and underscores",
                "error"
              );
              return;
            }

            // Rome Username Registry Contract Address (Deployed on Rome Devnet Esquiline)
            const REGISTRY_ADDRESS =
              "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
            const REGISTRY_ABI = [
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "registerUsername",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "renewUsername",
                outputs: [],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                  { internalType: "address", name: "to", type: "address" },
                ],
                name: "transferUsername",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                inputs: [],
                name: "registrationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "isUsernameAvailable",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "getUsernameInfo",
                outputs: [
                  {
                    internalType: "address",
                    name: "usernameOwner",
                    type: "address",
                  },
                  {
                    internalType: "uint256",
                    name: "registrationTime",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "expirationTime",
                    type: "uint256",
                  },
                  { internalType: "bool", name: "isActive", type: "bool" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "resolveUsername",
                outputs: [
                  { internalType: "address", name: "", type: "address" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "addr", type: "address" },
                ],
                name: "getUsernamesByAddress",
                outputs: [
                  { internalType: "string[]", name: "", type: "string[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalRegistrations",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("🔗 Connecting to Rome Username Registry...", "info");

            // Create contract instance
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const registry = new ethers.Contract(
              REGISTRY_ADDRESS,
              REGISTRY_ABI,
              signer
            );

            // Check if username is available
            this.log(`🔍 Checking if ${username}.rome is available...`, "info");
            const isAvailable = await registry.isUsernameAvailable(username);

            if (!isAvailable) {
              this.log(
                `❌ Username ${username}.rome is already taken`,
                "error"
              );
              this.log("💡 Try a different username", "info");
              return;
            }

            // Get registration fee
            const registrationFee = await registry.registrationFee();
            this.log(
              `💸 Registration fee: ${ethers.utils.formatEther(
                registrationFee
              )} RSOL (1 year)`,
              "info"
            );

            this.log("⚡ Sending registration transaction...", "info");

            // Register username
            const tx = await registry.registerUsername(username, {
              value: registrationFee,
            });

            this.log(`🔗 Transaction Hash: ${tx.hash}`, "info");
            this.log("⏳ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            const userAddress = await signer.getAddress();
            const expirationDate = new Date(
              Date.now() + 365 * 24 * 60 * 60 * 1000
            ); // 1 year from now

            this.log("✅ Username registered successfully!", "success");
            this.log("", "info");
            this.log("📋 USERNAME DETAILS:", "info");
            this.log(`🏛️ Network: Rome Devnet Esquiline`, "info");
            this.log(`📝 Username: ${username}.rome`, "success");
            this.log(`👤 Owner: ${userAddress}`, "info");
            this.log(
              `📅 Registered: ${new Date().toLocaleDateString()}`,
              "info"
            );
            this.log(
              `⏰ Expires: ${expirationDate.toLocaleDateString()}`,
              "info"
            );
            this.log(`📊 Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");
            this.log("🌐 VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}</a>`,
              "output"
            );
            this.log("", "info");
            this.log("💡 Your username will be valid for 1 year", "info");
            this.log(
              '💡 Use "rome ens renew <username>" to extend registration',
              "info"
            );
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("❌ Insufficient funds for registration fee", "error");
              this.log("💡 You need RSOL to pay the registration fee", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("❌ Transaction rejected by user", "error");
            } else {
              this.log(
                `❌ Error registering username: ${error.message}`,
                "error"
              );
              console.error("Rome username registration error:", error);
            }
          }
        }

        async resolveRomeUsername(username) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "❌ Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "❌ Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate username locally first
            if (username.length === 0 || username.length > 32) {
              this.log(
                "❌ Username must be between 1 and 32 characters",
                "error"
              );
              return;
            }

            const validUsernameRegex = /^[a-zA-Z0-9_-]+$/;
            if (!validUsernameRegex.test(username)) {
              this.log(
                "❌ Username can only contain letters, numbers, hyphens, and underscores",
                "error"
              );
              return;
            }

            // Rome Username Registry Contract Address (Deployed on Rome Devnet Esquiline)
            const REGISTRY_ADDRESS =
              "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
            const REGISTRY_ABI = [
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "registerUsername",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "renewUsername",
                outputs: [],
                stateMutability: "payable",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                  { internalType: "address", name: "to", type: "address" },
                ],
                name: "transferUsername",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function",
              },
              {
                inputs: [],
                name: "registrationFee",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "isUsernameAvailable",
                outputs: [{ internalType: "bool", name: "", type: "bool" }],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "getUsernameInfo",
                outputs: [
                  {
                    internalType: "address",
                    name: "usernameOwner",
                    type: "address",
                  },
                  {
                    internalType: "uint256",
                    name: "registrationTime",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "expirationTime",
                    type: "uint256",
                  },
                  { internalType: "bool", name: "isActive", type: "bool" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "string", name: "username", type: "string" },
                ],
                name: "resolveUsername",
                outputs: [
                  { internalType: "address", name: "", type: "address" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [
                  { internalType: "address", name: "addr", type: "address" },
                ],
                name: "getUsernamesByAddress",
                outputs: [
                  { internalType: "string[]", name: "", type: "string[]" },
                ],
                stateMutability: "view",
                type: "function",
              },
              {
                inputs: [],
                name: "getTotalRegistrations",
                outputs: [
                  { internalType: "uint256", name: "", type: "uint256" },
                ],
                stateMutability: "view",
                type: "function",
              },
            ];

            this.log("🔍 Resolving Rome username...", "info");

            // Connect to the registry contract
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const registry = new ethers.Contract(
              REGISTRY_ADDRESS,
              REGISTRY_ABI,
              provider
            );

            // Check if username is available (if available, it means no one owns it)
            const isAvailable = await registry.isUsernameAvailable(username);

            if (isAvailable) {
              this.log(
                `❌ Username "${username}.rome" is not registered`,
                "error"
              );
              this.log(
                "💡 This username is available for registration",
                "info"
              );
              this.log(
                '💡 Use "rome ens register <username>" to claim it',
                "info"
              );
              return;
            }

            // Get detailed username info
            const usernameInfo = await registry.getUsernameInfo(username);
            const owner = usernameInfo.usernameOwner;
            const registrationTime = usernameInfo.registrationTime;
            const expirationTime = usernameInfo.expirationTime;
            const isActive = usernameInfo.isActive;

            // Convert timestamps to readable dates
            const registrationDate = new Date(
              registrationTime.toNumber() * 1000
            );
            const expirationDate = new Date(expirationTime.toNumber() * 1000);
            const now = new Date();

            // Check if username is expired
            const isExpired = now > expirationDate;

            this.log("✅ Username found!", "success");
            this.log("", "info");
            this.log("📋 USERNAME DETAILS:", "info");
            this.log(`🏛️ Network: Rome Devnet Esquiline`, "info");
            this.log(`📝 Username: ${username}.rome`, "success");
            this.log(`👤 Owner: ${owner}`, "info");
            this.log(
              `📅 Registered: ${registrationDate.toLocaleDateString()}`,
              "info"
            );
            this.log(
              `⏰ Expires: ${expirationDate.toLocaleDateString()}`,
              "info"
            );

            if (isExpired) {
              this.log(
                `⚠️ Status: EXPIRED (expired ${Math.floor(
                  (now - expirationDate) / (1000 * 60 * 60 * 24)
                )} days ago)`,
                "error"
              );
              this.log(
                "💡 This username may become available for registration soon",
                "info"
              );
            } else {
              const daysLeft = Math.floor(
                (expirationDate - now) / (1000 * 60 * 60 * 24)
              );
              this.log(
                `✅ Status: ACTIVE (${daysLeft} days remaining)`,
                "success"
              );
            }

            this.log("", "info");
            this.log("🌐 VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/address/${REGISTRY_ADDRESS}</a>`,
              "output"
            );
          } catch (error) {
            this.log(`❌ Error resolving username: ${error.message}`, "error");
            console.error("Rome username resolution error:", error);
          }
        }

        async sendRomeTokens(amount, token, recipient) {
          try {
            if (!window.ethereum || !window.ethereum.selectedAddress) {
              this.log(
                "❌ Please connect your wallet first using: rome connect",
                "error"
              );
              return;
            }

            // Check if we're on Rome Network
            const chainId = await window.ethereum.request({
              method: "eth_chainId",
            });

            if (chainId !== "0x1d97c") {
              this.log(
                "❌ Please connect to Rome Network first using: rome connect",
                "error"
              );
              return;
            }

            // Validate amount
            const amountNum = parseFloat(amount);
            if (isNaN(amountNum) || amountNum <= 0) {
              this.log(
                "❌ Invalid amount. Please provide a positive number",
                "error"
              );
              return;
            }

            // Resolve recipient address (ENS or direct address)
            let recipientAddress;

            if (recipient.endsWith(".rome")) {
              // Resolve ENS name
              this.log(`🔍 Resolving ENS name: ${recipient}`, "info");

              const username = recipient.replace(".rome", "");
              const REGISTRY_ADDRESS =
                "0xc1a9037ccc121380e9c0655e3a207cf5a91b0ea4";
              const REGISTRY_ABI = [
                {
                  inputs: [
                    {
                      internalType: "string",
                      name: "username",
                      type: "string",
                    },
                  ],
                  name: "resolveUsername",
                  outputs: [
                    { internalType: "address", name: "", type: "address" },
                  ],
                  stateMutability: "view",
                  type: "function",
                },
              ];

              const provider = new ethers.providers.Web3Provider(
                window.ethereum
              );
              const registry = new ethers.Contract(
                REGISTRY_ADDRESS,
                REGISTRY_ABI,
                provider
              );

              recipientAddress = await registry.resolveUsername(username);

              if (
                recipientAddress ===
                "0x0000000000000000000000000000000000000000"
              ) {
                this.log(
                  `❌ ENS name "${recipient}" not found or expired`,
                  "error"
                );
                this.log(
                  '💡 Use "rome ens resolve <username>" to check availability',
                  "info"
                );
                return;
              }

              this.log(
                `✅ Resolved ${recipient} to: ${recipientAddress}`,
                "success"
              );
            } else {
              // Direct address
              if (!ethers.utils.isAddress(recipient)) {
                this.log("❌ Invalid recipient address or ENS name", "error");
                this.log(
                  "💡 Use a valid Ethereum address or ENS name ending in .rome",
                  "info"
                );
                return;
              }
              recipientAddress = recipient;
            }

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const userAddress = await signer.getAddress();

            // Handle different token types
            if (token.toLowerCase() === "rsol") {
              // Send native rSOL
              this.log(
                `💸 Sending ${amount} rSOL to ${recipientAddress}`,
                "info"
              );

              const tx = await signer.sendTransaction({
                to: recipientAddress,
                value: ethers.utils.parseEther(amount.toString()),
              });

              this.log(`⏳ Transaction submitted: ${tx.hash}`, "info");
              this.log("⏳ Waiting for confirmation...", "info");

              const receipt = await tx.wait();

              this.log("✅ Transaction confirmed!", "success");
              this.log("", "info");
              this.log("📋 TRANSACTION DETAILS:", "info");
              this.log(`🏛️ Network: Rome Devnet Esquiline`, "info");
              this.log(`💰 Amount: ${amount} rSOL`, "success");
              this.log(`👤 From: ${userAddress}`, "info");
              this.log(`👤 To: ${recipientAddress}`, "info");
              this.log(`📊 Gas Used: ${receipt.gasUsed.toString()}`, "info");
              this.log(
                `⛽ Gas Price: ${ethers.utils.formatUnits(
                  receipt.effectiveGasPrice,
                  "gwei"
                )} gwei`,
                "info"
              );
            } else {
              // Send ERC-20 token
              this.log(
                `💸 Sending ${amount} ${token} to ${recipientAddress}`,
                "info"
              );
              this.log(
                "⚠️ Note: ERC-20 token sending requires token contract address",
                "warning"
              );
              this.log(
                "💡 For now, this is a placeholder - full ERC-20 support coming soon",
                "info"
              );

              // TODO: Implement ERC-20 token sending
              // This would require:
              // 1. Token contract address lookup
              // 2. ERC-20 ABI
              // 3. transfer() function call
              // 4. Approval handling if needed

              this.log(
                "🚧 ERC-20 token sending not yet implemented",
                "warning"
              );
              this.log(
                "💡 Currently only rSOL (native token) sending is supported",
                "info"
              );
              return;
            }

            this.log("", "info");
            this.log("🌐 VIEW ON EXPLORER:", "info");
            this.logHtml(
              `<a href="https://romescout-esquiline-i.devnet.romeprotocol.xyz/tx/${receipt.transactionHash}" target="_blank" style="color: #007AFF; text-decoration: underline;">https://romescout-esquiline-i.devnet.romeprotocol.xyz/tx/${receipt.transactionHash}</a>`,
              "output"
            );
          } catch (error) {
            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("❌ Insufficient funds for transaction", "error");
              this.log(
                "💡 Check your rSOL balance using: rome balance",
                "info"
              );
            } else if (error.code === "USER_REJECTED") {
              this.log("❌ Transaction rejected by user", "error");
            } else {
              this.log(`❌ Error sending tokens: ${error.message}`, "error");
              console.error("Rome token send error:", error);
            }
          }
        }

        openRomeNFTMintUI() {
          const existing = document.getElementById("rome-nft-mint");
          if (existing) existing.remove();

          const html = `
                    <div id="rome-nft-mint" style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90vw;
                        max-width: 500px;
                        background: linear-gradient(135deg, rgba(18, 18, 18, 0.98), rgba(28, 28, 30, 0.95));
                        backdrop-filter: blur(40px);
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 20px;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                        z-index: 20000;
                        color: white;
                        font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
                        padding: 30px;
                        max-height: 90vh;
                        overflow-y: auto;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                            <div style="font-size: 1.6em; font-weight: 800;">🏛️ Mint Rome NFT</div>
                            <button onclick="closeRomeNFTMintUI()" style="
                                background: rgba(255, 59, 48, 0.2);
                                color: #FF3B30;
                                border: none;
                                padding: 8px 12px;
                                border-radius: 8px;
                                cursor: pointer;
                                font-size: 1.2em;
                            ">✕</button>
                        </div>
                        
                        <div id="rome-upload-zone" style="
                            border: 2px dashed rgba(255, 255, 255, 0.3);
                            border-radius: 16px;
                            padding: 40px;
                            text-align: center;
                            margin-bottom: 20px;
                            background: rgba(0, 0, 0, 0.2);
                            cursor: pointer;
                        " onclick="document.getElementById('rome-file-input').click()">
                            <div style="font-size: 3em; margin-bottom: 12px;">🖼️</div>
                            <div style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px;">Upload Image</div>
                            <div style="font-size: 0.9em; opacity: 0.7;">Click to browse or paste (Ctrl+V)</div>
                        </div>
                        
                        <input type="file" id="rome-file-input" accept="image/*" style="display: none;" onchange="handleRomeFileUpload(event)">
                        
                        <div id="rome-image-preview" style="display: none; margin-bottom: 20px; text-align: center;">
                            <img id="rome-preview-img" style="max-width: 100%; max-height: 200px; border-radius: 12px; display: block; margin: 0 auto;">
                            <button onclick="clearRomeImage()" style="
                                background: rgba(255, 59, 48, 0.2);
                                color: #FF3B30;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 8px;
                                cursor: pointer;
                                margin-top: 10px;
                                font-size: 0.9em;
                            ">Remove Image</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">NFT Name</label>
                            <input type="text" id="rome-nft-name" placeholder="Enter NFT name" style="
                                width: 100%;
                                padding: 12px;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                background: rgba(0, 0, 0, 0.3);
                                color: white;
                                font-size: 1em;
                            ">
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Description <span style="color: #888; font-weight: 400;">(Optional)</span></label>
                            <textarea id="rome-nft-description" placeholder="Describe your NFT (optional)" style="
                                width: 100%;
                                padding: 12px;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                background: rgba(0, 0, 0, 0.3);
                                color: white;
                                font-size: 1em;
                                min-height: 80px;
                                resize: vertical;
                            "></textarea>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label style="font-weight: 600;">Traits / Attributes</label>
                                <button onclick="toggleRomeTraits()" style="
                                    background: rgba(0, 122, 255, 0.2);
                                    color: #007AFF;
                                    border: none;
                                    padding: 6px 12px;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-size: 0.8em;
                                " id="rome-traits-toggle">Add Traits</button>
                            </div>
                            <div id="rome-traits-container" style="display: none;">
                                <div id="rome-traits-list"></div>
                                <button onclick="addRomeTrait()" style="
                                    background: rgba(52, 199, 89, 0.2);
                                    color: #34C759;
                                    border: none;
                                    padding: 8px 16px;
                                    border-radius: 8px;
                                    cursor: pointer;
                                    font-size: 0.9em;
                                    margin-top: 10px;
                                ">+ Add Trait</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Network Info</label>
                            <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; font-size: 0.9em;">
                                <div>🏛️ Network: Rome Devnet Esquiline</div>
                                <div>🔗 Contract: 0xc88a32d1977c11b7874400052d3750856c90120f</div>
                                <div>💰 Currency: RSOL</div>
                            </div>
                        </div>
                        
                        <button onclick="mintRomeNFTOnChain()" style="
                            width: 100%;
                            padding: 16px;
                            background: linear-gradient(135deg, #007AFF, #0051D5);
                            color: white;
                            border: none;
                            border-radius: 12px;
                            font-size: 1.1em;
                            font-weight: 600;
                            cursor: pointer;
                            margin-bottom: 10px;
                        ">🏛️ Mint on Rome Network</button>
                        
                        <div style="text-align: center; font-size: 0.8em; opacity: 0.7;">
                            Powered by Rome Network Layer 2
                        </div>
                    </div>
                `;

          document.body.insertAdjacentHTML("beforeend", html);

          // Add paste functionality
          window.handleRomePaste = this.handleRomePaste.bind(this);

          // Add global functions
          window.closeRomeNFTMintUI = this.closeRomeNFTMintUI.bind(this);
          window.handleRomeFileUpload = this.handleRomeFileUpload.bind(this);
          window.clearRomeImage = this.clearRomeImage.bind(this);
          window.mintRomeNFTOnChain = this.mintRomeNFTOnChain.bind(this);
          window.toggleRomeTraits = this.toggleRomeTraits.bind(this);
          window.addRomeTrait = this.addRomeTrait.bind(this);
          window.removeRomeTrait = this.removeRomeTrait.bind(this);
        }

        closeRomeNFTMintUI() {
          const modal = document.getElementById("rome-nft-mint");
          if (modal) modal.remove();
          document.removeEventListener("paste", window.handleRomePaste);
        }

        handleRomePaste(event) {
          const modal = document.getElementById("rome-nft-mint");
          if (!modal) return;

          const items = event.clipboardData?.items;
          if (!items) return;

          for (let item of items) {
            if (item.type.startsWith("image/")) {
              const file = item.getAsFile();
              if (file) {
                this.showRomeImage(file);
                break;
              }
            }
          }
        }

        handleRomeFileUpload(event) {
          const file = event.target.files[0];
          if (file) {
            this.showRomeImage(file);
          }
        }

        showRomeImage(file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const preview = document.getElementById("rome-image-preview");
            const img = document.getElementById("rome-preview-img");
            const uploadZone = document.getElementById("rome-upload-zone");

            img.src = e.target.result;
            preview.style.display = "block";
            uploadZone.style.display = "none";

            // Store file for later use
            window.romeSelectedFile = file;
          };
          reader.readAsDataURL(file);
        }

        clearRomeImage() {
          const preview = document.getElementById("rome-image-preview");
          const uploadZone = document.getElementById("rome-upload-zone");

          preview.style.display = "none";
          uploadZone.style.display = "block";

          window.romeSelectedFile = null;
          document.getElementById("rome-file-input").value = "";
        }

        toggleRomeTraits() {
          const container = document.getElementById("rome-traits-container");
          const toggle = document.getElementById("rome-traits-toggle");

          if (container.style.display === "none") {
            container.style.display = "block";
            toggle.textContent = "Hide Traits";
          } else {
            container.style.display = "none";
            toggle.textContent = "Add Traits";
          }
        }

        addRomeTrait() {
          const traitsList = document.getElementById("rome-traits-list");
          const traitId = Date.now();

          const traitHtml = `
                    <div id="rome-trait-${traitId}" style="
                        display: flex;
                        gap: 10px;
                        margin-bottom: 10px;
                        align-items: center;
                    ">
                        <input type="text" placeholder="Trait Type" style="
                            flex: 1;
                            padding: 8px;
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            background: rgba(0, 0, 0, 0.3);
                            color: white;
                            font-size: 0.9em;
                        ">
                        <input type="text" placeholder="Value" style="
                            flex: 1;
                            padding: 8px;
                            border: 1px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            background: rgba(0, 0, 0, 0.3);
                            color: white;
                            font-size: 0.9em;
                        ">
                        <button onclick="removeRomeTrait(${traitId})" style="
                            background: rgba(255, 59, 48, 0.2);
                            color: #FF3B30;
                            border: none;
                            padding: 8px 12px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 0.9em;
                        ">✕</button>
                    </div>
                `;

          traitsList.insertAdjacentHTML("beforeend", traitHtml);
        }

        removeRomeTrait(traitId) {
          const traitElement = document.getElementById(`rome-trait-${traitId}`);
          if (traitElement) {
            traitElement.remove();
          }
        }

        getRomeTraits() {
          const traits = [];
          const traitElements = document.querySelectorAll(
            '[id^="rome-trait-"]'
          );

          traitElements.forEach((element) => {
            const inputs = element.querySelectorAll("input");
            const traitType = inputs[0]?.value?.trim();
            const traitValue = inputs[1]?.value?.trim();

            if (traitType && traitValue) {
              traits.push({
                trait_type: traitType,
                value: traitValue,
              });
            }
          });

          return traits;
        }

        async mintRomeNFTOnChain() {
          const name = document.getElementById("rome-nft-name").value.trim();
          const description = document
            .getElementById("rome-nft-description")
            .value.trim();
          const file = window.romeSelectedFile;
          const traits = this.getRomeTraits();

          if (!file) {
            this.log("❌ Please upload an image first", "error");
            return;
          }

          if (!name) {
            this.log("❌ Please enter an NFT name", "error");
            return;
          }

          if (!window.ethereum || !window.ethereum.selectedAddress) {
            this.log("❌ Please connect your wallet first", "error");
            return;
          }

          try {
            this.log("🏛️ Starting Rome NFT minting process...", "info");

            // Step 1: Upload image to Pinata
            this.log("📤 Uploading image to IPFS...", "info");
            const imageUrl = await this.uploadRomeImageToPinata(file);

            // Step 2: Create metadata JSON
            const metadata = {
              name: name,
              description: description || `Rome NFT: ${name}`,
              image: imageUrl,
              external_url: "https://rome.network",
              attributes: traits,
            };

            if (traits.length > 0) {
              this.log(
                `📊 Adding ${traits.length} trait(s) to metadata...`,
                "info"
              );
            }

            this.log("📝 Creating metadata...", "info");
            const metadataUrl = await this.uploadRomeMetadataToPinata(metadata);

            // Step 3: Mint NFT on Rome Network
            this.log("⚡ Minting NFT on Rome Network...", "info");
            await this.mintRomeNFT(metadataUrl);

            // Close UI on success
            this.closeRomeNFTMintUI();
          } catch (error) {
            this.log(`❌ Error: ${error.message}`, "error");
            console.error("Rome NFT minting error:", error);
          }
        }

        async uploadRomeImageToPinata(file) {
          const formData = new FormData();
          formData.append("file", file);

          const response = await fetch(
            "https://api.pinata.cloud/pinning/pinFileToIPFS",
            {
              method: "POST",
              headers: {
                pinata_api_key: "c717314daa6072cf4111",
                pinata_secret_api_key:
                  "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
              },
              body: formData,
            }
          );

          if (!response.ok) {
            throw new Error("Failed to upload image to IPFS");
          }

          const result = await response.json();
          return `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`;
        }

        async uploadRomeMetadataToPinata(metadata) {
          const response = await fetch(
            "https://api.pinata.cloud/pinning/pinJSONToIPFS",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                pinata_api_key: "c717314daa6072cf4111",
                pinata_secret_api_key:
                  "2d78c057627d207a25d57f0b625d3c8f6388e911101788cbe5b0b3d2cf763f59",
              },
              body: JSON.stringify({
                pinataContent: metadata,
                pinataMetadata: {
                  name: "rome-nft-metadata.json",
                },
              }),
            }
          );

          if (!response.ok) {
            throw new Error("Failed to upload metadata to IPFS");
          }

          const result = await response.json();
          return `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`;
        }

        async mintRomeNFT(tokenURI) {
          try {
            // Rome Network configuration
            const ROME_CONFIG = {
              chainId: "0x1d97c", // 121212 in hex
              chainName: "Rome Devnet Esquiline",
              nativeCurrency: {
                name: "RSOL",
                symbol: "RSOL",
                decimals: 18,
              },
              rpcUrls: ["https://esquiline-i.devnet.romeprotocol.xyz"],
              blockExplorerUrls: [
                "https://romescout-esquiline-i.devnet.romeprotocol.xyz",
              ],
            };

            // Check if Rome network is added
            try {
              await window.ethereum.request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: ROME_CONFIG.chainId }],
              });
            } catch (switchError) {
              if (switchError.code === 4902) {
                // Network not added, add it
                await window.ethereum.request({
                  method: "wallet_addEthereumChain",
                  params: [ROME_CONFIG],
                });
              } else {
                throw switchError;
              }
            }

            this.log("✅ Connected to Rome Devnet Esquiline", "success");

            // Contract ABI for the mint function
            const contractABI = [
              {
                inputs: [
                  {
                    internalType: "address",
                    name: "to",
                    type: "address",
                  },
                  {
                    internalType: "string",
                    name: "tokenURI",
                    type: "string",
                  },
                ],
                name: "mint",
                outputs: [
                  {
                    internalType: "uint256",
                    name: "",
                    type: "uint256",
                  },
                ],
                stateMutability: "nonpayable",
                type: "function",
              },
            ];

            const contractAddress =
              "0xc88a32d1977c11b7874400052d3750856c90120f";

            // Get provider and signer
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            const userAddress = await signer.getAddress();

            this.log(`👤 Minting to address: ${userAddress}`, "info");

            // Create contract instance
            const contract = new ethers.Contract(
              contractAddress,
              contractABI,
              signer
            );

            this.log("⚡ Sending mint transaction...", "info");

            // Call mint function
            const tx = await contract.mint(userAddress, tokenURI);

            this.log(`🔗 Transaction Hash: ${tx.hash}`, "info");
            this.log("⏳ Waiting for confirmation...", "info");

            // Wait for transaction confirmation
            const receipt = await tx.wait();

            // Get the token ID from the Transfer event
            let tokenId = "Unknown";

            // Try to get token ID from Transfer event first
            if (receipt.events && receipt.events.length > 0) {
              const transferEvent = receipt.events.find(
                (e) => e.event === "Transfer"
              );
              if (
                transferEvent &&
                transferEvent.args &&
                transferEvent.args.tokenId
              ) {
                tokenId = transferEvent.args.tokenId.toString();
              }
            }

            // If still unknown, try to parse from logs
            if (
              tokenId === "Unknown" &&
              receipt.logs &&
              receipt.logs.length > 0
            ) {
              try {
                for (let log of receipt.logs) {
                  if (
                    log.topics[0] ===
                    "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
                  ) {
                    // Transfer event signature
                    tokenId = parseInt(log.topics[3], 16).toString();
                    break;
                  }
                }
              } catch (e) {
                console.log("Could not extract token ID from logs:", e);
              }
            }

            this.log("✅ NFT minted successfully!", "success");
            this.log("", "info");
            this.log("📋 NFT DETAILS:", "info");
            this.log(`🏛️ Network: Rome Devnet Esquiline`, "info");
            this.log(`🔗 Contract: ${contractAddress}`, "info");
            this.log(`🆔 Token ID: #${tokenId}`, "info");
            this.log(`👤 Owner: ${userAddress}`, "info");
            this.log(`🔗 Token URI: ${tokenURI}`, "info");
            this.log(`📊 Gas Used: ${receipt.gasUsed.toString()}`, "info");
            this.log("", "info");
            this.log("🌐 VIEW ON EXPLORER:", "info");

            // Create clickable explorer URL (remove /instance/Unknown if token ID is unknown)
            let explorerUrl = `https://romescout-esquiline-i.devnet.romeprotocol.xyz/token/${contractAddress}`;
            if (tokenId !== "Unknown") {
              explorerUrl += `/instance/${tokenId}`;
            }

            // Create clickable link
            this.logHtml(
              `<a href="${explorerUrl}" target="_blank" style="color: #007AFF; text-decoration: underline;">${explorerUrl}</a>`,
              "output"
            );
          } catch (error) {
            this.log(`❌ Error minting NFT: ${error.message}`, "error");
            console.error("Rome NFT minting error:", error);

            if (error.code === "INSUFFICIENT_FUNDS") {
              this.log("💡 Insufficient RSOL for gas fees", "info");
              this.log("🏛️ Get RSOL from Rome faucet or bridge", "info");
            } else if (error.code === "USER_REJECTED") {
              this.log("💡 Transaction rejected by user", "info");
            } else if (error.message.includes("network")) {
              this.log("💡 Network connection issue", "info");
              this.log("🔗 Make sure you're connected to Rome Devnet", "info");
            }
          }
        }
      }

      // Add this helper function to fund the Omega wallet via relayer
      async function fundOmegaWallet(address) {
        try {
          const response = await fetch(`${RELAYER_URL}/fund`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ address, amount: "0.1" }),
          });
          const data = await response.json();
          if (data.success) {
            window.terminal.log(
              `✅ Your wallet is being funded! Tx: ${data.txHash}`,
              "success"
            );
            window.terminal.log(
              "Please wait a few seconds before using your wallet.",
              "info"
            );
          } else {
            window.terminal.log(
              "❌ Funding failed: " + (data.error || "Unknown error"),
              "error"
            );
          }
        } catch (err) {
          window.terminal.log(
            "❌ Funding request failed: " + err.message,
            "error"
          );
        }
      }

      // Nuclear option: Completely block Phantom and force MetaMask
      (function () {
        console.log(
          "🚨 PHANTOM BLOCKER: Starting aggressive Phantom blocking..."
        );

        // Store original providers before any manipulation
        const originalProviders = window.ethereum?.providers || [];
        console.log(
          "Original providers:",
          originalProviders.map((p) => ({
            isMetaMask: p.isMetaMask,
            isPhantom: p.isPhantom,
          }))
        );

        // Immediately block Phantom at the global level
        if (window.ethereum && window.ethereum.isPhantom) {
          console.log("🚨 PHANTOM DETECTED: Blocking immediately");
          const metamaskProvider = originalProviders.find((p) => p.isMetaMask);
          if (metamaskProvider) {
            window.ethereum = metamaskProvider;
            console.log("✅ MetaMask forced as primary provider");
          } else {
            window.ethereum = null;
            console.log("❌ No MetaMask available - blocking all wallets");
          }
        }

        if (
          window.ethereum &&
          window.ethereum.providers &&
          Array.isArray(window.ethereum.providers)
        ) {
          const metamaskProvider = window.ethereum.providers.find(
            (p) => p.isMetaMask
          );
          const phantomProvider = window.ethereum.providers.find(
            (p) => p.isPhantom
          );

          console.log("Found providers:", {
            metamask: !!metamaskProvider,
            phantom: !!phantomProvider,
          });

          if (metamaskProvider) {
            // Completely replace window.ethereum with MetaMask
            window.ethereum = metamaskProvider;
            console.log("✅ MetaMask provider selected and forced");

            // Completely disable Phantom
            if (phantomProvider) {
              phantomProvider.isPhantom = false;
              phantomProvider.request = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              phantomProvider.send = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              phantomProvider.on = () => {};
              phantomProvider.removeListener = () => {};
              phantomProvider.isConnected = () => false;
              phantomProvider.connect = () =>
                Promise.reject(new Error("Phantom disabled - use MetaMask"));
              console.log("🚫 Phantom provider completely disabled");
            }
          } else if (phantomProvider) {
            // Only Phantom available - block it completely
            console.warn("🚨 Only Phantom detected - blocking connection");
            window.ethereum = null;
            console.log("❌ Phantom blocked - no wallet available");
          }
        }

        // Nuclear safety check - if we detect Phantom at any point, block it
        const checkAndBlockPhantom = () => {
          if (window.ethereum && window.ethereum.isPhantom) {
            console.log("🚨 PHANTOM DETECTED in safety check - blocking");
            const metamaskProvider = originalProviders.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              window.ethereum = metamaskProvider;
              console.log("✅ MetaMask restored after Phantom detection");
            } else {
              window.ethereum = null;
              console.log("❌ No MetaMask available - blocking all wallets");
            }
          }
        };

        // Run safety check immediately and set up periodic checks
        checkAndBlockPhantom();
        setInterval(checkAndBlockPhantom, 500); // Check every 500ms for more aggressive blocking

        // Also block any attempts to restore Phantom
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function (obj, prop, descriptor) {
          if (
            obj === window &&
            prop === "ethereum" &&
            descriptor.value &&
            descriptor.value.isPhantom
          ) {
            console.log(
              "🚨 BLOCKED: Attempt to restore Phantom via Object.defineProperty"
            );
            const metamaskProvider = originalProviders.find(
              (p) => p.isMetaMask
            );
            if (metamaskProvider) {
              descriptor.value = metamaskProvider;
            } else {
              descriptor.value = null;
            }
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };

        console.log("🚨 PHANTOM BLOCKER: Setup complete");
      })();
    </script>
    <script>
      // Force cache busting by adding a version parameter
      const scriptVersion = Date.now();
      console.log("Terminal script version:", scriptVersion);

      // Clear any existing terminal instance
      if (window.terminal) {
        console.log("Clearing existing terminal instance");
        window.terminal = null;
      }

      // Polymarket API Integration (Simple!)
      console.log("🔧 DEBUG: Loading Polymarket functions...");

      // Add Polymarket methods directly to OmegaMinerTerminal prototype
      // This needs to happen BEFORE the terminal instance is created
      if (typeof OmegaMinerTerminal !== "undefined") {
        console.log(
          "🔧 DEBUG: OmegaMinerTerminal found, adding Polymarket functions..."
        );

        // Add Polymarket methods to the terminal prototype
        OmegaMinerTerminal.prototype.handlePolymarketCommand = async function (
          args
        ) {
          this.log(
            "🔧 DEBUG: handlePolymarketCommand called with args:",
            "info"
          );
          console.log("DEBUG: handlePolymarketCommand args:", args);

          if (!args || args.length < 2) {
            this.showPolymarketHelp();
            return;
          }

          const subcommand = args[1].toLowerCase();
          this.log(`🔧 DEBUG: Processing subcommand: ${subcommand}`, "info");

          switch (subcommand) {
            case "help":
              this.showPolymarketHelp();
              break;
            case "markets":
              await this.getPolymarketMarkets();
              break;
            case "active":
              await this.getPolymarketActiveMarkets();
              break;
            case "trending":
              await this.getPolymarketTrendingMarkets();
              break;
            case "search":
              if (args.length < 3) {
                this.log("❌ Usage: polymarket search <query>", "error");
                return;
              }
              const query = args.slice(2).join(" ");
              await this.searchPolymarketMarkets(query);
              break;
            case "events":
              await this.getPolymarketEvents();
              break;
            case "recent":
              await this.getPolymarketRecentEvents();
              break;
            case "breaking":
              await this.getPolymarketBreaking();
              break;
            case "new":
              await this.getPolymarketNew();
              break;
            case "politics":
              await this.getPolymarketPolitics();
              break;
            case "sports":
              await this.getPolymarketSports();
              break;
            case "crypto":
              await this.getPolymarketCrypto();
              break;
            case "earnings":
              await this.getPolymarketEarnings();
              break;
            case "geopolitics":
              await this.getPolymarketGeopolitics();
              break;
            case "tech":
              await this.getPolymarketTech();
              break;
            case "culture":
              await this.getPolymarketCulture();
              break;
            case "world":
              await this.getPolymarketWorld();
              break;
            case "economy":
              await this.getPolymarketEconomy();
              break;
            case "trump":
              await this.getPolymarketTrump();
              break;
            case "elections":
              await this.getPolymarketElections();
              break;
            default:
              this.log(`❌ Unknown Polymarket command: ${subcommand}`, "error");
              this.showPolymarketHelp();
          }
        };

        OmegaMinerTerminal.prototype.showPolymarketHelp = function () {
          this.log("🎯 POLYMARKET PREDICTION MARKETS", "info");
          this.log("════════════════════════════════════", "info");
          this.log("", "info");
          this.log("📋 MAIN COMMANDS:", "info");
          this.log("  polymarket help          Show this help", "output");
          this.log(
            "  polymarket markets       Get current active markets",
            "output"
          );
          this.log(
            "  polymarket trending      Get top volume markets",
            "output"
          );
          this.log(
            "  polymarket events        Get recent events (last 6 months)",
            "output"
          );
          this.log(
            "  polymarket recent        Get very recent events (last month)",
            "output"
          );
          this.log("  polymarket search <q>    Search markets", "output");
          this.log("", "info");
          this.log("🔥 CATEGORY COMMANDS:", "info");
          this.log(
            "  polymarket breaking      Breaking news markets",
            "output"
          );
          this.log("  polymarket new           Newest markets", "output");
          this.log("  polymarket politics      Political markets", "output");
          this.log("  polymarket sports        Sports markets", "output");
          this.log("  polymarket crypto        Crypto markets", "output");
          this.log("  polymarket earnings      Earnings markets", "output");
          this.log("  polymarket geopolitics   Geopolitical markets", "output");
          this.log("  polymarket tech          Technology markets", "output");
          this.log("  polymarket culture       Culture markets", "output");
          this.log("  polymarket world         World events", "output");
          this.log("  polymarket economy       Economic markets", "output");
          this.log(
            "  polymarket trump         Trump-related markets",
            "output"
          );
          this.log("  polymarket elections     Election markets", "output");
          this.log("", "info");
          this.log("🎯 EXAMPLES:", "info");
          this.log(
            "  polymarket markets       # Current active markets",
            "info"
          );
          this.log(
            "  polymarket trending      # Highest volume markets",
            "info"
          );
          this.log(
            "  polymarket politics      # Political predictions",
            "info"
          );
          this.log("  polymarket crypto        # Crypto predictions", "info");
          this.log(
            "  polymarket breaking      # Breaking news markets",
            "info"
          );
          this.log(
            '  polymarket search "AI"   # Search for AI markets',
            "info"
          );
          this.log("", "info");
        };

        OmegaMinerTerminal.prototype.setPolymarketApiKey = function (apiKey) {
          // Store in unified API key system
          let apiKeys = JSON.parse(
            localStorage.getItem("omega_terminal_api_keys") || "{}"
          );
          apiKeys.polymarket = apiKey;
          localStorage.setItem(
            "omega_terminal_api_keys",
            JSON.stringify(apiKeys)
          );

          this.log("✅ Polymarket API key saved successfully!", "success");
          this.log("💡 You can now use polymarket commands", "info");
        };

        OmegaMinerTerminal.prototype.makePolymarketRequest = async function (
          endpoint
        ) {
          this.log(
            `🔧 DEBUG: makePolymarketRequest called with endpoint: ${endpoint}`,
            "info"
          );
          try {
            // Use unified server proxy to avoid browser restrictions
            const proxyUrl = "https://terminal-v1-5-9.onrender.com";
            const url = `${proxyUrl}/polymarket${endpoint}`;
            this.log(`🔧 DEBUG: Making request to: ${url}`, "info");

            const response = await fetch(url, {
              method: "GET",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
            });

            this.log(`🔧 DEBUG: Response status: ${response.status}`, "info");

            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const data = await response.json();
            this.log(`🔧 DEBUG: Response data received:`, "info");
            console.log("DEBUG: Polymarket API response:", data);
            return data;
          } catch (error) {
            this.log(`❌ Polymarket API Error: ${error.message}`, "error");
            this.log(
              `💡 Make sure the Polymarket proxy is running: node polymarket-proxy.js`,
              "info"
            );
            return null;
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketMarkets = async function () {
          this.log("📊 Fetching comprehensive Polymarket markets...", "info");

          // Use the correct API approach per official docs - events endpoint for active markets
          const data = await this.makePolymarketRequest(
            `/events?order=id&ascending=false&closed=false&limit=100`
          );

          if (!data) return;

          // Handle both array format and {data: array} format
          const events = Array.isArray(data) ? data : data.data || [];

          if (events && events.length > 0) {
            // Convert events to markets and filter for active markets with volume
            const sortedMarkets = events
              .filter((event) => {
                // Only show events with markets and volume
                if (!event.markets || !event.markets.length) return false;

                // Get the primary market for volume calculation
                const primaryMarket = event.markets[0];
                if (
                  !primaryMarket ||
                  !primaryMarket.volume ||
                  primaryMarket.volume <= 0
                )
                  return false;

                return true;
              })
              .map((event) => {
                // Convert event to market format for display
                const primaryMarket = event.markets[0];
                return {
                  id: event.id,
                  question: event.title || "Untitled Event",
                  description: event.description || "",
                  volume: primaryMarket.volume || 0,
                  liquidity: primaryMarket.liquidity || 0,
                  active: true,
                  endDate: event.endDate || event.end_date,
                  startDate: event.startDate || event.start_date,
                  createdAt: event.createdAt || event.created_at,
                  slug: event.slug,
                  category: event.category || "",
                  featured: event.featured || false,
                  markets: event.markets || [],
                };
              })
              .sort((a, b) => {
                // Sort by volume first, then by creation date
                const volumeDiff = (b.volume || 0) - (a.volume || 0);
                if (Math.abs(volumeDiff) > 1000) {
                  // If volumes differ significantly
                  return volumeDiff;
                }
                // If volumes are similar, sort by creation date (newest first)
                const aDate = new Date(a.createdAt || a.startDate || 0);
                const bDate = new Date(b.createdAt || b.startDate || 0);
                return bDate - aDate;
              });

            // Create comprehensive UI for markets
            const marketsHtml = `
                    <div style="
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 16px 0;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 12px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 36px;
                                height: 36px;
                                background: linear-gradient(135deg, #06b6d4, #0891b2);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 12px;
                                font-size: 16px;
                            ">📊</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    color: #ffffff;
                                ">Current Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                ">${
                                  sortedMarkets.length
                                } active markets found • Future end dates only</p>
                            </div>
                        </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr)); gap: 16px;">
                                ${sortedMarkets
                                  .slice(0, 12)
                                  .map(
                                    (market, index) => `
                                    <div style="
                                        background: #1a1a1a;
                                        border: 1px solid #333;
                                        border-radius: 12px;
                                        padding: 16px;
                                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                        position: relative;
                                        cursor: pointer;
                                        height: 280px;
                                        display: flex;
                                        flex-direction: column;
                                        justify-content: space-between;
                                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                    " onmouseover="this.style.transform='translateY(-6px) scale(1.02)'; this.style.boxShadow='0 12px 32px rgba(6, 182, 212, 0.4)'; this.style.borderColor='#06b6d4';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.2)'; this.style.borderColor='#333';">
                                        <div style="
                                            position: absolute;
                                            top: 0;
                                            left: 0;
                                            right: 0;
                                            height: 3px;
                                            background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            border-radius: 12px 12px 0 0;
                                        "></div>
                                        
                                        <!-- Header with volume -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            margin-bottom: 12px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 6px 12px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              market.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              market.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 4px 8px;
                                                    border-radius: 12px;
                                                    font-size: 10px;
                                                    font-weight: 500;
                                                ">🟢 Active</div>
                                            `
                                                : ""
                                            }
                                        </div>

                                        <!-- Question/Title -->
                                        <h4 style="
                                            margin: 0 0 12px 0;
                                            font-size: 14px;
                                            font-weight: 600;
                                            line-height: 1.4;
                                            color: #ffffff;
                                            word-wrap: break-word;
                                            display: -webkit-box;
                                            -webkit-line-clamp: 3;
                                            -webkit-box-orient: vertical;
                                            overflow: hidden;
                                        ">${
                                          market.question || "Untitled Market"
                                        }</h4>

                                        <!-- Description (if short enough) -->
                                        ${
                                          market.description &&
                                          market.description.length < 100
                                            ? `
                                            <p style="
                                                margin: 0 0 12px 0;
                                                font-size: 12px;
                                                color: #bbb;
                                                line-height: 1.3;
                                                display: -webkit-box;
                                                -webkit-line-clamp: 2;
                                                -webkit-box-orient: vertical;
                                                overflow: hidden;
                                            ">${market.description}</p>
                                        `
                                            : ""
                                        }

                                        <!-- Trade button and category -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            margin-bottom: 8px;
                                        ">
                                            <a href="https://polymarket.com/market/${
                                              market.slug || market.id
                                            }" target="_blank" title="Trade this market on Polymarket" style="
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                text-decoration: none;
                                                display: inline-flex;
                                                align-items: center;
                                                gap: 6px;
                                                box-shadow: 0 3px 8px rgba(6, 182, 212, 0.3);
                                                transition: all 0.2s ease;
                                                flex: 1;
                                                justify-content: center;
                                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(6, 182, 212, 0.3)';">
                                                🔗 Trade
                                            </a>
                                        </div>

                                        <!-- Footer info -->
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            font-size: 10px;
                                            color: #888;
                                            margin-top: 8px;
                                            padding-top: 8px;
                                            border-top: 1px solid #333;
                                        ">
                                            <span>🆔 ${market.id}</span>
                                            ${
                                              market.endDate
                                                ? `<span>📅 ${new Date(
                                                    market.endDate
                                                  ).toLocaleDateString()}</span>`
                                                : ""
                                            }
                                        </div>
                                    </div>
                                `
                                  )
                                  .join("")}
                        </div>
                        ${
                          sortedMarkets.length > 10
                            ? `
                            <div style="
                                text-align: center;
                                margin-top: 20px;
                                padding-top: 16px;
                                border-top: 1px solid #333;
                            ">
                                <button onclick="this.parentElement.parentElement.querySelector('.show-more-markets').style.display='grid'; this.style.display='none';" style="
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    color: white;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 20px;
                                    font-size: 14px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                    🔽 Show More Markets (${
                                      sortedMarkets.length - 10
                                    } more)
                                </button>
                                <div class="show-more-markets" style="display: none; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; margin-top: 16px;">
                                    ${sortedMarkets
                                      .slice(10)
                                      .map(
                                        (market, index) => `
                                        <div style="
                                            background: #2a2a2a;
                                            border: 1px solid #444;
                                            border-radius: 8px;
                                            padding: 16px;
                                            transition: all 0.2s ease;
                                            position: relative;
                                        ">
                                            <div style="
                                                position: absolute;
                                                top: 0;
                                                left: 0;
                                                right: 0;
                                                height: 2px;
                                                background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            "></div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: flex-start;
                                                margin-bottom: 8px;
                                            ">
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 12px;
                                                    flex: 1;
                                                ">
                                                    <div style="
                                                        width: 28px;
                                                        height: 28px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        border-radius: 6px;
                                                        display: flex;
                                                        align-items: center;
                                                        justify-content: center;
                                                        color: white;
                                                        font-weight: 600;
                                                        font-size: 12px;
                                                    ">${index + 11}</div>
                                                    <div style="
                                                        flex: 1;
                                                        min-width: 0;
                                                    ">
                                                        <h4 style="
                                                            margin: 0 0 6px 0;
                                                            font-size: 15px;
                                                            font-weight: 500;
                                                            line-height: 1.3;
                                                            color: #ffffff;
                                                            word-wrap: break-word;
                                                        ">${
                                                          market.question ||
                                                          "Untitled Market"
                                                        }</h4>
                                                    </div>
                                                </div>
                                                <div style="
                                                    display: flex;
                                                    flex-direction: column;
                                                    align-items: flex-end;
                                                    gap: 6px;
                                                    flex-shrink: 0;
                                                    margin-left: 12px;
                                                ">
                                                    <div style="
                                                        background: #059669;
                                                        color: white;
                                                        padding: 4px 10px;
                                                        border-radius: 12px;
                                                        font-size: 11px;
                                                        font-weight: 600;
                                                        display: inline-block;
                                                    ">$${(
                                                      market.volume || 0
                                                    ).toLocaleString()}</div>
                                                    ${
                                                      market.active
                                                        ? `
                                                        <div style="
                                                            background: #059669;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">🟢 Active</div>
                                                    `
                                                        : market.closed
                                                        ? `
                                                        <div style="
                                                            background: #dc2626;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">🔴 Closed</div>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: center;
                                                font-size: 12px;
                                                color: #aaa;
                                                flex-wrap: wrap;
                                                gap: 8px;
                                            ">
                                                <span>🆔 ${market.id}</span>
                                                ${
                                                  market.endDateIso
                                                    ? `<span>📅 End: ${new Date(
                                                        market.endDateIso
                                                      ).toLocaleDateString()}</span>`
                                                    : market.startDateIso
                                                    ? `<span>📅 Start: ${new Date(
                                                        market.startDateIso
                                                      ).toLocaleDateString()}</span>`
                                                    : ""
                                                }
                                                ${
                                                  market.resolutionSource
                                                    ? `<span>📋 Source: ${market.resolutionSource}</span>`
                                                    : ""
                                                }
                                                ${
                                                  market.competitive
                                                    ? `<span>🏆 Competitive</span>`
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                    `
                                      )
                                      .join("")}
                                </div>
                            </div>
                        `
                            : ""
                        }
                    </div>
                `;

            this.logHtml(marketsHtml, "output");
          } else {
            this.log("❌ No markets found", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketActiveMarkets =
          async function () {
            this.log("🎯 Fetching active markets...", "info");

            // Use events endpoint for active markets per official docs
            const data = await this.makePolymarketRequest(
              `/events?order=id&ascending=false&closed=false&limit=50`
            );
            if (!data) return;

            // Handle both array format and {data: array} format
            const events = Array.isArray(data) ? data : data.data || [];

            if (events && events.length > 0) {
              // Convert events to markets and filter for active markets
              const sortedMarkets = events
                .filter((event) => {
                  // Only show events with markets and volume
                  if (!event.markets || !event.markets.length) return false;

                  // Get the primary market for volume calculation
                  const primaryMarket = event.markets[0];
                  if (
                    !primaryMarket ||
                    !primaryMarket.volume ||
                    primaryMarket.volume <= 0
                  )
                    return false;

                  return true;
                })
                .map((event) => {
                  // Convert event to market format for display
                  const primaryMarket = event.markets[0];
                  return {
                    id: event.id,
                    question: event.title || "Untitled Event",
                    description: event.description || "",
                    volume: primaryMarket.volume || 0,
                    liquidity: primaryMarket.liquidity || 0,
                    active: true,
                    endDate: event.endDate || event.end_date,
                    startDate: event.startDate || event.start_date,
                    createdAt: event.createdAt || event.created_at,
                    slug: event.slug,
                    category: event.category || "",
                    featured: event.featured || false,
                    markets: event.markets || [],
                  };
                })
                .sort((a, b) => (b.volume || 0) - (a.volume || 0))
                .slice(0, 10);

              // Create modern UI for active markets
              const activeHtml = `
                    <div style="
                        background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.1) 100%);
                        border: 1px solid rgba(34, 197, 94, 0.2);
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        backdrop-filter: blur(10px);
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid rgba(34, 197, 94, 0.2);
                        ">
                            <div style="
                                width: 40px;
                                height: 40px;
                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 18px;
                            ">🔥</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    background: linear-gradient(135deg, #22c55e, #16a34a);
                                    -webkit-background-clip: text;
                                    -webkit-text-fill-color: transparent;
                                    background-clip: text;
                                ">Active Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #6b7280;
                                ">Top ${
                                  sortedMarkets.length
                                } trending markets by volume</p>
                            </div>
                        </div>
                        <div style="display: grid; gap: 16px;">
                            ${sortedMarkets
                              .map(
                                (market, index) => `
                                <div style="
                                    background: var(--poly-bg-primary);
                                    border: 1px solid var(--poly-border);
                                    border-radius: 12px;
                                    padding: 20px;
                                    transition: all 0.2s ease;
                                    position: relative;
                                    overflow: hidden;
                                ">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #22c55e, #16a34a);
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 12px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 32px;
                                                height: 32px;
                                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                                border-radius: 8px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 600;
                                                font-size: 14px;
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 500;
                                                    line-height: 1.4;
                                                    color: #1f2937;
                                                    word-wrap: break-word;
                                                ">${market.question}</h4>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #10b981, #059669);
                                                color: white;
                                                padding: 6px 12px;
                                                border-radius: 20px;
                                                font-size: 12px;
                                                font-weight: 600;
                                                display: inline-block;
                                            ">$${(
                                              market.volume || 0
                                            ).toLocaleString()}</div>
                                            <div style="
                                                background: linear-gradient(135deg, #22c55e, #16a34a);
                                                color: white;
                                                padding: 4px 8px;
                                                border-radius: 12px;
                                                font-size: 11px;
                                                font-weight: 500;
                                                display: inline-block;
                                            ">🟢 Active</div>
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #6b7280;
                                    ">
                                        <span>🆔 ${market.id}</span>
                                        ${
                                          market.end_date_iso
                                            ? `<span>📅 End: ${new Date(
                                                market.end_date_iso
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(activeHtml, "output");
            } else {
              this.log("❌ No active markets found", "error");
            }
          };

        OmegaMinerTerminal.prototype.getPolymarketTrendingMarkets =
          async function () {
            this.log("🔥 Fetching highest volume markets...", "info");

            // Use events endpoint for trending markets per official docs
            const data = await this.makePolymarketRequest(
              `/events?order=id&ascending=false&closed=false&limit=100`
            );
            if (!data) return;

            // Handle both array format and {data: array} format
            const events = Array.isArray(data) ? data : data.data || [];

            if (events && events.length > 0) {
              // Convert events to markets and sort by volume for trending
              const trendingMarkets = events
                .filter((event) => {
                  // Only show events with markets and volume
                  if (!event.markets || !event.markets.length) return false;

                  // Get the primary market for volume calculation
                  const primaryMarket = event.markets[0];
                  if (
                    !primaryMarket ||
                    !primaryMarket.volume ||
                    primaryMarket.volume <= 0
                  )
                    return false;

                  return true;
                })
                .map((event) => {
                  // Convert event to market format for display
                  const primaryMarket = event.markets[0];
                  return {
                    id: event.id,
                    question: event.title || "Untitled Event",
                    description: event.description || "",
                    volume: primaryMarket.volume || 0,
                    liquidity: primaryMarket.liquidity || 0,
                    active: true,
                    endDate: event.endDate || event.end_date,
                    startDate: event.startDate || event.start_date,
                    createdAt: event.createdAt || event.created_at,
                    slug: event.slug,
                    category: event.category || "",
                    featured: event.featured || false,
                    markets: event.markets || [],
                  };
                })
                .sort((a, b) => (b.volume || 0) - (a.volume || 0))
                .slice(0, 8);

              // Create modern UI for trending markets with grid layout
              const trendingHtml = `
                    <div style="
                        background: #1a1a1a;
                        border: 1px solid #333;
                        border-radius: 12px;
                        padding: 20px;
                        margin: 16px 0;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 20px;
                            padding-bottom: 12px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 36px;
                                height: 36px;
                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 12px;
                                font-size: 16px;
                            ">🔥</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 18px;
                                    font-weight: 600;
                                    color: #ffffff;
                                ">Trending Markets</h3>
                                <p style="
                                    margin: 4px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                ">${
                                  trendingMarkets.length
                                } highest volume markets</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr)); gap: 16px;">
                            ${trendingMarkets
                              .map(
                                (market, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                " onmouseover="this.style.transform='translateY(-6px) scale(1.02)'; this.style.boxShadow='0 12px 32px rgba(107, 114, 128, 0.4)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.2)'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #6b7280, #4b5563);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    
                                    <!-- Header with volume -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            background: linear-gradient(135deg, #059669, #047857);
                                            color: white;
                                            padding: 6px 12px;
                                            border-radius: 20px;
                                            font-size: 12px;
                                            font-weight: 600;
                                            box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                        ">$${(
                                          market.volume || 0
                                        ).toLocaleString()}</div>
                                        ${
                                          market.active
                                            ? `
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 4px 8px;
                                                border-radius: 12px;
                                                font-size: 10px;
                                                font-weight: 500;
                                            ">🟢 Active</div>
                                        `
                                            : ""
                                        }
                                    </div>

                                    <!-- Question/Title -->
                                    <h4 style="
                                        margin: 0 0 12px 0;
                                        font-size: 14px;
                                        font-weight: 600;
                                        line-height: 1.4;
                                        color: #ffffff;
                                        word-wrap: break-word;
                                        display: -webkit-box;
                                        -webkit-line-clamp: 3;
                                        -webkit-box-orient: vertical;
                                        overflow: hidden;
                                    ">${
                                      market.question || "Untitled Market"
                                    }</h4>

                                    <!-- Trade button -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 8px;
                                    ">
                                        <a href="https://polymarket.com/market/${
                                          market.slug || market.id
                                        }" target="_blank" title="Trade this market on Polymarket" style="
                                            background: linear-gradient(135deg, #6b7280, #4b5563);
                                            color: white;
                                            padding: 8px 16px;
                                            border-radius: 20px;
                                            font-size: 12px;
                                            font-weight: 600;
                                            text-decoration: none;
                                            display: inline-flex;
                                            align-items: center;
                                            gap: 6px;
                                            box-shadow: 0 3px 8px rgba(107, 114, 128, 0.3);
                                            transition: all 0.2s ease;
                                            flex: 1;
                                            justify-content: center;
                                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(107, 114, 128, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(107, 114, 128, 0.3)';">
                                            🔗 Trade
                                        </a>
                                    </div>

                                    <!-- Footer info -->
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 10px;
                                        color: #888;
                                        margin-top: 8px;
                                        padding-top: 8px;
                                        border-top: 1px solid #333;
                                    ">
                                        <span>🆔 ${market.id}</span>
                                        ${
                                          market.endDate
                                            ? `<span>📅 ${new Date(
                                                market.endDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(trendingHtml, "output");
            } else {
              this.log("❌ No trending markets found", "error");
            }
          };

        OmegaMinerTerminal.prototype.searchPolymarketMarkets = async function (
          query
        ) {
          this.log(`🔍 Searching Polymarket for: "${query}"`, "info");

          const data = await this.makePolymarketRequest(
            `/markets?question=${encodeURIComponent(query)}&limit=15`
          );
          if (!data) return;

          // Handle both array format and {data: array} format
          const markets = Array.isArray(data) ? data : data.data || [];

          if (markets && markets.length > 0) {
            this.log(`📊 Found ${markets.length} matching markets:`, "success");
            markets.slice(0, 10).forEach((market, index) => {
              this.log(`${index + 1}. ${market.question}`, "output");
              this.log(`   🆔 ID: ${market.id}`, "info");
              this.log(
                `   💰 Volume: $${(market.volume || 0).toLocaleString()}`,
                "info"
              );
              if (market.end_date_iso) {
                this.log(
                  `   📅 End: ${new Date(
                    market.end_date_iso
                  ).toLocaleDateString()}`,
                  "info"
                );
              }
              this.log("", "info");
            });
          } else {
            this.log("❌ No markets found matching your search", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketEvents = async function () {
          this.log("🎯 Fetching recent Polymarket events...", "info");

          // Get more events and filter for recent ones (last 6 months)
          const data = await this.makePolymarketRequest(
            "/events?limit=50&order=createdAt&ascending=false"
          );
          if (!data) return;

          if (data && data.length > 0) {
            // Filter for recent events (last 6 months)
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

            const recentEvents = data.filter((event) => {
              if (!event.endDate && !event.startDate) return false;
              const eventDate = new Date(event.endDate || event.startDate);
              return eventDate > sixMonthsAgo;
            });

            if (recentEvents.length === 0) {
              this.log(
                "❌ No recent events found in the last 6 months",
                "error"
              );
              this.log(
                "💡 Try using different date filters or check if there are any active markets",
                "info"
              );
              return;
            }

            // Create enhanced UI for events with clickable URLs
            const eventsHtml = `
                    <div style="
                        background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
                        border: 1px solid #333;
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            height: 4px;
                            background: linear-gradient(90deg, #ec4899, #ef4444, #8b5cf6);
                        "></div>
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 24px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 48px;
                                height: 48px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 20px;
                                box-shadow: 0 4px 16px rgba(107, 114, 128, 0.3);
                            ">🎯</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 20px;
                                    font-weight: 700;
                                    color: #ffffff;
                                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                                ">Recent Events</h3>
                                <p style="
                                    margin: 6px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                    font-weight: 500;
                                ">${
                                  recentEvents.length
                                } events found • Last 6 months</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr)); gap: 16px;">
                            ${recentEvents
                              .slice(0, 12)
                              .map(
                                (event, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                    " onmouseover="this.style.transform='translateY(-6px) scale(1.02)'; this.style.boxShadow='0 12px 32px rgba(107, 114, 128, 0.4)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.2)'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                            background: linear-gradient(90deg, #06b6d4, #0891b2);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 16px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 36px;
                                                height: 36px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                border-radius: 10px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 700;
                                                font-size: 14px;
                                                box-shadow: 0 4px 12px rgba(236, 72, 153, 0.3);
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 600;
                                                    line-height: 1.4;
                                                    color: #ffffff;
                                                    word-wrap: break-word;
                                                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                                                ">${
                                                  event.title ||
                                                  "Untitled Event"
                                                }</h4>
                                                ${
                                                  event.subtitle
                                                    ? `
                                                    <p style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 13px;
                                                        color: #bbb;
                                                        line-height: 1.3;
                                                    ">${event.subtitle}</p>
                                                `
                                                    : ""
                                                }
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 8px;
                                                    margin-top: 8px;
                                                ">
                                                    <a href="https://polymarket.com/event/${
                                                      event.slug || event.id
                                                    }" target="_blank" style="
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        color: white;
                                                        padding: 6px 12px;
                                                        border-radius: 20px;
                                                        font-size: 12px;
                                                        font-weight: 600;
                                                        text-decoration: none;
                                                        display: inline-flex;
                                                        align-items: center;
                                                        gap: 6px;
                                                        box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                                        transition: all 0.2s ease;
                                                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                                        🔗 View on Polymarket
                                                    </a>
                                                    ${
                                                      event.category
                                                        ? `
                                                        <span style="
                                                            background: rgba(6, 182, 212, 0.2);
                                                            color: #06b6d4;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                            border: 1px solid rgba(6, 182, 212, 0.3);
                                                        ">${event.category}</span>
                                                    `
                                                        : ""
                                                    }
                                                    ${
                                                      event.featured
                                                        ? `
                                                        <span style="
                                                            background: linear-gradient(135deg, #f59e0b, #d97706);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                        ">⭐ Featured</span>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 13px;
                                                font-weight: 700;
                                                display: inline-block;
                                                box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              event.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              event.liquidity
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
                                                ">💧 $${event.liquidity.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.openInterest
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #f59e0b, #d97706);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(245, 158, 11, 0.3);
                                                ">📊 $${event.openInterest.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">🟢 Active</div>
                                            `
                                                : event.closed
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #dc2626, #b91c1c);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(220, 38, 38, 0.3);
                                                ">🔴 Closed</div>
                                            `
                                                : ""
                                            }
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #aaa;
                                        font-weight: 500;
                                        flex-wrap: wrap;
                                        gap: 8px;
                                    ">
                                        <span>🆔 ${event.id}</span>
                                        ${
                                          event.endDate
                                            ? `<span>📅 End: ${new Date(
                                                event.endDate
                                              ).toLocaleDateString()}</span>`
                                            : event.startDate
                                            ? `<span>📅 Start: ${new Date(
                                                event.startDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                        ${
                                          event.resolutionSource
                                            ? `<span>📋 Source: ${event.resolutionSource}</span>`
                                            : ""
                                        }
                                        ${
                                          event.competitive
                                            ? `<span>🏆 Competitive</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                        ${
                          recentEvents.length > 6
                            ? `
                            <div style="
                                text-align: center;
                                margin-top: 20px;
                                padding-top: 16px;
                                border-top: 1px solid #333;
                            ">
                                <button onclick="this.parentElement.parentElement.querySelector('.show-more-events').style.display='grid'; this.style.display='none';" style="
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    color: white;
                                    border: none;
                                    padding: 12px 24px;
                                    border-radius: 20px;
                                    font-size: 14px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                    🔽 Show More Events (${
                                      recentEvents.length - 6
                                    } more)
                                </button>
                                <div class="show-more-events" style="display: none; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; margin-top: 16px;">
                                    ${recentEvents
                                      .slice(6)
                                      .map(
                                        (event, index) => `
                                        <div style="
                                            background: #2a2a2a;
                                            border: 1px solid #444;
                                            border-radius: 8px;
                                            padding: 16px;
                                            transition: all 0.2s ease;
                                            position: relative;
                                        ">
                                            <div style="
                                                position: absolute;
                                                top: 0;
                                                left: 0;
                                                right: 0;
                                                height: 2px;
                                                background: linear-gradient(90deg, #06b6d4, #0891b2);
                                            "></div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: flex-start;
                                                margin-bottom: 8px;
                                            ">
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 12px;
                                                    flex: 1;
                                                ">
                                                    <div style="
                                                        width: 28px;
                                                        height: 28px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        border-radius: 6px;
                                                        display: flex;
                                                        align-items: center;
                                                        justify-content: center;
                                                        color: white;
                                                        font-weight: 600;
                                                        font-size: 12px;
                                                    ">${index + 7}</div>
                                                    <div style="
                                                        flex: 1;
                                                        min-width: 0;
                                                    ">
                                                        <h4 style="
                                                            margin: 0 0 6px 0;
                                                            font-size: 15px;
                                                            font-weight: 500;
                                                            line-height: 1.3;
                                                            color: #ffffff;
                                                            word-wrap: break-word;
                                                        ">${
                                                          event.title ||
                                                          "Untitled Event"
                                                        }</h4>
                                                    </div>
                                                </div>
                                                <div style="
                                                    display: flex;
                                                    flex-direction: column;
                                                    align-items: flex-end;
                                                    gap: 6px;
                                                    flex-shrink: 0;
                                                    margin-left: 12px;
                                                ">
                                                    <div style="
                                                        background: #059669;
                                                        color: white;
                                                        padding: 4px 10px;
                                                        border-radius: 12px;
                                                        font-size: 11px;
                                                        font-weight: 600;
                                                        display: inline-block;
                                                    ">$${(
                                                      event.volume || 0
                                                    ).toLocaleString()}</div>
                                                    ${
                                                      event.active
                                                        ? `
                                                        <div style="
                                                            background: #059669;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">🟢 Active</div>
                                                    `
                                                        : event.closed
                                                        ? `
                                                        <div style="
                                                            background: #dc2626;
                                                            color: white;
                                                            padding: 3px 8px;
                                                            border-radius: 10px;
                                                            font-size: 10px;
                                                            font-weight: 500;
                                                            display: inline-block;
                                                        ">🔴 Closed</div>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                justify-content: space-between;
                                                align-items: center;
                                                font-size: 12px;
                                                color: #aaa;
                                                flex-wrap: wrap;
                                                gap: 8px;
                                            ">
                                                <span>🆔 ${event.id}</span>
                                                ${
                                                  event.endDate
                                                    ? `<span>📅 End: ${new Date(
                                                        event.endDate
                                                      ).toLocaleDateString()}</span>`
                                                    : event.startDate
                                                    ? `<span>📅 Start: ${new Date(
                                                        event.startDate
                                                      ).toLocaleDateString()}</span>`
                                                    : ""
                                                }
                                                ${
                                                  event.resolutionSource
                                                    ? `<span>📋 Source: ${event.resolutionSource}</span>`
                                                    : ""
                                                }
                                                ${
                                                  event.competitive
                                                    ? `<span>🏆 Competitive</span>`
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                    `
                                      )
                                      .join("")}
                                </div>
                            </div>
                        `
                            : ""
                        }
                    </div>
                `;

            this.logHtml(eventsHtml, "output");
          } else {
            this.log("❌ No events found", "error");
          }
        };

        OmegaMinerTerminal.prototype.getPolymarketRecentEvents =
          async function () {
            this.log("🎯 Fetching very recent Polymarket events...", "info");

            // Get very recent events (last month) using API date filtering
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            const dateFilter = oneMonthAgo.toISOString().split("T")[0]; // YYYY-MM-DD format

            const data = await this.makePolymarketRequest(
              `/events?limit=30&start_date_min=${dateFilter}&order=createdAt&ascending=false`
            );
            if (!data) return;

            if (data && data.length > 0) {
              const recentEvents = data.slice(0, 8);

              // Create enhanced UI for recent events with clickable URLs
              const recentHtml = `
                    <div style="
                        background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
                        border: 1px solid #333;
                        border-radius: 16px;
                        padding: 24px;
                        margin: 16px 0;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                        position: relative;
                        overflow: hidden;
                    ">
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            height: 4px;
                            background: linear-gradient(90deg, #06b6d4, #0891b2, #06b6d4);
                        "></div>
                        <div style="
                            display: flex;
                            align-items: center;
                            margin-bottom: 24px;
                            padding-bottom: 16px;
                            border-bottom: 1px solid #333;
                        ">
                            <div style="
                                width: 48px;
                                height: 48px;
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                margin-right: 16px;
                                font-size: 20px;
                                box-shadow: 0 4px 16px rgba(107, 114, 128, 0.3);
                            ">⚡</div>
                            <div>
                                <h3 style="
                                    margin: 0;
                                    font-size: 20px;
                                    font-weight: 700;
                                    color: #ffffff;
                                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                                ">Very Recent Events</h3>
                                <p style="
                                    margin: 6px 0 0 0;
                                    font-size: 14px;
                                    color: #888;
                                    font-weight: 500;
                                ">${
                                  recentEvents.length
                                } events found • Last month</p>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr)); gap: 16px;">
                            ${recentEvents
                              .map(
                                (event, index) => `
                                <div style="
                                    background: #1a1a1a;
                                    border: 1px solid #333;
                                    border-radius: 12px;
                                    padding: 16px;
                                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                    position: relative;
                                    cursor: pointer;
                                    height: 280px;
                                    display: flex;
                                    flex-direction: column;
                                    justify-content: space-between;
                                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                    " onmouseover="this.style.transform='translateY(-6px) scale(1.02)'; this.style.boxShadow='0 12px 32px rgba(107, 114, 128, 0.4)'; this.style.borderColor='#6b7280';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.2)'; this.style.borderColor='#333';">
                                    <div style="
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        height: 3px;
                                        background: linear-gradient(90deg, #06b6d4, #0891b2);
                                        border-radius: 12px 12px 0 0;
                                    "></div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: flex-start;
                                        margin-bottom: 12px;
                                    ">
                                        <div style="
                                            display: flex;
                                            align-items: center;
                                            gap: 16px;
                                            flex: 1;
                                        ">
                                            <div style="
                                                width: 36px;
                                                height: 36px;
                                                background: linear-gradient(135deg, #6b7280, #4b5563);
                                                border-radius: 10px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                color: white;
                                                font-weight: 700;
                                                font-size: 14px;
                                                box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
                                            ">${index + 1}</div>
                                            <div style="
                                                flex: 1;
                                                min-width: 0;
                                            ">
                                                <h4 style="
                                                    margin: 0 0 8px 0;
                                                    font-size: 16px;
                                                    font-weight: 600;
                                                    line-height: 1.4;
                                                    color: #ffffff;
                                                    word-wrap: break-word;
                                                    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                                                ">${
                                                  event.title ||
                                                  "Untitled Event"
                                                }</h4>
                                                ${
                                                  event.subtitle
                                                    ? `
                                                    <p style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 13px;
                                                        color: #bbb;
                                                        line-height: 1.3;
                                                    ">${event.subtitle}</p>
                                                `
                                                    : ""
                                                }
                                                <div style="
                                                    display: flex;
                                                    align-items: center;
                                                    gap: 8px;
                                                    margin-top: 8px;
                                                ">
                                                    <a href="https://polymarket.com/event/${
                                                      event.slug || event.id
                                                    }" target="_blank" style="
                                                        background: linear-gradient(135deg, #6b7280, #4b5563);
                                                        color: white;
                                                        padding: 6px 12px;
                                                        border-radius: 20px;
                                                        font-size: 12px;
                                                        font-weight: 600;
                                                        text-decoration: none;
                                                        display: inline-flex;
                                                        align-items: center;
                                                        gap: 6px;
                                                        box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
                                                        transition: all 0.2s ease;
                                                    " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 16px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.3)';">
                                                        🔗 View on Polymarket
                                                    </a>
                                                    ${
                                                      event.category
                                                        ? `
                                                        <span style="
                                                            background: rgba(6, 182, 212, 0.2);
                                                            color: #06b6d4;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                            border: 1px solid rgba(6, 182, 212, 0.3);
                                                        ">${event.category}</span>
                                                    `
                                                        : ""
                                                    }
                                                    ${
                                                      event.featured
                                                        ? `
                                                        <span style="
                                                            background: linear-gradient(135deg, #f59e0b, #d97706);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 11px;
                                                            font-weight: 500;
                                                        ">⭐ Featured</span>
                                                    `
                                                        : ""
                                                    }
                                                </div>
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            flex-direction: column;
                                            align-items: flex-end;
                                            gap: 8px;
                                            flex-shrink: 0;
                                            margin-left: 16px;
                                        ">
                                            <div style="
                                                background: linear-gradient(135deg, #059669, #047857);
                                                color: white;
                                                padding: 8px 16px;
                                                border-radius: 20px;
                                                font-size: 13px;
                                                font-weight: 700;
                                                display: inline-block;
                                                box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
                                            ">$${(
                                              event.volume || 0
                                            ).toLocaleString()}</div>
                                            ${
                                              event.liquidity
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3);
                                                ">💧 $${event.liquidity.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.openInterest
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #f59e0b, #d97706);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(245, 158, 11, 0.3);
                                                ">📊 $${event.openInterest.toLocaleString()}</div>
                                            `
                                                : ""
                                            }
                                            ${
                                              event.active
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">🟢 Active</div>
                                            `
                                                : event.closed
                                                ? `
                                                <div style="
                                                    background: linear-gradient(135deg, #dc2626, #b91c1c);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(220, 38, 38, 0.3);
                                                ">🔴 Closed</div>
                                            `
                                                : ""
                                            }
                                        </div>
                                    </div>
                                    <div style="
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        font-size: 13px;
                                        color: #aaa;
                                        font-weight: 500;
                                        flex-wrap: wrap;
                                        gap: 8px;
                                    ">
                                        <span>🆔 ${event.id}</span>
                                        ${
                                          event.endDate
                                            ? `<span>📅 End: ${new Date(
                                                event.endDate
                                              ).toLocaleDateString()}</span>`
                                            : event.startDate
                                            ? `<span>📅 Start: ${new Date(
                                                event.startDate
                                              ).toLocaleDateString()}</span>`
                                            : ""
                                        }
                                        ${
                                          event.resolutionSource
                                            ? `<span>📋 Source: ${event.resolutionSource}</span>`
                                            : ""
                                        }
                                        ${
                                          event.competitive
                                            ? `<span>🏆 Competitive</span>`
                                            : ""
                                        }
                                    </div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    </div>
                `;

              this.logHtml(recentHtml, "output");

              if (data.length === 0) {
                this.log(
                  "❌ No very recent events found in the last month",
                  "error"
                );
                this.log(
                  '💡 Try "polymarket events" for events from the last 6 months',
                  "info"
                );
              }
            } else {
              this.log("❌ No recent events found", "error");
            }
          };

        // Category-specific functions
        OmegaMinerTerminal.prototype.getPolymarketBreaking = async function () {
          this.log("🔥 Fetching breaking news markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "breaking",
            "Breaking News",
            "🔥"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketNew = async function () {
          this.log("🆕 Fetching newest markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "new",
            "Newest Markets",
            "🆕"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketPolitics = async function () {
          this.log("🏛️ Fetching political markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "politics",
            "Political Markets",
            "🏛️"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketSports = async function () {
          this.log("⚽ Fetching sports markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "sports",
            "Sports Markets",
            "⚽"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketCrypto = async function () {
          this.log("₿ Fetching crypto markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "crypto",
            "Crypto Markets",
            "₿"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketEarnings = async function () {
          this.log("📊 Fetching earnings markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "earnings",
            "Earnings Markets",
            "📊"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketGeopolitics =
          async function () {
            this.log("🌍 Fetching geopolitical markets...", "info");
            await this.getPolymarketCategoryMarkets(
              "geopolitics",
              "Geopolitical Markets",
              "🌍"
            );
          };

        OmegaMinerTerminal.prototype.getPolymarketTech = async function () {
          this.log("💻 Fetching technology markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "tech",
            "Technology Markets",
            "💻"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketCulture = async function () {
          this.log("🎭 Fetching culture markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "culture",
            "Culture Markets",
            "🎭"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketWorld = async function () {
          this.log("🌎 Fetching world events...", "info");
          await this.getPolymarketCategoryMarkets(
            "world",
            "World Events",
            "🌎"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketEconomy = async function () {
          this.log("💰 Fetching economic markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "economy",
            "Economic Markets",
            "💰"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketTrump = async function () {
          this.log("👑 Fetching Trump-related markets...", "info");
          await this.getPolymarketCategoryMarkets(
            "trump",
            "Trump Markets",
            "👑"
          );
        };

        OmegaMinerTerminal.prototype.getPolymarketElections =
          async function () {
            this.log("🗳️ Fetching election markets...", "info");
            await this.getPolymarketCategoryMarkets(
              "elections",
              "Election Markets",
              "🗳️"
            );
          };

        // Generic category function that handles all categories
        OmegaMinerTerminal.prototype.getPolymarketCategoryMarkets =
          async function (category, displayName, icon) {
            try {
              // Use the correct API approach per official docs
              // Get current active markets using events endpoint (most efficient)
              const data = await this.makePolymarketRequest(
                `/events?order=id&ascending=false&closed=false&limit=100`
              );

              if (!data) return;

              // Handle both array format and {data: array} format
              const events = Array.isArray(data) ? data : data.data || [];

              if (events && events.length > 0) {
                // Extract markets from events and filter by category
                const categoryKeywords = this.getCategoryKeywords(category);
                console.log(
                  `🔍 Searching for ${category} markets with keywords:`,
                  categoryKeywords.slice(0, 10)
                );

                const sortedMarkets = events
                  .filter((event) => {
                    // Only show events with markets and volume
                    if (!event.markets || !event.markets.length) return false;

                    // Get the primary market for volume calculation
                    const primaryMarket = event.markets[0];
                    if (
                      !primaryMarket ||
                      !primaryMarket.volume ||
                      primaryMarket.volume <= 0
                    )
                      return false;

                    // Client-side category filtering using event title and description
                    const searchText = `${event.title || ""} ${
                      event.description || ""
                    }`.toLowerCase();
                    const matches = categoryKeywords.filter((keyword) =>
                      searchText.includes(keyword.toLowerCase())
                    );

                    if (matches.length > 0) {
                      console.log(
                        `✅ ${category} match: "${matches[0]}" in "${event.title}"`
                      );
                      return true;
                    }

                    return false;
                  })
                  .map((event) => {
                    // Convert event to market format for display
                    const primaryMarket = event.markets[0];
                    return {
                      id: event.id,
                      question: event.title || "Untitled Event",
                      description: event.description || "",
                      volume: primaryMarket.volume || 0,
                      liquidity: primaryMarket.liquidity || 0,
                      active: true,
                      endDate: event.endDate || event.end_date,
                      startDate: event.startDate || event.start_date,
                      createdAt: event.createdAt || event.created_at,
                      slug: event.slug,
                      category: event.category || "",
                      featured: event.featured || false,
                      markets: event.markets || [],
                    };
                  })
                  .sort((a, b) => (b.volume || 0) - (a.volume || 0));

                // Create category-specific UI
                const categoryHtml = `
                        <div style="
                            background: #1a1a1a;
                            border: 1px solid #333;
                            border-radius: 12px;
                            padding: 20px;
                            margin: 16px 0;
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        ">
                            <div style="
                                display: flex;
                                align-items: center;
                                margin-bottom: 20px;
                                padding-bottom: 12px;
                                border-bottom: 1px solid #333;
                            ">
                                <div style="
                                    width: 36px;
                                    height: 36px;
                                    background: linear-gradient(135deg, #06b6d4, #0891b2);
                                    border-radius: 8px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    margin-right: 12px;
                                    font-size: 16px;
                                ">${icon}</div>
                                <div>
                                    <h3 style="
                                        margin: 0;
                                        font-size: 18px;
                                        font-weight: 600;
                                        color: #ffffff;
                                    ">${displayName}</h3>
                                    <p style="
                                        margin: 4px 0 0 0;
                                        font-size: 14px;
                                        color: #888;
                                    ">${
                                      sortedMarkets.length
                                    } markets found • Sorted by volume</p>
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(280px, 100%), 1fr)); gap: 16px;">
                                ${sortedMarkets
                                  .slice(0, 12)
                                  .map(
                                    (market, index) => `
                                    <div style="
                                        background: #1a1a1a;
                                        border: 1px solid #333;
                                        border-radius: 12px;
                                        padding: 16px;
                                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                                        position: relative;
                                        cursor: pointer;
                                        height: 280px;
                                        display: flex;
                                        flex-direction: column;
                                        justify-content: space-between;
                                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                                    " onmouseover="this.style.transform='translateY(-6px) scale(1.02)'; this.style.boxShadow='0 12px 32px rgba(6, 182, 212, 0.4)'; this.style.borderColor='#06b6d4';" onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.2)'; this.style.borderColor='#333';">
                                        <div style="
                                            position: absolute;
                                            top: 0;
                                            left: 0;
                                            right: 0;
                                            height: 3px;
                                            background: linear-gradient(90deg, #6b7280, #4b5563);
                                            border-radius: 12px 12px 0 0;
                                        "></div>
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: flex-start;
                                            margin-bottom: 12px;
                                        ">
                                            <div style="
                                                display: flex;
                                                align-items: center;
                                                gap: 12px;
                                                flex: 1;
                                            ">
                                                <div style="
                                                    width: 28px;
                                                    height: 28px;
                                                    background: linear-gradient(135deg, #6b7280, #4b5563);
                                                    border-radius: 6px;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    color: white;
                                                    font-weight: 600;
                                                    font-size: 12px;
                                                ">${index + 1}</div>
                                                <div style="
                                                    flex: 1;
                                                    min-width: 0;
                                                ">
                                                    <h4 style="
                                                        margin: 0 0 8px 0;
                                                        font-size: 15px;
                                                        font-weight: 500;
                                                        line-height: 1.3;
                                                        color: #ffffff;
                                                        word-wrap: break-word;
                                                    ">${
                                                      market.question ||
                                                      "Untitled Market"
                                                    }</h4>
                                                    ${
                                                      market.description
                                                        ? `
                                                        <p style="
                                                            margin: 0 0 8px 0;
                                                            font-size: 12px;
                                                            color: #bbb;
                                                            line-height: 1.3;
                                                            display: -webkit-box;
                                                            -webkit-line-clamp: 2;
                                                            -webkit-box-orient: vertical;
                                                            overflow: hidden;
                                                        ">${market.description}</p>
                                                    `
                                                        : ""
                                                    }
                                                    <div style="
                                                        display: flex;
                                                        align-items: center;
                                                        gap: 8px;
                                                        flex-wrap: wrap;
                                                        margin-top: 8px;
                                                    ">
                                                        <a href="https://polymarket.com/market/${
                                                          market.slug ||
                                                          market.id
                                                        }" target="_blank" style="
                                                            background: linear-gradient(135deg, #6b7280, #4b5563);
                                                            color: white;
                                                            padding: 4px 8px;
                                                            border-radius: 12px;
                                                            font-size: 10px;
                                                            font-weight: 600;
                                                            text-decoration: none;
                                                            display: inline-flex;
                                                            align-items: center;
                                                            gap: 4px;
                                                            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.3);
                                                            transition: all 0.2s ease;
                                                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(6, 182, 212, 0.4)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 8px rgba(6, 182, 212, 0.3)';">
                                                            🔗 Trade
                                                        </a>
                                                        ${
                                                          market.category
                                                            ? `
                                                            <span style="
                                                                background: rgba(6, 182, 212, 0.2);
                                                                color: #06b6d4;
                                                                padding: 2px 6px;
                                                                border-radius: 8px;
                                                                font-size: 10px;
                                                                font-weight: 500;
                                                                border: 1px solid rgba(6, 182, 212, 0.3);
                                                            ">${market.category}</span>
                                                        `
                                                            : ""
                                                        }
                                                    </div>
                                                </div>
                                            </div>
                                            <div style="
                                                display: flex;
                                                flex-direction: column;
                                                align-items: flex-end;
                                                gap: 6px;
                                                flex-shrink: 0;
                                                margin-left: 12px;
                                            ">
                                                <div style="
                                                    background: linear-gradient(135deg, #059669, #047857);
                                                    color: white;
                                                    padding: 6px 12px;
                                                    border-radius: 16px;
                                                    font-size: 11px;
                                                    font-weight: 600;
                                                    display: inline-block;
                                                    box-shadow: 0 3px 8px rgba(5, 150, 105, 0.3);
                                                ">$${(
                                                  market.volume || 0
                                                ).toLocaleString()}</div>
                                                ${
                                                  market.active
                                                    ? `
                                                    <div style="
                                                        background: linear-gradient(135deg, #059669, #047857);
                                                        color: white;
                                                        padding: 3px 8px;
                                                        border-radius: 10px;
                                                        font-size: 9px;
                                                        font-weight: 500;
                                                        display: inline-block;
                                                    ">🟢 Active</div>
                                                `
                                                    : ""
                                                }
                                            </div>
                                        </div>
                                        <div style="
                                            display: flex;
                                            justify-content: space-between;
                                            align-items: center;
                                            font-size: 11px;
                                            color: #aaa;
                                            flex-wrap: wrap;
                                            gap: 8px;
                                            margin-top: 8px;
                                            padding-top: 8px;
                                            border-top: 1px solid #333;
                                        ">
                                            <span>🆔 ${market.id}</span>
                                            ${
                                              market.endDate
                                                ? `<span>📅 End: ${new Date(
                                                    market.endDate
                                                  ).toLocaleDateString()}</span>`
                                                : market.startDate
                                                ? `<span>📅 Start: ${new Date(
                                                    market.startDate
                                                  ).toLocaleDateString()}</span>`
                                                : ""
                                            }
                                        </div>
                                    </div>
                                `
                                  )
                                  .join("")}
                            </div>
                        </div>
                    `;

                this.logHtml(categoryHtml, "output");
              } else {
                this.log(`❌ No ${category} markets found`, "error");
              }
            } catch (error) {
              this.log(
                `❌ Error fetching ${category} markets: ${error.message}`,
                "error"
              );
            }
          };

        // Category keyword matching functions
        OmegaMinerTerminal.prototype.getCategoryKeywords = function (category) {
          const keywordMap = {
            tech: [
              "AI",
              "artificial intelligence",
              "OpenAI",
              "ChatGPT",
              "GPT",
              "Google",
              "Microsoft",
              "Apple",
              "Meta",
              "Facebook",
              "Tesla",
              "Elon Musk",
              "tech",
              "technology",
              "software",
              "hardware",
              "computer",
              "internet",
              "startup",
              "IPO",
              "algorithm",
              "machine learning",
              "ML",
              "deep learning",
              "neural network",
              "quantum",
              "robotics",
              "automation",
              "data",
              "analytics",
              "cloud",
              "AWS",
              "Azure",
              "GCP",
              "database",
              "API",
              "programming",
              "code",
              "developer",
              "engineer",
              "scientist",
              "research",
              "innovation",
              "patent",
              "venture capital",
              "VC",
              "unicorn",
              "fintech",
              "edtech",
              "healthtech",
              "biotech",
              "space",
              "rocket",
              "satellite",
              "solar",
              "renewable",
              "energy",
              "battery",
              "electric",
              "autonomous",
              "drone",
              "VR",
              "AR",
              "metaverse",
              "gaming",
              "streaming",
              "social media",
              "platform",
              "app",
              "mobile",
              "smartphone",
              "laptop",
              "chip",
              "semiconductor",
              "processor",
              "GPU",
              "CPU",
              "memory",
              "storage",
              "server",
              "network",
              "security",
              "privacy",
              "encryption",
              "hack",
              "cyber",
              "digital",
              "online",
              "e-commerce",
              "marketplace",
              "payment",
              "banking",
            ],
            politics: [
              "Trump",
              "Biden",
              "election",
              "president",
              "presidential",
              "congress",
              "senate",
              "house",
              "republican",
              "democrat",
              "GOP",
              "liberal",
              "conservative",
              "campaign",
              "vote",
              "voting",
              "poll",
              "polling",
              "primary",
              "caucus",
              "debate",
              "rally",
              "inauguration",
              "swearing in",
              "state of the union",
              "impeachment",
              "cabinet",
              "secretary",
              "governor",
              "mayor",
              "senator",
              "representative",
              "congressman",
              "congresswoman",
              "politician",
              "policy",
              "legislation",
              "bill",
              "law",
              "act",
              "amendment",
              "constitution",
              "supreme court",
              "judge",
              "justice",
              "federal",
              "state",
              "local",
              "government",
              "administration",
              "white house",
              "capital",
              "washington",
              "dc",
              "political",
              "politics",
              "democracy",
              "republic",
              "freedom",
              "liberty",
              "rights",
              "constitution",
              "amendment",
              "federal",
              "state",
              "local",
              "municipal",
              "county",
              "city",
              "town",
              "village",
              "district",
              "ward",
              "precinct",
              "ballot",
              "candidate",
              "nominee",
              "party",
              "convention",
              "platform",
              "agenda",
              "manifesto",
              "endorsement",
              "support",
              "oppose",
              "approval",
              "disapproval",
              "rating",
              "popularity",
            ],
            sports: [
              "football",
              "soccer",
              "basketball",
              "baseball",
              "hockey",
              "tennis",
              "golf",
              "boxing",
              "MMA",
              "UFC",
              "Olympics",
              "World Cup",
              "Super Bowl",
              "NBA",
              "NFL",
              "MLB",
              "NHL",
              "MLS",
              "Premier League",
              "Champions League",
              "ESPN",
              "athlete",
              "player",
              "team",
              "game",
              "match",
              "tournament",
              "championship",
              "playoff",
              "final",
              "semifinal",
              "quarterfinal",
              "round",
              "season",
              "league",
              "division",
              "conference",
              "stadium",
              "arena",
              "field",
              "court",
              "rink",
              "track",
              "pool",
              "gym",
              "training",
              "coach",
              "manager",
              "referee",
              "umpire",
              "official",
              "score",
              "goal",
              "point",
              "run",
              "hit",
              "shot",
              "pass",
              "catch",
              "throw",
              "kick",
              "pitch",
              "serve",
              "volley",
              "dribble",
              "shoot",
              "tackle",
              "block",
              "defense",
              "offense",
              "quarterback",
              "running back",
              "wide receiver",
              "tight end",
              "linebacker",
              "cornerback",
              "safety",
              "kicker",
              "punter",
              "guard",
              "forward",
              "center",
              "goalkeeper",
              "defender",
              "midfielder",
              "striker",
              "pitcher",
              "catcher",
              "batter",
              "fielder",
              "runner",
              "goalie",
              "defenseman",
              "forward",
              "winger",
              "captain",
              "rookie",
              "veteran",
              "MVP",
              "all-star",
              "pro bowl",
              "all-pro",
              "champion",
              "winner",
              "loser",
              "tie",
              "draw",
              "overtime",
              "penalty",
              "foul",
              "yellow card",
              "red card",
              "suspension",
              "injury",
              "trade",
              "draft",
              "contract",
              "salary",
              "bonus",
              "extension",
              "free agent",
              "waiver",
              "retirement",
            ],
            crypto: [
              "bitcoin",
              "BTC",
              "ethereum",
              "ETH",
              "cryptocurrency",
              "crypto",
              "blockchain",
              "NFT",
              "Web3",
              "DeFi",
              "trading",
              "exchange",
              "coinbase",
              "binance",
              "kraken",
              "gemini",
              "crypto.com",
              "wallet",
              "metamask",
              "trust wallet",
              "ledger",
              "trezor",
              "cold storage",
              "hot wallet",
              "private key",
              "public key",
              "seed phrase",
              "mnemonic",
              "hash",
              "mining",
              "miner",
              "proof of work",
              "proof of stake",
              "PoW",
              "PoS",
              "consensus",
              "node",
              "validator",
              "stake",
              "staking",
              "yield",
              "farming",
              "liquidity",
              "pool",
              "pair",
              "swap",
              "DEX",
              "CEX",
              "AMM",
              "orderbook",
              "limit order",
              "market order",
              "stop loss",
              "take profit",
              "leverage",
              "margin",
              "futures",
              "options",
              "perpetual",
              "spot",
              "derivative",
              "token",
              "coin",
              "altcoin",
              "shitcoin",
              "meme coin",
              "stablecoin",
              "USDT",
              "USDC",
              "DAI",
              "BUSD",
              "TUSD",
              "FRAX",
              "LUSD",
              "algorithmic stablecoin",
              "governance token",
              "utility token",
              "security token",
              "utility token",
              "fungible",
              "non-fungible",
              "ERC-20",
              "ERC-721",
              "ERC-1155",
              "BEP-20",
              "TRC-20",
              "smart contract",
              "solidity",
              "vyper",
              "rust",
              "move",
              "programming",
              "developer",
              "audit",
              "hack",
              "exploit",
              "rug pull",
              "scam",
              "ponzi",
              "pyramid",
              "pump and dump",
              "whale",
              "diamond hands",
              "paper hands",
              "HODL",
              "FOMO",
              "FUD",
              "bull market",
              "bear market",
              "bullish",
              "bearish",
              "moon",
              "lambo",
              "to the moon",
              "wen moon",
              "diamond hands",
              "paper hands",
              "rekt",
              "liquidated",
              "margincall",
              "flash crash",
              "flash loan",
              "arbitrage",
              "MEV",
              "front running",
              "sandwich attack",
              "impermanent loss",
              "slippage",
              "gas fee",
              "gas limit",
              "gas price",
              "gwei",
              "wei",
              "satoshi",
              "gwei",
              "shannon",
              "finney",
              "szabo",
              "ether",
              "gwei",
              "megawei",
              "kiloether",
              "megaether",
              "gigaether",
              "teraether",
            ],
            breaking: [
              "breaking",
              "urgent",
              "alert",
              "news",
              "update",
              "developing",
              "live",
              "happening now",
              "just in",
              "latest",
              "recent",
              "today",
              "this week",
              "this month",
              "crisis",
              "emergency",
              "disaster",
              "attack",
              "bomb",
              "shooting",
              "fire",
              "flood",
              "earthquake",
              "hurricane",
              "tornado",
              "storm",
              "accident",
              "crash",
              "collision",
              "explosion",
              "outbreak",
              "pandemic",
              "epidemic",
              "virus",
              "disease",
              "health",
              "medical",
              "hospital",
              "clinic",
              "doctor",
              "nurse",
              "patient",
              "treatment",
              "vaccine",
              "medicine",
              "drug",
              "pharmaceutical",
              "FDA",
              "CDC",
              "WHO",
              "government",
              "official",
              "statement",
              "announcement",
              "press conference",
              "briefing",
              "report",
              "investigation",
              "arrest",
              "charges",
              "trial",
              "court",
              "judge",
              "jury",
              "verdict",
              "sentence",
              "prison",
              "jail",
              "bail",
              "bond",
              "fine",
              "penalty",
              "punishment",
              "crime",
              "criminal",
              "suspect",
              "victim",
              "witness",
              "evidence",
              "proof",
              "alibi",
              "confession",
              "guilty",
              "innocent",
              "acquittal",
              "conviction",
              "appeal",
              "mistrial",
              "retrial",
              "pardoned",
              "clemency",
              "commutation",
              "parole",
              "probation",
              "community service",
              "restitution",
              "damages",
              "settlement",
              "lawsuit",
              "litigation",
              "mediation",
              "arbitration",
              "negotiation",
              "agreement",
              "contract",
              "deal",
              "partnership",
              "merger",
              "acquisition",
              "takeover",
              "hostile takeover",
              "friendly takeover",
              "buyout",
              "IPO",
              "public offering",
              "private offering",
              "funding",
              "investment",
              "venture capital",
              "angel investor",
              "seed funding",
              "series A",
              "series B",
              "series C",
              "unicorn",
              "decacorn",
              "valuation",
              "market cap",
              "revenue",
              "profit",
              "loss",
              "earnings",
              "quarterly",
              "annual",
              "fiscal year",
              "budget",
              "expense",
              "cost",
              "price",
              "fee",
              "tax",
              "duty",
              "tariff",
              "subsidy",
              "grant",
              "loan",
              "debt",
              "credit",
              "interest",
              "rate",
              "percentage",
              "inflation",
              "deflation",
              "recession",
              "depression",
              "boom",
              "bust",
              "bubble",
              "crash",
              "correction",
              "rally",
              "surge",
              "spike",
              "dip",
              "drop",
              "fall",
              "rise",
              "increase",
              "decrease",
              "growth",
              "decline",
              "expansion",
              "contraction",
              "recovery",
              "rebound",
              "turnaround",
              "comeback",
              "breakthrough",
              "milestone",
              "achievement",
              "success",
              "failure",
              "mistake",
              "error",
              "bug",
              "glitch",
              "malfunction",
              "outage",
              "downtime",
              "maintenance",
              "upgrade",
              "update",
              "patch",
              "fix",
              "repair",
              "restore",
              "recover",
              "backup",
              "restore",
              "migration",
              "deployment",
              "launch",
              "release",
              "rollout",
              "beta",
              "alpha",
              "prototype",
              "demo",
              "pilot",
              "test",
              "trial",
              "experiment",
              "research",
              "study",
              "analysis",
              "report",
              "findings",
              "results",
              "conclusion",
              "recommendation",
              "suggestion",
              "proposal",
              "plan",
              "strategy",
              "tactic",
              "approach",
              "method",
              "technique",
              "process",
              "procedure",
              "protocol",
              "standard",
              "guideline",
              "rule",
              "regulation",
              "law",
              "act",
              "bill",
              "legislation",
              "policy",
              "directive",
              "order",
              "command",
              "instruction",
              "requirement",
              "specification",
              "criteria",
              "condition",
              "term",
              "clause",
              "provision",
              "stipulation",
              "restriction",
              "limitation",
              "constraint",
              "obstacle",
              "barrier",
              "challenge",
              "difficulty",
              "problem",
              "issue",
              "concern",
              "risk",
              "threat",
              "danger",
              "hazard",
              "peril",
              "menace",
              "warning",
              "caution",
              "alert",
              "notice",
              "advisory",
              "bulletin",
              "announcement",
              "communication",
              "message",
              "information",
              "data",
              "intelligence",
              "news",
              "report",
              "story",
              "article",
              "blog",
              "post",
              "tweet",
              "status",
              "update",
              "feed",
              "timeline",
              "stream",
              "broadcast",
              "live",
              "real-time",
              "instant",
              "immediate",
              "urgent",
              "critical",
              "important",
              "significant",
              "major",
              "minor",
              "small",
              "big",
              "large",
              "huge",
              "massive",
              "enormous",
              "tiny",
              "mini",
              "micro",
              "nano",
              "pico",
              "femto",
              "atto",
              "zepto",
              "yocto",
            ],
            new: [
              "new",
              "latest",
              "recent",
              "fresh",
              "just released",
              "just launched",
              "just announced",
              "unveiled",
              "introduced",
              "debut",
              "premiere",
              "first",
              "inaugural",
              "maiden",
              "pioneer",
              "groundbreaking",
              "revolutionary",
              "innovative",
              "cutting-edge",
              "state-of-the-art",
              "advanced",
              "modern",
              "contemporary",
              "current",
              "up-to-date",
              "updated",
              "upgraded",
              "enhanced",
              "improved",
              "refined",
              "polished",
              "perfected",
              "optimized",
              "streamlined",
              "simplified",
              "efficient",
              "effective",
              "powerful",
              "robust",
              "reliable",
              "stable",
              "secure",
              "safe",
              "trusted",
              "proven",
              "tested",
              "validated",
              "verified",
              "confirmed",
              "approved",
              "certified",
              "licensed",
              "registered",
              "patented",
              "trademarked",
              "copyrighted",
              "protected",
              "proprietary",
              "exclusive",
              "unique",
              "original",
              "creative",
              "novel",
              "unprecedented",
              "unheard of",
              "never before seen",
              "first of its kind",
              "one of a kind",
              "special",
              "exceptional",
              "outstanding",
              "remarkable",
              "extraordinary",
              "amazing",
              "incredible",
              "fantastic",
              "wonderful",
              "awesome",
              "brilliant",
              "genius",
              "smart",
              "intelligent",
              "clever",
              "wise",
              "insightful",
              "perceptive",
              "astute",
              "shrewd",
              "sharp",
              "keen",
              "acute",
              "penetrating",
              "deep",
              "profound",
              "meaningful",
              "significant",
              "important",
              "valuable",
              "precious",
              "rare",
              "scarce",
              "limited",
              "exclusive",
              "premium",
              "luxury",
              "high-end",
              "top-tier",
              "first-class",
              "world-class",
              "international",
              "global",
              "universal",
              "comprehensive",
              "complete",
              "full",
              "total",
              "entire",
              "whole",
              "all",
              "every",
              "each",
              "individual",
              "personal",
              "custom",
              "tailored",
              "bespoke",
              "made-to-order",
              "handcrafted",
              "artisan",
              "professional",
              "expert",
              "specialist",
              "master",
              "guru",
              "authority",
              "leader",
              "pioneer",
              "trailblazer",
              "innovator",
              "inventor",
              "creator",
              "founder",
              "developer",
              "designer",
              "architect",
              "engineer",
              "scientist",
              "researcher",
              "analyst",
              "consultant",
              "advisor",
              "mentor",
              "coach",
              "teacher",
              "instructor",
              "trainer",
              "educator",
              "professor",
              "doctor",
              "scholar",
              "academic",
              "intellectual",
              "thinker",
              "philosopher",
              "theorist",
              "practitioner",
              "professional",
              "expert",
              "specialist",
              "master",
              "guru",
              "authority",
              "leader",
            ],
            politics: [
              "Trump",
              "Biden",
              "election",
              "president",
              "presidential",
              "congress",
              "senate",
              "house",
              "republican",
              "democrat",
              "GOP",
              "liberal",
              "conservative",
              "campaign",
              "vote",
              "voting",
              "poll",
              "polling",
              "primary",
              "caucus",
              "debate",
              "rally",
              "inauguration",
              "swearing in",
              "state of the union",
              "impeachment",
              "cabinet",
              "secretary",
              "governor",
              "mayor",
              "senator",
              "representative",
              "congressman",
              "congresswoman",
              "politician",
              "policy",
              "legislation",
              "bill",
              "law",
              "act",
              "amendment",
              "constitution",
              "supreme court",
              "judge",
              "justice",
              "federal",
              "state",
              "local",
              "government",
              "administration",
              "white house",
              "capital",
              "washington",
              "dc",
              "political",
              "politics",
            ],
            sports: [
              "football",
              "soccer",
              "basketball",
              "baseball",
              "hockey",
              "tennis",
              "golf",
              "boxing",
              "MMA",
              "UFC",
              "Olympics",
              "World Cup",
              "Super Bowl",
              "NBA",
              "NFL",
              "MLB",
              "NHL",
              "MLS",
              "Premier League",
              "Champions League",
              "ESPN",
              "athlete",
              "player",
              "team",
              "game",
              "match",
              "tournament",
              "championship",
              "playoff",
              "final",
            ],
            earnings: [
              "earnings",
              "revenue",
              "profit",
              "loss",
              "quarterly",
              "annual",
              "Q1",
              "Q2",
              "Q3",
              "Q4",
              "fiscal",
              "financial",
              "results",
              "report",
              "beat",
              "miss",
              "guidance",
              "forecast",
              "estimate",
              "analyst",
              "EPS",
              "P/E",
              "valuation",
              "market cap",
              "IPO",
              "public offering",
              "stock",
              "shares",
              "dividend",
              "buyback",
              "merger",
              "acquisition",
            ],
            geopolitics: [
              "war",
              "conflict",
              "peace",
              "treaty",
              "alliance",
              "sanctions",
              "embargo",
              "trade war",
              "diplomacy",
              "summit",
              "meeting",
              "negotiation",
              "agreement",
              "Russia",
              "China",
              "Iran",
              "North Korea",
              "Israel",
              "Palestine",
              "Ukraine",
              "Syria",
              "Afghanistan",
              "Iraq",
              "Iran",
              "Saudi Arabia",
              "Turkey",
              "Egypt",
              "Libya",
              "Yemen",
              "Lebanon",
              "Jordan",
              "Kuwait",
              "UAE",
              "Qatar",
              "Bahrain",
              "Oman",
              "Yemen",
              "Somalia",
              "Sudan",
              "Ethiopia",
              "Eritrea",
              "Djibouti",
              "Kenya",
              "Tanzania",
              "Uganda",
              "Rwanda",
              "Burundi",
              "Congo",
              "Central African Republic",
              "Chad",
              "Cameroon",
              "Nigeria",
              "Niger",
              "Mali",
              "Burkina Faso",
              "Senegal",
              "Guinea",
              "Sierra Leone",
              "Liberia",
              "Ivory Coast",
              "Ghana",
              "Togo",
              "Benin",
              "Niger",
              "Mauritania",
              "Morocco",
              "Algeria",
              "Tunisia",
              "Libya",
              "Egypt",
              "Sudan",
              "South Sudan",
              "Ethiopia",
              "Eritrea",
              "Djibouti",
              "Somalia",
              "Kenya",
              "Tanzania",
              "Uganda",
              "Rwanda",
              "Burundi",
              "Congo",
              "Central African Republic",
              "Chad",
              "Cameroon",
              "Nigeria",
              "Niger",
              "Mali",
              "Burkina Faso",
              "Senegal",
              "Guinea",
              "Sierra Leone",
              "Liberia",
              "Ivory Coast",
              "Ghana",
              "Togo",
              "Benin",
              "Niger",
              "Mauritania",
            ],
            culture: [
              "movie",
              "film",
              "cinema",
              "television",
              "TV",
              "show",
              "series",
              "episode",
              "season",
              "premiere",
              "finale",
              "award",
              "Oscar",
              "Emmy",
              "Grammy",
              "Tony",
              "Golden Globe",
              "festival",
              "Cannes",
              "Sundance",
              "actor",
              "actress",
              "director",
              "producer",
              "writer",
              "screenplay",
              "script",
              "character",
              "role",
              "performance",
              "star",
              "celebrity",
              "famous",
              "popular",
              "trending",
              "viral",
              "meme",
              "social media",
              "Instagram",
              "Twitter",
              "TikTok",
              "YouTube",
              "influencer",
              "blogger",
              "vlogger",
              "podcast",
              "music",
              "song",
              "album",
              "artist",
              "band",
              "singer",
              "musician",
              "composer",
              "lyrics",
              "concert",
              "tour",
              "performance",
              "show",
              "gig",
              "venue",
              "theater",
              "stadium",
              "arena",
              "auditorium",
              "hall",
              "club",
              "bar",
              "restaurant",
              "cafe",
              "coffee shop",
              "book",
              "novel",
              "story",
              "author",
              "writer",
              "poet",
              "poetry",
              "literature",
              "publishing",
              "magazine",
              "newspaper",
              "article",
              "blog",
              "website",
              "art",
              "painting",
              "sculpture",
              "drawing",
              "photography",
              "gallery",
              "museum",
              "exhibition",
              "display",
              "collection",
              "artwork",
              "masterpiece",
              "creation",
              "design",
              "fashion",
              "style",
              "trend",
              "fad",
              "culture",
              "society",
              "community",
              "group",
              "organization",
              "club",
              "association",
              "foundation",
              "charity",
              "nonprofit",
              "volunteer",
              "activist",
              "advocate",
              "campaign",
              "movement",
              "protest",
              "demonstration",
              "rally",
              "march",
              "petition",
              "signature",
              "support",
              "oppose",
              "boycott",
              "strike",
              "walkout",
              "sit-in",
              "occupation",
              "takeover",
              "revolution",
              "rebellion",
              "uprising",
              "revolt",
              "coup",
              "overthrow",
              "regime change",
              "democracy",
              "freedom",
              "liberty",
              "rights",
              "justice",
              "equality",
              "fairness",
              "discrimination",
              "racism",
              "sexism",
              "homophobia",
              "transphobia",
              "xenophobia",
              "antisemitism",
              "islamophobia",
              "hate",
              "violence",
              "crime",
              "terrorism",
              "extremism",
              "radicalization",
              "recruitment",
              "propaganda",
              "disinformation",
              "misinformation",
              "fake news",
              "conspiracy",
              "theory",
              "hoax",
              "scam",
              "fraud",
              "corruption",
              "scandal",
              "controversy",
              "outrage",
              "backlash",
              "criticism",
              "complaint",
              "protest",
              "boycott",
              "cancellation",
              "ban",
              "censor",
              "suppress",
              "silence",
              "muzzle",
              "gag order",
              "injunction",
              "restraining order",
              "lawsuit",
              "legal action",
              "court case",
              "trial",
              "verdict",
              "judgment",
              "sentence",
              "punishment",
              "penalty",
              "fine",
              "damages",
              "compensation",
              "settlement",
              "agreement",
              "contract",
              "deal",
              "partnership",
              "collaboration",
              "cooperation",
              "alliance",
              "union",
              "merger",
              "acquisition",
              "takeover",
              "buyout",
              "investment",
              "funding",
              "sponsorship",
              "endorsement",
              "support",
              "backing",
              "approval",
              "blessing",
              "permission",
              "authorization",
              "license",
              "permit",
              "certificate",
              "diploma",
              "degree",
              "qualification",
              "credential",
              "certification",
              "accreditation",
              "recognition",
              "honor",
              "award",
              "prize",
              "trophy",
              "medal",
              "badge",
              "ribbon",
              "certificate",
              "diploma",
              "degree",
              "qualification",
              "achievement",
              "accomplishment",
              "success",
              "victory",
              "win",
              "triumph",
              "conquest",
              "domination",
              "supremacy",
              "leadership",
              "authority",
              "power",
              "influence",
              "control",
              "command",
              "rule",
              "governance",
              "management",
              "administration",
              "supervision",
              "oversight",
              "monitoring",
              "surveillance",
              "inspection",
              "audit",
              "review",
              "evaluation",
              "assessment",
              "analysis",
              "examination",
              "investigation",
              "inquiry",
              "probe",
              "search",
              "hunt",
              "quest",
              "mission",
              "journey",
              "adventure",
              "expedition",
              "exploration",
              "discovery",
              "finding",
              "result",
              "outcome",
              "consequence",
              "effect",
              "impact",
              "influence",
              "change",
              "transformation",
              "evolution",
              "development",
              "progress",
              "advancement",
              "improvement",
              "enhancement",
              "upgrade",
              "modernization",
              "innovation",
              "invention",
              "creation",
              "design",
              "development",
              "production",
              "manufacturing",
              "construction",
              "building",
              "making",
              "creating",
              "designing",
              "planning",
              "organizing",
              "coordinating",
              "managing",
              "leading",
              "directing",
              "guiding",
              "instructing",
              "teaching",
              "training",
              "educating",
              "informing",
              "communicating",
              "sharing",
              "exchanging",
              "trading",
              "buying",
              "selling",
              "marketing",
              "advertising",
              "promoting",
              "publicizing",
              "announcing",
              "declaring",
              "proclaiming",
              "stating",
              "saying",
              "telling",
              "speaking",
              "talking",
              "discussing",
              "debating",
              "arguing",
              "disagreeing",
              "agreeing",
              "consenting",
              "approving",
              "accepting",
              "rejecting",
              "refusing",
              "denying",
              "contradicting",
              "challenging",
              "questioning",
              "doubting",
              "wondering",
              "thinking",
              "considering",
              "pondering",
              "reflecting",
              "meditating",
              "contemplating",
              "studying",
              "learning",
              "understanding",
              "comprehending",
              "grasping",
              "realizing",
              "recognizing",
              "identifying",
              "distinguishing",
              "differentiating",
              "comparing",
              "contrasting",
              "analyzing",
              "evaluating",
              "assessing",
              "judging",
              "criticizing",
              "praising",
              "complimenting",
              "congratulating",
              "celebrating",
              "commemorating",
              "remembering",
              "recalling",
              "reminiscing",
              "nostalgia",
              "sentiment",
              "emotion",
              "feeling",
              "mood",
              "atmosphere",
              "ambiance",
              "environment",
              "setting",
              "scene",
              "background",
              "context",
              "situation",
              "circumstance",
              "condition",
              "state",
              "status",
              "position",
              "location",
              "place",
              "space",
              "area",
              "region",
              "territory",
              "country",
              "nation",
              "state",
              "city",
              "town",
              "village",
              "community",
              "neighborhood",
              "district",
              "ward",
              "precinct",
              "zone",
              "sector",
              "section",
              "part",
              "portion",
              "piece",
              "fragment",
              "segment",
              "division",
              "category",
              "class",
              "type",
              "kind",
              "sort",
              "variety",
              "species",
              "breed",
              "strain",
              "version",
              "edition",
              "model",
              "brand",
              "make",
              "manufacturer",
              "producer",
              "creator",
              "inventor",
              "designer",
              "architect",
              "engineer",
              "developer",
              "programmer",
              "coder",
              "analyst",
              "researcher",
              "scientist",
              "scholar",
              "academic",
              "professor",
              "teacher",
              "instructor",
              "trainer",
              "coach",
              "mentor",
              "advisor",
              "consultant",
              "expert",
              "specialist",
              "professional",
              "practitioner",
              "worker",
              "employee",
              "staff",
              "personnel",
              "team",
              "crew",
              "group",
              "organization",
              "company",
              "corporation",
              "business",
              "enterprise",
              "firm",
              "agency",
              "institution",
              "establishment",
              "foundation",
              "association",
              "society",
              "club",
              "union",
              "guild",
              "fraternity",
              "sorority",
              "brotherhood",
              "sisterhood",
              "fellowship",
              "partnership",
              "alliance",
              "coalition",
              "federation",
              "confederation",
              "league",
              "association",
              "society",
              "organization",
              "institution",
              "establishment",
              "foundation",
              "corporation",
              "company",
              "business",
              "enterprise",
              "firm",
              "agency",
              "bureau",
              "department",
              "division",
              "section",
              "unit",
              "branch",
              "office",
              "headquarters",
              "base",
              "facility",
              "plant",
              "factory",
              "workshop",
              "studio",
              "laboratory",
              "research center",
              "development center",
              "innovation center",
              "technology center",
              "business center",
              "commercial center",
              "shopping center",
              "retail center",
              "entertainment center",
              "cultural center",
              "community center",
              "conference center",
              "convention center",
              "exhibition center",
              "sports center",
              "fitness center",
              "health center",
              "medical center",
              "hospital",
              "clinic",
              "pharmacy",
              "laboratory",
              "research facility",
              "testing facility",
              "manufacturing facility",
              "production facility",
              "distribution center",
              "warehouse",
              "storage facility",
              "logistics center",
              "transportation hub",
              "airport",
              "train station",
              "bus station",
              "port",
              "harbor",
              "marina",
              "dock",
              "pier",
              "wharf",
              "terminal",
              "depot",
              "garage",
              "parking lot",
              "parking garage",
              "parking structure",
              "ramp",
              "elevator",
              "escalator",
              "staircase",
              "stairs",
              "steps",
              "walkway",
              "pathway",
              "sidewalk",
              "street",
              "road",
              "highway",
              "freeway",
              "expressway",
              "parkway",
              "boulevard",
              "avenue",
              "drive",
              "lane",
              "way",
              "place",
              "court",
              "circle",
              "square",
              "plaza",
              "mall",
              "shopping mall",
              "strip mall",
              "outlet mall",
              "flea market",
              "farmer's market",
              "bazaar",
              "marketplace",
              "store",
              "shop",
              "boutique",
              "department store",
              "supermarket",
              "grocery store",
              "convenience store",
              "gas station",
              "restaurant",
              "cafe",
              "coffee shop",
              "bar",
              "pub",
              "tavern",
              "lounge",
              "club",
              "nightclub",
              "dance club",
              "music venue",
              "theater",
              "cinema",
              "movie theater",
              "drive-in",
              "amphitheater",
              "stadium",
              "arena",
              "coliseum",
              "auditorium",
              "concert hall",
              "opera house",
              "ballet",
              "dance",
              "music",
              "orchestra",
              "band",
              "choir",
              "ensemble",
              "group",
              "troupe",
              "company",
              "organization",
              "institution",
              "establishment",
              "foundation",
              "corporation",
              "business",
              "enterprise",
              "firm",
              "agency",
              "bureau",
              "department",
              "division",
              "section",
              "unit",
              "branch",
              "office",
              "headquarters",
              "base",
              "facility",
              "plant",
              "factory",
              "workshop",
              "studio",
              "laboratory",
              "research center",
              "development center",
              "innovation center",
              "technology center",
            ],
            world: [
              "international",
              "global",
              "worldwide",
              "universal",
              "foreign",
              "overseas",
              "abroad",
              "nation",
              "country",
              "state",
              "government",
              "UN",
              "United Nations",
              "NATO",
              "EU",
              "European Union",
              "ASEAN",
              "G7",
              "G20",
              "WTO",
              "World Trade Organization",
              "IMF",
              "International Monetary Fund",
              "World Bank",
              "WHO",
              "World Health Organization",
              "UNESCO",
              "UNICEF",
              "Red Cross",
              "humanitarian",
              "aid",
              "relief",
              "disaster",
              "crisis",
              "emergency",
              "conflict",
              "war",
              "peace",
              "treaty",
              "summit",
              "conference",
              "meeting",
              "negotiation",
            ],
            economy: [
              "economy",
              "economic",
              "GDP",
              "inflation",
              "recession",
              "depression",
              "boom",
              "bust",
              "market",
              "stock",
              "bond",
              "currency",
              "exchange rate",
              "interest rate",
              "Federal Reserve",
              "Fed",
              "central bank",
              "monetary policy",
              "fiscal policy",
              "budget",
              "deficit",
              "surplus",
              "debt",
              "trade",
              "import",
              "export",
              "tariff",
              "tax",
              "unemployment",
              "job",
              "employment",
              "wage",
              "salary",
              "income",
              "wealth",
              "poverty",
              "inequality",
            ],
            trump: [
              "Trump",
              "Donald Trump",
              "DJT",
              "Trump administration",
              "Trump campaign",
              "Trump rally",
              "Trump tweet",
              "Trump statement",
              "Trump policy",
              "Trump decision",
              "Trump order",
              "executive order",
              "Trump Tower",
              "Mar-a-Lago",
              "Trump Organization",
              "Trump Foundation",
              "Trump University",
              "Trump Casino",
              "Trump Hotel",
              "Trump Resort",
              "Trump Golf",
              "Trump Entertainment",
              "Trump Media",
              "Truth Social",
              "Trump TV",
              "Trump Radio",
              "Trump Podcast",
              "Trump Interview",
              "Trump Speech",
              "Trump Debate",
              "Trump Press Conference",
              "Trump Briefing",
              "Trump Meeting",
              "Trump Summit",
              "Trump Negotiation",
              "Trump Deal",
              "Trump Agreement",
              "Trump Contract",
              "Trump Partnership",
              "Trump Alliance",
              "Trump Coalition",
              "Trump Support",
              "Trump Endorsement",
              "Trump Approval",
              "Trump Rating",
              "Trump Poll",
              "Trump Survey",
              "Trump Vote",
              "Trump Election",
              "Trump Campaign",
              "Trump Rally",
              "Trump Event",
              "Trump Appearance",
              "Trump Visit",
              "Trump Trip",
              "Trump Travel",
              "Trump Schedule",
              "Trump Agenda",
              "Trump Priority",
              "Trump Focus",
              "Trump Goal",
              "Trump Objective",
              "Trump Mission",
              "Trump Vision",
              "Trump Plan",
              "Trump Strategy",
              "Trump Approach",
              "Trump Method",
              "Trump Tactic",
              "Trump Style",
              "Trump Way",
              "Trump Manner",
              "Trump Approach",
              "Trump Method",
              "Trump Technique",
              "Trump Process",
              "Trump Procedure",
              "Trump Protocol",
              "Trump Standard",
              "Trump Guideline",
              "Trump Rule",
              "Trump Regulation",
              "Trump Law",
              "Trump Act",
              "Trump Bill",
              "Trump Legislation",
              "Trump Policy",
              "Trump Directive",
              "Trump Order",
              "Trump Command",
              "Trump Instruction",
              "Trump Requirement",
              "Trump Specification",
              "Trump Criteria",
              "Trump Condition",
              "Trump Term",
              "Trump Clause",
              "Trump Provision",
              "Trump Stipulation",
              "Trump Restriction",
              "Trump Limitation",
              "Trump Constraint",
              "Trump Obstacle",
              "Trump Barrier",
              "Trump Challenge",
              "Trump Difficulty",
              "Trump Problem",
              "Trump Issue",
              "Trump Concern",
              "Trump Risk",
              "Trump Threat",
              "Trump Danger",
              "Trump Hazard",
              "Trump Peril",
              "Trump Menace",
              "Trump Warning",
              "Trump Caution",
              "Trump Alert",
              "Trump Notice",
              "Trump Advisory",
              "Trump Bulletin",
              "Trump Announcement",
              "Trump Communication",
              "Trump Message",
              "Trump Information",
              "Trump Data",
              "Trump Intelligence",
              "Trump News",
              "Trump Report",
              "Trump Story",
              "Trump Article",
              "Trump Blog",
              "Trump Post",
              "Trump Tweet",
              "Trump Status",
              "Trump Update",
              "Trump Feed",
              "Trump Timeline",
              "Trump Stream",
              "Trump Broadcast",
              "Trump Live",
              "Trump Real-time",
              "Trump Instant",
              "Trump Immediate",
              "Trump Urgent",
              "Trump Critical",
              "Trump Important",
              "Trump Significant",
              "Trump Major",
              "Trump Minor",
              "Trump Small",
              "Trump Big",
              "Trump Large",
              "Trump Huge",
              "Trump Massive",
              "Trump Enormous",
              "Trump Tiny",
              "Trump Mini",
              "Trump Micro",
              "Trump Nano",
              "Trump Pico",
              "Trump Femto",
              "Trump Atto",
              "Trump Zepto",
              "Trump Yocto",
            ],
            elections: [
              "election",
              "elections",
              "vote",
              "voting",
              "ballot",
              "ballots",
              "poll",
              "polls",
              "polling",
              "primary",
              "primaries",
              "caucus",
              "caucuses",
              "general election",
              "presidential election",
              "congressional election",
              "senate election",
              "house election",
              "gubernatorial election",
              "mayoral election",
              "local election",
              "state election",
              "federal election",
              "midterm election",
              "special election",
              "runoff election",
              "recall election",
              "referendum",
              "initiative",
              "proposition",
              "amendment",
              "candidate",
              "candidates",
              "nominee",
              "nominees",
              "incumbent",
              "incumbents",
              "challenger",
              "challengers",
              "opponent",
              "opponents",
              "rival",
              "rivals",
              "competitor",
              "competitors",
              "contender",
              "contenders",
              "hopeful",
              "hopefuls",
              "prospect",
              "prospects",
              "frontrunner",
              "frontrunners",
              "underdog",
              "underdogs",
              "dark horse",
              "dark horses",
              "favorite",
              "favorites",
              "longshot",
              "longshots",
              "campaign",
              "campaigns",
              "campaigning",
              "campaigner",
              "campaigners",
              "campaign manager",
              "campaign managers",
              "campaign staff",
              "campaign workers",
              "campaign volunteers",
              "campaign supporters",
              "campaign donors",
              "campaign contributors",
              "campaign fundraisers",
              "campaign finance",
              "campaign funding",
              "campaign budget",
              "campaign spending",
              "campaign expenditure",
              "campaign cost",
              "campaign expense",
              "campaign investment",
              "campaign return",
              "campaign yield",
              "campaign result",
              "campaign outcome",
              "campaign success",
              "campaign failure",
              "campaign victory",
              "campaign defeat",
              "campaign win",
              "campaign loss",
              "campaign triumph",
              "campaign disaster",
              "campaign fiasco",
              "campaign debacle",
              "campaign catastrophe",
              "campaign calamity",
              "campaign tragedy",
              "campaign comedy",
              "campaign farce",
              "campaign joke",
              "campaign embarrassment",
              "campaign humiliation",
              "campaign disgrace",
              "campaign scandal",
              "campaign controversy",
              "campaign issue",
              "campaign problem",
              "campaign difficulty",
              "campaign challenge",
              "campaign obstacle",
              "campaign barrier",
              "campaign hurdle",
              "campaign setback",
              "campaign reversal",
              "campaign turnaround",
              "campaign comeback",
              "campaign recovery",
              "campaign rebound",
              "campaign surge",
              "campaign rally",
              "campaign momentum",
              "campaign boost",
              "campaign lift",
              "campaign push",
              "campaign drive",
              "campaign effort",
              "campaign work",
              "campaign labor",
              "campaign toil",
              "campaign grind",
              "campaign hustle",
              "campaign hustle",
              "campaign bustle",
              "campaign activity",
              "campaign action",
              "campaign movement",
              "campaign progress",
              "campaign advancement",
              "campaign development",
              "campaign growth",
              "campaign expansion",
              "campaign increase",
              "campaign rise",
              "campaign climb",
              "campaign ascent",
              "campaign elevation",
              "campaign promotion",
              "campaign upgrade",
              "campaign improvement",
              "campaign enhancement",
              "campaign refinement",
              "campaign perfection",
              "campaign optimization",
              "campaign maximization",
              "campaign utilization",
              "campaign exploitation",
              "campaign leverage",
              "campaign advantage",
              "campaign benefit",
              "campaign gain",
              "campaign profit",
              "campaign return",
              "campaign yield",
              "campaign dividend",
              "campaign reward",
              "campaign prize",
              "campaign trophy",
              "campaign medal",
              "campaign honor",
              "campaign recognition",
              "campaign acclaim",
              "campaign praise",
              "campaign commendation",
              "campaign approval",
              "campaign endorsement",
              "campaign support",
              "campaign backing",
              "campaign sponsorship",
              "campaign patronage",
              "campaign assistance",
              "campaign help",
              "campaign aid",
              "campaign relief",
              "campaign support",
              "campaign encouragement",
              "campaign motivation",
              "campaign inspiration",
              "campaign guidance",
              "campaign direction",
              "campaign leadership",
              "campaign management",
              "campaign administration",
              "campaign coordination",
              "campaign organization",
              "campaign planning",
              "campaign strategy",
              "campaign tactics",
              "campaign approach",
              "campaign method",
              "campaign technique",
              "campaign process",
              "campaign procedure",
              "campaign protocol",
              "campaign standard",
              "campaign guideline",
              "campaign rule",
              "campaign regulation",
              "campaign law",
              "campaign act",
              "campaign bill",
              "campaign legislation",
              "campaign policy",
              "campaign directive",
              "campaign order",
              "campaign command",
              "campaign instruction",
              "campaign requirement",
              "campaign specification",
              "campaign criteria",
              "campaign condition",
              "campaign term",
              "campaign clause",
              "campaign provision",
              "campaign stipulation",
              "campaign restriction",
              "campaign limitation",
              "campaign constraint",
              "campaign obstacle",
              "campaign barrier",
              "campaign challenge",
              "campaign difficulty",
              "campaign problem",
              "campaign issue",
              "campaign concern",
              "campaign risk",
              "campaign threat",
              "campaign danger",
              "campaign hazard",
              "campaign peril",
              "campaign menace",
              "campaign warning",
              "campaign caution",
              "campaign alert",
              "campaign notice",
              "campaign advisory",
              "campaign bulletin",
              "campaign announcement",
              "campaign communication",
              "campaign message",
              "campaign information",
              "campaign data",
              "campaign intelligence",
              "campaign news",
              "campaign report",
              "campaign story",
              "campaign article",
              "campaign blog",
              "campaign post",
              "campaign tweet",
              "campaign status",
              "campaign update",
              "campaign feed",
              "campaign timeline",
              "campaign stream",
              "campaign broadcast",
              "campaign live",
              "campaign real-time",
              "campaign instant",
              "campaign immediate",
              "campaign urgent",
              "campaign critical",
              "campaign important",
              "campaign significant",
              "campaign major",
              "campaign minor",
              "campaign small",
              "campaign big",
              "campaign large",
              "campaign huge",
              "campaign massive",
              "campaign enormous",
              "campaign tiny",
              "campaign mini",
              "campaign micro",
              "campaign nano",
              "campaign pico",
              "campaign femto",
              "campaign atto",
              "campaign zepto",
              "campaign yocto",
            ],
          };

          return keywordMap[category] || [];
        };

        OmegaMinerTerminal.prototype.isMarketInCategory = function (
          market,
          keywords
        ) {
          const searchText = `${market.question || ""} ${
            market.description || ""
          } ${market.category || ""}`.toLowerCase();

          // Check if any keyword matches (more flexible matching)
          const matches = keywords.filter((keyword) => {
            const keywordLower = keyword.toLowerCase();
            // Exact match or word boundary match for better accuracy
            return (
              searchText.includes(keywordLower) ||
              searchText.includes(` ${keywordLower} `) ||
              searchText.startsWith(`${keywordLower} `) ||
              searchText.endsWith(` ${keywordLower}`)
            );
          });

          if (matches.length > 0) {
            console.log(
              `🎯 Category match found: "${matches[0]}" in "${market.question}"`
            );
            return true;
          }

          return false;
        };

        // Add Perp command handler - Updated to use iframe viewer
        OmegaMinerTerminal.prototype.handlePerpCommand = function (args) {
          // Check if perps viewer is available
          if (window.OmegaPerpsViewer) {
            // Open the perps viewer panel
            window.OmegaPerpsViewer.openPanel();
          } else {
            this.log(
              "❌ Perps Viewer not loaded. Please refresh the page.",
              "error"
            );
          }
        };

        console.log(
          "🔧 DEBUG: Polymarket and Perp functions loaded successfully!"
        );
      } else {
        console.log(
          "🔧 DEBUG: Terminal prototype not found, Polymarket and Perp functions not loaded"
        );
      }

      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOMContentLoaded - creating new terminal instance");
        window.terminal = new OmegaMinerTerminal();
        // init() is already called in the constructor, so we don't need to call it again
      });
    </script>
    <!-- <script src="js/ai-dropdown-fix.js"></script> -->
    <!-- File doesn't exist - commented out -->
    <!-- <script src="js/command-input-fix.js"></script> -->
    <!-- File doesn't exist - commented out -->
    <script src="js/welcome-screen-color-integration-new.js"></script>
    <script src="js/terminal-output-color-integration.js"></script>

    <!-- Global Color Palette Cycle Function -->
    <script>
      // Global color palette cycle function for header button
      window.cycleColorPalette = function () {
        const palettes = [
          "red",
          "anime",
          "ocean",
          "forest",
          "sunset",
          "purple",
          "cyber",
          "gold",
          "ice",
          "fire",
          "mint",
          "rose",
          "amber",
          "slate",
        ];

        // Get current palette from localStorage or default to 'cyber'
        const currentPalette =
          localStorage.getItem("omega-color-palette") || "cyber";
        const currentIndex = palettes.indexOf(currentPalette);

        // Get next palette (cycle back to start if at end)
        const nextIndex = (currentIndex + 1) % palettes.length;
        const nextPalette = palettes[nextIndex];

        // Execute the color command
        if (window.terminal && window.terminal.executeCommand) {
          window.terminal.executeCommand(`color ${nextPalette}`);
        } else if (
          window.FuturisticDashboard &&
          window.FuturisticDashboard.cycleColorPalette
        ) {
          window.FuturisticDashboard.cycleColorPalette();
        } else {
          // Fallback: directly set the palette
          if (window.OmegaCommands && window.OmegaCommands.Color) {
            window.OmegaCommands.Color.setColorPalette(nextPalette);
          }
        }

        // Show feedback
        if (window.terminal && window.terminal.log) {
          window.terminal.log(`Cycling to ${nextPalette} palette`, "success");
        }
      };

      // Global theme cycle function for header button
      window.cycleTheme = function () {
        const themes = [
          "executive",
          "modern",
          "dark",
          "light",
          "matrix",
          "retro",
          "powershell",
        ];

        // Get current theme from localStorage or detect from DOM
        let currentTheme =
          localStorage.getItem("omega-terminal-theme") || "dark";

        // Check if Modern UI is currently active
        const terminal =
          document.getElementById("terminal") ||
          document.querySelector(".terminal");
        const isModernUIActive =
          terminal && terminal.classList.contains("apple-ui");

        if (isModernUIActive) {
          // If Modern UI is active, we need to deactivate it first
          if (window.terminal && window.terminal.deactivateAppleUI) {
            window.terminal.deactivateAppleUI();
          }
          currentTheme = "modern"; // Set as current for cycling
        }

        const currentIndex = themes.indexOf(currentTheme);

        // Get next theme (cycle back to start if at end)
        const nextIndex = (currentIndex + 1) % themes.length;
        const nextTheme = themes[nextIndex];

        // Special handling for Modern UI theme
        if (nextTheme === "modern") {
          // Activate Modern UI directly
          if (window.terminal && window.terminal.activateAppleUI) {
            window.terminal.activateAppleUI(false); // Light mode
            localStorage.setItem("omega-terminal-theme", "modern");
          } else {
            // Fallback to command execution
            if (window.terminal && window.terminal.executeCommand) {
              window.terminal.executeCommand(`theme ${nextTheme}`);
            }
          }
        } else {
          // For other themes, execute normally
          if (window.terminal && window.terminal.executeCommand) {
            window.terminal.executeCommand(`theme ${nextTheme}`);
          } else if (
            window.FuturisticDashboard &&
            window.FuturisticDashboard.cycleTheme
          ) {
            window.FuturisticDashboard.cycleTheme();
          }
        }

        // Show feedback
        if (window.terminal && window.terminal.log) {
          window.terminal.log(`Cycling to ${nextTheme} theme`, "success");
          console.log(
            `[Global Theme Cycle] Switched from ${currentTheme} to ${nextTheme}`
          );
        }
      };
    </script>
  </body>
</html>
